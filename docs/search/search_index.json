{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"LatentLego - flexible latent spaces for single cells LatentLego is a python library for building autoencoders for single-cell genomics. It is build on top of TensorFlow and Keras and provides modular components to build common single-cell autoencoder architectures. All individual comonents are valid Keras Layer or Model objects and therefore support model construction using the standard Keras (functional/sequential) API. There is also a model zoo of preconstructed models that understand builtin Keras methods like .fit() or .predict() and .compile() with custom loss functions. Installation You can install LatentLego from PyPI using pip pip install latent or install the development version from GitHub pip install git + https : // github . com / quadbiolab / latent - lego Overview LatentLego is designed to be a flexible kit for defining autoencoders by providing common building blocks that can be freely assembled. Here's an overview: latent.models - Here you can find Keras-compatible implementations of common single-cell autoencoder architectures, such as the ZINBAutoencoder ( Erslan 2019 ) or the NegativeBinomialVAE ( Lopez 2018 ). I also implemented some more experimental architectures like the TopologicalAutoencoder ( Moor 2019 ). latent.modules - Here live the lower level building blocks of autoencoders, namely encoder and decoder models that can be freely assembled to produce autoencoder models. E.g., using a VariationalEncoder with a PoissonDecoder produces a PoissonVAE , a variational autoencoder with a poisson reconstruction loss. latent.layers - These are the most basic building blocks of encoder and decoder models. In addition to the DenseBlock / DenseStack layers that are the core component of encoders and decoders, I implemeneted some other useful utility layers. latent.losses , latent.activations , latent.callbacks - Keras-style components that are useful for single-cell data, like a NegativeBinomial loss or a KLDivergenceScheduler callback function. All of these should work nicely within the TensorFlow/Keras framework.","title":"About"},{"location":"#latentlego-flexible-latent-spaces-for-single-cells","text":"LatentLego is a python library for building autoencoders for single-cell genomics. It is build on top of TensorFlow and Keras and provides modular components to build common single-cell autoencoder architectures. All individual comonents are valid Keras Layer or Model objects and therefore support model construction using the standard Keras (functional/sequential) API. There is also a model zoo of preconstructed models that understand builtin Keras methods like .fit() or .predict() and .compile() with custom loss functions.","title":"LatentLego  - flexible latent spaces for single cells"},{"location":"#installation","text":"You can install LatentLego from PyPI using pip pip install latent or install the development version from GitHub pip install git + https : // github . com / quadbiolab / latent - lego","title":"Installation"},{"location":"#overview","text":"LatentLego is designed to be a flexible kit for defining autoencoders by providing common building blocks that can be freely assembled. Here's an overview: latent.models - Here you can find Keras-compatible implementations of common single-cell autoencoder architectures, such as the ZINBAutoencoder ( Erslan 2019 ) or the NegativeBinomialVAE ( Lopez 2018 ). I also implemented some more experimental architectures like the TopologicalAutoencoder ( Moor 2019 ). latent.modules - Here live the lower level building blocks of autoencoders, namely encoder and decoder models that can be freely assembled to produce autoencoder models. E.g., using a VariationalEncoder with a PoissonDecoder produces a PoissonVAE , a variational autoencoder with a poisson reconstruction loss. latent.layers - These are the most basic building blocks of encoder and decoder models. In addition to the DenseBlock / DenseStack layers that are the core component of encoders and decoders, I implemeneted some other useful utility layers. latent.losses , latent.activations , latent.callbacks - Keras-style components that are useful for single-cell data, like a NegativeBinomial loss or a KLDivergenceScheduler callback function. All of these should work nicely within the TensorFlow/Keras framework.","title":"Overview"},{"location":"quickstart/","text":"Quickstart LatentLego is like a lego box with building blocks for autoencoders. These building blocks are hierarchically assembled into larger components, each of which can be used in a modular way to define a model. To make this more clear, lets start with some examples. Using pre-defined models LatentLego hosts a model zoo with a number of common autoencoder architectures ready to use. They are subclassed Keras Model objects and understand common methods like .fit() and .predict() . So the quickest way to train an autoencoder with LatentLego is simply import numpy as np from latent.models import Autoencoder x_train = np . array ([ np . random . poisson ( lam = 5 , size = 100 ) for i in range ( 100 )]) # Creates an autoencoder model with a 2-dimensional latent space ae = Autoencoder ( latent_dim = 2 , x_dim = x_train . shape [ 1 ], activation = 'relu' ) # Compiled the model with a poisson loss and a Adam optimizer ae . compile ( loss = 'mse' , optimizer = 'adam' ) # Trains the model on x_train ae . fit ( x_train , epochs = 10 , batch_size = 10 ) This trained autoencoder model can now be used to yield a low dimensional representation of the input (or new) data. In line with the scikit-learn API, autoencoder models in LatentLego have a .transform() method, which returns the low dimensional representation. x_latent = ae . transform ( x_train ) Using .predict() gives us the reconstructred input data after being passed through the bottleneck. This representation can be used for denoising of single-cell data ( Erslan 2019 ). x_recon = ae . predict ( x_train ) Defining models by combining encoder and decoder The second way to define a model with LatentLego is to pick any of the provided encoder and decoder models and combine them using the Autoencoder data structure. For instance, if you want to create a variational autoencoder with a negative binomial reconstruction loss you can simply combine a VariationalEncoder with a NegativeBinomialDecoder : from latent.modules import VariationalEncoder , NegativeBinomialDecoder # Creates a VariationalEncoder with a standard normal prior encoder = VariationalEncoder ( latent_dim = 20 , prior = 'normal' , kld_weight = 0.01 ) # Creates a NegativeBinomialDecoder with a constant dispersion estimate decoder = NegativeBinomialDecoder ( x_dim = x_train . shape [ 1 ], dispersion = 'constant' ) # Constructs an Autoencoder object with predefined encoder and decoder ae = Autoencoder ( encoder = encoder , decoder = decoder ) ae . compile () # Fit input data using size factors for each cell x_sf = np . array ([ 1. ] * 100 ) ae . fit ([ x_train , x_sf ], epochs = 10 , batch_size = 10 ) You might have noticed that this time we did not define a loss function. This is because some encoder and decoder models take care of the model loss on their own. Generally in LatentLego, encoders are responsible for adding losses related to the latent space, such as the KLDivergence loss of a VAE and decoders add the reconstruction loss. If you anyway decide to pass a loss function to .compile() it will be added to the reconstruction loss defined by the decoder. The Autoencoder data structure subclasses the Keras Model and takes care of providing additional methods like .transform() and handling cases with multiple inputs like conditions or size factors. But since encoder and decoder models are just Keras Model objects themselves, they can also be used with the Keras Functional API: from tensorflow.keras import Input , Model from latent.modules import Encoder , Decoder x = Input ( shape = ( x_train . shape [ 1 ],)) x_latent = Encoder ( latent_dim = 2 )( x ) # Decoders take the latent and the original data space as the input # so they can add the reconstruction loss x_rec = Decoder ( x_dim = x_train . shape [ 1 ])([ x , x_latent ]) ae = Model ( inputs = x , outputs = x_rec ) ae . compile ( loss = 'mse' , optimizer = 'adam' , run_eagerly = False ) ae . fit ( x = x_train , y = x_train , epochs = 10 , batch_size = 10 ) Building autoencoders from scratch Lastly, if you want to implement a model that can not be directly assembled in LatentLego, you may want to implement the encoder/decoder or both from scratch. For this, we also provide some convenient lower-level components that extend the reportoire of Keras and TensorFlow. For instance, the DenseStack layer strings together a sequence of DenseBlock layers and take care of batch normalization, dropout and conditional injection. We can combine it with some TensorFlow Probability magic and stack it on top of a NegativeBinomialDecoder to obtain a VAE with negative binomial loss. import tensorflow as tf from tensorflow.keras import Sequential , Input , Model import tensorflow_probability as tfp tfpl = tfp . layers tfd = tfp . distributions from latent.layers import DenseStack from latent.modules import NegativeBinomialDecoder latent_dim = 2 # Initiate standard normal prior prior = tfd . Independent ( tfd . Normal ( loc = tf . zeros ( latent_dim ), scale = 1 ), reinterpreted_batch_ndims = 1 ) # Construct encoder with sequential model encoder = Sequential ([ DenseStack ( hidden_units = [ 256 , 128 , 56 ], batchnorm = True , dropout_rate = 0.2 ), tf . keras . layers . Dense ( tfpl . MultivariateNormalTriL . params_size ( latent_dim ), activation = 'linear' ), tfpl . MultivariateNormalTriL ( latent_dim , activity_regularizer = tfpl . KLDivergenceRegularizer ( prior )) ]) # Initiate a NB decoder with a per-gene dispersion estimate decoder = NegativeBinomialDecoder ( x_dim = x_train . shape [ 1 ], dispersion = 'gene' ) x_in = Input ( shape = ( x_train . shape [ 1 ],)) sf_in = Input ( shape = ( 1 ,)) x_latent = encoder ( x_in ) x_rec = decoder ([ x_in , x_latent , sf_in ]) nbvae = Model ([ x_in , sf_in ], x_rec ) # We specify no loss because NB loss is handled by the decoder nbvae . compile ( loss = None , optimizer = 'sgd' ) nbvae . fit ( x = [ x_train , x_sf ], y = x_train , epochs = 10 , batch_size = 10 )","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"LatentLego is like a lego box with building blocks for autoencoders. These building blocks are hierarchically assembled into larger components, each of which can be used in a modular way to define a model. To make this more clear, lets start with some examples.","title":"Quickstart"},{"location":"quickstart/#using-pre-defined-models","text":"LatentLego hosts a model zoo with a number of common autoencoder architectures ready to use. They are subclassed Keras Model objects and understand common methods like .fit() and .predict() . So the quickest way to train an autoencoder with LatentLego is simply import numpy as np from latent.models import Autoencoder x_train = np . array ([ np . random . poisson ( lam = 5 , size = 100 ) for i in range ( 100 )]) # Creates an autoencoder model with a 2-dimensional latent space ae = Autoencoder ( latent_dim = 2 , x_dim = x_train . shape [ 1 ], activation = 'relu' ) # Compiled the model with a poisson loss and a Adam optimizer ae . compile ( loss = 'mse' , optimizer = 'adam' ) # Trains the model on x_train ae . fit ( x_train , epochs = 10 , batch_size = 10 ) This trained autoencoder model can now be used to yield a low dimensional representation of the input (or new) data. In line with the scikit-learn API, autoencoder models in LatentLego have a .transform() method, which returns the low dimensional representation. x_latent = ae . transform ( x_train ) Using .predict() gives us the reconstructred input data after being passed through the bottleneck. This representation can be used for denoising of single-cell data ( Erslan 2019 ). x_recon = ae . predict ( x_train )","title":"Using pre-defined models"},{"location":"quickstart/#defining-models-by-combining-encoder-and-decoder","text":"The second way to define a model with LatentLego is to pick any of the provided encoder and decoder models and combine them using the Autoencoder data structure. For instance, if you want to create a variational autoencoder with a negative binomial reconstruction loss you can simply combine a VariationalEncoder with a NegativeBinomialDecoder : from latent.modules import VariationalEncoder , NegativeBinomialDecoder # Creates a VariationalEncoder with a standard normal prior encoder = VariationalEncoder ( latent_dim = 20 , prior = 'normal' , kld_weight = 0.01 ) # Creates a NegativeBinomialDecoder with a constant dispersion estimate decoder = NegativeBinomialDecoder ( x_dim = x_train . shape [ 1 ], dispersion = 'constant' ) # Constructs an Autoencoder object with predefined encoder and decoder ae = Autoencoder ( encoder = encoder , decoder = decoder ) ae . compile () # Fit input data using size factors for each cell x_sf = np . array ([ 1. ] * 100 ) ae . fit ([ x_train , x_sf ], epochs = 10 , batch_size = 10 ) You might have noticed that this time we did not define a loss function. This is because some encoder and decoder models take care of the model loss on their own. Generally in LatentLego, encoders are responsible for adding losses related to the latent space, such as the KLDivergence loss of a VAE and decoders add the reconstruction loss. If you anyway decide to pass a loss function to .compile() it will be added to the reconstruction loss defined by the decoder. The Autoencoder data structure subclasses the Keras Model and takes care of providing additional methods like .transform() and handling cases with multiple inputs like conditions or size factors. But since encoder and decoder models are just Keras Model objects themselves, they can also be used with the Keras Functional API: from tensorflow.keras import Input , Model from latent.modules import Encoder , Decoder x = Input ( shape = ( x_train . shape [ 1 ],)) x_latent = Encoder ( latent_dim = 2 )( x ) # Decoders take the latent and the original data space as the input # so they can add the reconstruction loss x_rec = Decoder ( x_dim = x_train . shape [ 1 ])([ x , x_latent ]) ae = Model ( inputs = x , outputs = x_rec ) ae . compile ( loss = 'mse' , optimizer = 'adam' , run_eagerly = False ) ae . fit ( x = x_train , y = x_train , epochs = 10 , batch_size = 10 )","title":"Defining models by combining encoder and decoder"},{"location":"quickstart/#building-autoencoders-from-scratch","text":"Lastly, if you want to implement a model that can not be directly assembled in LatentLego, you may want to implement the encoder/decoder or both from scratch. For this, we also provide some convenient lower-level components that extend the reportoire of Keras and TensorFlow. For instance, the DenseStack layer strings together a sequence of DenseBlock layers and take care of batch normalization, dropout and conditional injection. We can combine it with some TensorFlow Probability magic and stack it on top of a NegativeBinomialDecoder to obtain a VAE with negative binomial loss. import tensorflow as tf from tensorflow.keras import Sequential , Input , Model import tensorflow_probability as tfp tfpl = tfp . layers tfd = tfp . distributions from latent.layers import DenseStack from latent.modules import NegativeBinomialDecoder latent_dim = 2 # Initiate standard normal prior prior = tfd . Independent ( tfd . Normal ( loc = tf . zeros ( latent_dim ), scale = 1 ), reinterpreted_batch_ndims = 1 ) # Construct encoder with sequential model encoder = Sequential ([ DenseStack ( hidden_units = [ 256 , 128 , 56 ], batchnorm = True , dropout_rate = 0.2 ), tf . keras . layers . Dense ( tfpl . MultivariateNormalTriL . params_size ( latent_dim ), activation = 'linear' ), tfpl . MultivariateNormalTriL ( latent_dim , activity_regularizer = tfpl . KLDivergenceRegularizer ( prior )) ]) # Initiate a NB decoder with a per-gene dispersion estimate decoder = NegativeBinomialDecoder ( x_dim = x_train . shape [ 1 ], dispersion = 'gene' ) x_in = Input ( shape = ( x_train . shape [ 1 ],)) sf_in = Input ( shape = ( 1 ,)) x_latent = encoder ( x_in ) x_rec = decoder ([ x_in , x_latent , sf_in ]) nbvae = Model ([ x_in , sf_in ], x_rec ) # We specify no loss because NB loss is handled by the decoder nbvae . compile ( loss = None , optimizer = 'sgd' ) nbvae . fit ( x = [ x_train , x_sf ], y = x_train , epochs = 10 , batch_size = 10 )","title":"Building autoencoders from scratch"},{"location":"api/activations/clipped_exp/","text":"latent . activations . clipped_exp ( x ) Applies a exp activation function clipped at 1e-5 and 1e6. Parameters: Name Type Description Default x Tensor Input tensor required Returns: Type Description Tensor Tensor, output of clipped exp transformation.","title":"clipped_exp"},{"location":"api/activations/clipped_exp/#latent.activations.clipped_exp","text":"Applies a exp activation function clipped at 1e-5 and 1e6. Parameters: Name Type Description Default x Tensor Input tensor required Returns: Type Description Tensor Tensor, output of clipped exp transformation.","title":"clipped_exp()"},{"location":"api/activations/clipped_softplus/","text":"latent . activations . clipped_softplus ( x ) Applies a exp activation function clipped at 1e-4 and 1e4. Parameters: Name Type Description Default x Tensor Input tensor required Returns: Type Description Tensor Tensor, output of clipped softplus transformation.","title":"clipped_softplus"},{"location":"api/activations/clipped_softplus/#latent.activations.clipped_softplus","text":"Applies a exp activation function clipped at 1e-4 and 1e4. Parameters: Name Type Description Default x Tensor Input tensor required Returns: Type Description Tensor Tensor, output of clipped softplus transformation.","title":"clipped_softplus()"},{"location":"api/activations/get/","text":"latent . activations . get ( identifier ) Returns activation function Parameters: Name Type Description Default identifier Union[Callable, str] Function or string required Returns: Type Description Callable Function corresponding to the input string or input function.","title":"get"},{"location":"api/activations/get/#latent.activations.get","text":"Returns activation function Parameters: Name Type Description Default identifier Union[Callable, str] Function or string required Returns: Type Description Callable Function corresponding to the input string or input function.","title":"get()"},{"location":"api/callbacks/IncreaseKLDOnEpoch/","text":"latent.callbacks.IncreaseKLDOnEpoch Increase Kullback-Leibler Divergence loss of VAEs during training. __init__ ( self , factor = 1.5 , max_val = 1.0 , ** kwargs ) special Parameters: Name Type Description Default factor float Positive float. Factor by which the KLD will be increased each epoch. 1.5 max_val float Positive float. Maximum value of KLD. 1.0 **kwargs Other parameters passed to keras.callbacks.Callback . {}","title":"IncreaseKLDOnEpoch"},{"location":"api/callbacks/IncreaseKLDOnEpoch/#latent.callbacks.IncreaseKLDOnEpoch","text":"Increase Kullback-Leibler Divergence loss of VAEs during training.","title":"IncreaseKLDOnEpoch"},{"location":"api/callbacks/IncreaseKLDOnEpoch/#latent.callbacks.IncreaseKLDOnEpoch.__init__","text":"Parameters: Name Type Description Default factor float Positive float. Factor by which the KLD will be increased each epoch. 1.5 max_val float Positive float. Maximum value of KLD. 1.0 **kwargs Other parameters passed to keras.callbacks.Callback . {}","title":"__init__()"},{"location":"api/callbacks/KLDivergenceScheduler/","text":"latent.callbacks.KLDivergenceScheduler Schedule Kullback-Leibler Divergence loss of VAEs during training. __init__ ( self , schedule , ** kwargs ) special Parameters: Name Type Description Default schedule Callable a function that takes an epoch index (integer, indexed from 0) and current KLD (float) as inputs and returns a new KLD as output (float). required **kwargs Other parameters passed to keras.callbacks.Callback . {}","title":"KLDivergenceScheduler"},{"location":"api/callbacks/KLDivergenceScheduler/#latent.callbacks.KLDivergenceScheduler","text":"Schedule Kullback-Leibler Divergence loss of VAEs during training.","title":"KLDivergenceScheduler"},{"location":"api/callbacks/KLDivergenceScheduler/#latent.callbacks.KLDivergenceScheduler.__init__","text":"Parameters: Name Type Description Default schedule Callable a function that takes an epoch index (integer, indexed from 0) and current KLD (float) as inputs and returns a new KLD as output (float). required **kwargs Other parameters passed to keras.callbacks.Callback . {}","title":"__init__()"},{"location":"api/layers/Constant/","text":"latent.layers.DenseStack A stack of DenseBlock layers. __init__ ( self , name = None , hidden_units = [ 128 , 128 ], conditional = None , ** kwargs ) special Parameters: Name Type Description Default name str String indicating the name of the layer. None hidden_units Iterable[int] Iterable of number hidden units per layer. All layers are fully connected. Ex. [128, 64] means first layer has 128 nodes and second one has 64. [128, 128] conditional Literal['first', 'all'] One of the following: 'first' Inject condition into first layer 'all' Inject condition into all layers None Don't inject condition None **kwargs Other arguments passed on to DenseBlock . {}","title":"Constant"},{"location":"api/layers/Constant/#latent.layers.DenseStack","text":"A stack of DenseBlock layers.","title":"DenseStack"},{"location":"api/layers/Constant/#latent.layers.DenseStack.__init__","text":"Parameters: Name Type Description Default name str String indicating the name of the layer. None hidden_units Iterable[int] Iterable of number hidden units per layer. All layers are fully connected. Ex. [128, 64] means first layer has 128 nodes and second one has 64. [128, 128] conditional Literal['first', 'all'] One of the following: 'first' Inject condition into first layer 'all' Inject condition into all layers None Don't inject condition None **kwargs Other arguments passed on to DenseBlock . {}","title":"__init__()"},{"location":"api/layers/DenseBlock/","text":"latent.layers.DenseBlock Basic dense layer block with regularization, dropout, and batch-/layernorm functionality. __init__ ( self , units , name = None , dropout_rate = 0.1 , batchnorm = True , layernorm = False , l1 = 0.0 , l2 = 0.0 , activation = 'leaky_relu' , initializer = 'glorot_normal' ) special Parameters: Name Type Description Default units int Positive integer, dimensionality of the output space. required name str String indicating the name of the layer. None dropout_rate float Float between 0 and 1. Fraction of the input units to drop. 0.1 batchnorm bool Boolean, whether to perform batch normalization. True layernorm bool Boolean, whether to perform layer normalization. False l1 float Float. L1 regularization factor. 0.0 l2 float Float. L2 regularization factor. 0.0 activation Union[str, Callable] Activation function to use. 'leaky_relu' initializer Union[str, Callable] Initializer for the kernel weights matrix. 'glorot_normal'","title":"DenseBlock"},{"location":"api/layers/DenseBlock/#latent.layers.DenseBlock","text":"Basic dense layer block with regularization, dropout, and batch-/layernorm functionality.","title":"DenseBlock"},{"location":"api/layers/DenseBlock/#latent.layers.DenseBlock.__init__","text":"Parameters: Name Type Description Default units int Positive integer, dimensionality of the output space. required name str String indicating the name of the layer. None dropout_rate float Float between 0 and 1. Fraction of the input units to drop. 0.1 batchnorm bool Boolean, whether to perform batch normalization. True layernorm bool Boolean, whether to perform layer normalization. False l1 float Float. L1 regularization factor. 0.0 l2 float Float. L2 regularization factor. 0.0 activation Union[str, Callable] Activation function to use. 'leaky_relu' initializer Union[str, Callable] Initializer for the kernel weights matrix. 'glorot_normal'","title":"__init__()"},{"location":"api/layers/DenseStack/","text":"latent.layers.DenseStack A stack of DenseBlock layers. __init__ ( self , name = None , hidden_units = [ 128 , 128 ], conditional = None , ** kwargs ) special Parameters: Name Type Description Default name str String indicating the name of the layer. None hidden_units Iterable[int] Iterable of number hidden units per layer. All layers are fully connected. Ex. [128, 64] means first layer has 128 nodes and second one has 64. [128, 128] conditional Literal['first', 'all'] One of the following: 'first' Inject condition into first layer 'all' Inject condition into all layers None Don't inject condition None **kwargs Other arguments passed on to DenseBlock . {}","title":"DenseStack"},{"location":"api/layers/DenseStack/#latent.layers.DenseStack","text":"A stack of DenseBlock layers.","title":"DenseStack"},{"location":"api/layers/DenseStack/#latent.layers.DenseStack.__init__","text":"Parameters: Name Type Description Default name str String indicating the name of the layer. None hidden_units Iterable[int] Iterable of number hidden units per layer. All layers are fully connected. Ex. [128, 64] means first layer has 128 nodes and second one has 64. [128, 128] conditional Literal['first', 'all'] One of the following: 'first' Inject condition into first layer 'all' Inject condition into all layers None Don't inject condition None **kwargs Other arguments passed on to DenseBlock . {}","title":"__init__()"},{"location":"api/layers/PseudoInputs/","text":"latent.layers.PseudoInputs Creates trainable pseudo inputs ( Tomczak 2017 ) based on input shapes. __init__ ( self , n_inputs , name = None , activation = 'relu' , initializer = None ) special Parameters: Name Type Description Default n_inputs int Positive integer, number of pseudo-inputs. required name str String indicating the name of the layer. None activation Union[str, Callable] Activation function to use. 'relu' initializer Union[str, Callable] Initializer for the kernel weights matrix. None","title":"PseudoInputs"},{"location":"api/layers/PseudoInputs/#latent.layers.PseudoInputs","text":"Creates trainable pseudo inputs ( Tomczak 2017 ) based on input shapes.","title":"PseudoInputs"},{"location":"api/layers/PseudoInputs/#latent.layers.PseudoInputs.__init__","text":"Parameters: Name Type Description Default n_inputs int Positive integer, number of pseudo-inputs. required name str String indicating the name of the layer. None activation Union[str, Callable] Activation function to use. 'relu' initializer Union[str, Callable] Initializer for the kernel weights matrix. None","title":"__init__()"},{"location":"api/layers/RowwiseMult/","text":"latent.layers.RowwiseMult Performs row-wise multiplication between input vectors. __init__ ( self , name = None ) special Parameters: Name Type Description Default name str String indicating the name of the layer. None call ( self , inputs ) This is where the layer's logic lives. Note here that call() method in tf.keras is little bit different from keras API. In keras API, you can pass support masking for layers as additional arguments. Whereas tf.keras has compute_mask() method to support masking. Parameters: Name Type Description Default inputs Input tensor, or list/tuple of input tensors. required **kwargs Additional keyword arguments. Currently unused. required Returns: Type Description A tensor or list/tuple of tensors.","title":"RowwiseMult"},{"location":"api/layers/RowwiseMult/#latent.layers.RowwiseMult","text":"Performs row-wise multiplication between input vectors.","title":"RowwiseMult"},{"location":"api/layers/RowwiseMult/#latent.layers.RowwiseMult.__init__","text":"Parameters: Name Type Description Default name str String indicating the name of the layer. None","title":"__init__()"},{"location":"api/layers/RowwiseMult/#latent.layers.RowwiseMult.call","text":"This is where the layer's logic lives. Note here that call() method in tf.keras is little bit different from keras API. In keras API, you can pass support masking for layers as additional arguments. Whereas tf.keras has compute_mask() method to support masking. Parameters: Name Type Description Default inputs Input tensor, or list/tuple of input tensors. required **kwargs Additional keyword arguments. Currently unused. required Returns: Type Description A tensor or list/tuple of tensors.","title":"call()"},{"location":"api/layers/Sampling/","text":"latent.layers.Sampling Uses inputs (z_mean, log_var) to sample z. __init__ ( self , name = None ) special Parameters: Name Type Description Default name str String indicating the name of the layer. None","title":"Sampling"},{"location":"api/layers/Sampling/#latent.layers.Sampling","text":"Uses inputs (z_mean, log_var) to sample z.","title":"Sampling"},{"location":"api/layers/Sampling/#latent.layers.Sampling.__init__","text":"Parameters: Name Type Description Default name str String indicating the name of the layer. None","title":"__init__()"},{"location":"api/layers/SharedDispersion/","text":"latent.layers.SharedDispersion Layer to get shared dispersion estimates per gene. __init__ ( self , units , name = None , activation = 'clipped_exp' , initializer = 'glorot_normal' ) special Parameters: Name Type Description Default units int Positive integer, dimensionality of the output space. required name str String indicating the name of the layer. None activation Union[str, Callable] Activation function to use. 'clipped_exp' initializer Union[str, Callable] Initializer for the kernel weights matrix. 'glorot_normal'","title":"SharedDispersion"},{"location":"api/layers/SharedDispersion/#latent.layers.SharedDispersion","text":"Layer to get shared dispersion estimates per gene.","title":"SharedDispersion"},{"location":"api/layers/SharedDispersion/#latent.layers.SharedDispersion.__init__","text":"Parameters: Name Type Description Default units int Positive integer, dimensionality of the output space. required name str String indicating the name of the layer. None activation Union[str, Callable] Activation function to use. 'clipped_exp' initializer Union[str, Callable] Initializer for the kernel weights matrix. 'glorot_normal'","title":"__init__()"},{"location":"api/losses/MaximumMeanDiscrepancy/","text":"latent.losses.MaximumMeanDiscrepancy Computes Maximum Mean Discrepancy (MMD) loss between conditions ( y_true ) in y_pred . __init__ ( self , n_conditions = 2 , kernel_method = 'ms_rbf' , ** kwargs ) special Parameters: Name Type Description Default n_conditions int Positive integer indicating number of conditions. 2 kernel_method str Name of kernel method to use. Can be one of the following: 'ms_rbf' Multi-scale RBF kernel ( Lotfollahi 2019 ) 'rbf' Basic RBF kernel 'rq' Rational Quadratic kernel 'ms_rbf' **kwargs Other arguments passed to keras.losses.Loss . {}","title":"MaximumMeanDiscrepancy"},{"location":"api/losses/MaximumMeanDiscrepancy/#latent.losses.MaximumMeanDiscrepancy","text":"Computes Maximum Mean Discrepancy (MMD) loss between conditions ( y_true ) in y_pred .","title":"MaximumMeanDiscrepancy"},{"location":"api/losses/MaximumMeanDiscrepancy/#latent.losses.MaximumMeanDiscrepancy.__init__","text":"Parameters: Name Type Description Default n_conditions int Positive integer indicating number of conditions. 2 kernel_method str Name of kernel method to use. Can be one of the following: 'ms_rbf' Multi-scale RBF kernel ( Lotfollahi 2019 ) 'rbf' Basic RBF kernel 'rq' Rational Quadratic kernel 'ms_rbf' **kwargs Other arguments passed to keras.losses.Loss . {}","title":"__init__()"},{"location":"api/losses/NegativeBinomial/","text":"latent.losses.NegativeBinomial Computes negative binomial loss between y_true and y_pred given a dispersion parameter ( theta ). __init__ ( self , theta , eps = 1e-08 , ** kwargs ) special Parameters: Name Type Description Default theta Union[tensorflow.python.framework.ops.Tensor, float] Positive float. Dispersion parameter. required eps float Positive float. Clipping value for numerical stability. 1e-08 **kwargs Other arguments passed to keras.losses.Loss . {}","title":"NegativeBinomial"},{"location":"api/losses/NegativeBinomial/#latent.losses.NegativeBinomial","text":"Computes negative binomial loss between y_true and y_pred given a dispersion parameter ( theta ).","title":"NegativeBinomial"},{"location":"api/losses/NegativeBinomial/#latent.losses.NegativeBinomial.__init__","text":"Parameters: Name Type Description Default theta Union[tensorflow.python.framework.ops.Tensor, float] Positive float. Dispersion parameter. required eps float Positive float. Clipping value for numerical stability. 1e-08 **kwargs Other arguments passed to keras.losses.Loss . {}","title":"__init__()"},{"location":"api/losses/TopologicalSignatureDistance/","text":"latent.losses.TopologicalSignatureDistance Computes distance between topological signatures ( Moor 2019 ). __init__ ( self , match_edges = None , eps = 1e-08 , return_additional_metrics = False , ** kwargs ) special Parameters: Name Type Description Default match_edges Literal['symmetric', 'random'] One of the following: 'symmetric' Match edged between signatures symmetrically 'random' Match edged between signatures randomly None Don't match edges None eps float Positive float. Clipping value for numerical stability. 1e-08 return_additional_metrics bool Boolean, whether to return additional metrics. False **kwargs Other arguments passed to keras.losses.Loss . {}","title":"TopologicalSignatureDistance"},{"location":"api/losses/TopologicalSignatureDistance/#latent.losses.TopologicalSignatureDistance","text":"Computes distance between topological signatures ( Moor 2019 ).","title":"TopologicalSignatureDistance"},{"location":"api/losses/TopologicalSignatureDistance/#latent.losses.TopologicalSignatureDistance.__init__","text":"Parameters: Name Type Description Default match_edges Literal['symmetric', 'random'] One of the following: 'symmetric' Match edged between signatures symmetrically 'random' Match edged between signatures randomly None Don't match edges None eps float Positive float. Clipping value for numerical stability. 1e-08 return_additional_metrics bool Boolean, whether to return additional metrics. False **kwargs Other arguments passed to keras.losses.Loss . {}","title":"__init__()"},{"location":"api/losses/ZINB/","text":"latent.losses.ZINB Computes zero-inflated negative binomial loss between y_true and y_pred given a dispersion parameter ( theta ) and dropout rate ( pi ). __init__ ( self , pi , theta , eps = 1e-08 , ** kwargs ) special Parameters: Name Type Description Default theta Union[tensorflow.python.framework.ops.Tensor, float] Positive float. Dispersion parameter. required pi Union[tensorflow.python.framework.ops.Tensor, float] Positive float between 0 and 1. Dropout rate. required eps float Positive float. Clipping value for numerical stability. 1e-08 **kwargs Other arguments passed to keras.losses.Loss . {}","title":"ZINB"},{"location":"api/losses/ZINB/#latent.losses.ZINB","text":"Computes zero-inflated negative binomial loss between y_true and y_pred given a dispersion parameter ( theta ) and dropout rate ( pi ).","title":"ZINB"},{"location":"api/losses/ZINB/#latent.losses.ZINB.__init__","text":"Parameters: Name Type Description Default theta Union[tensorflow.python.framework.ops.Tensor, float] Positive float. Dispersion parameter. required pi Union[tensorflow.python.framework.ops.Tensor, float] Positive float between 0 and 1. Dropout rate. required eps float Positive float. Clipping value for numerical stability. 1e-08 **kwargs Other arguments passed to keras.losses.Loss . {}","title":"__init__()"},{"location":"api/losses/get/","text":"latent . losses . get ( identifier ) Returns loss function Parameters: Name Type Description Default identifier Union[Callable, str] Function or string required Returns: Type Description Callable Function corresponding to the input string or input function.","title":"get"},{"location":"api/losses/get/#latent.losses.get","text":"Returns loss function Parameters: Name Type Description Default identifier Union[Callable, str] Function or string required Returns: Type Description Callable Function corresponding to the input string or input function.","title":"get()"},{"location":"api/models/Autoencoder/","text":"Autoencoder latent.models.ae.Autoencoder Autoencoder base class. This model stacks together an encoder and a decoder model to produce an autoencoder which compresses input data in a latent space by minimizing the reconstruction error. __init__ ( self , encoder = None , decoder = None , name = 'autoencoder' , x_dim = None , latent_dim = 50 , encoder_units = [ 128 , 128 ], decoder_units = [ 128 , 128 ], reconstruction_loss = None , use_conditions = False , ** kwargs ) special Parameters: Name Type Description Default encoder Model Keras/tensorflow model object that inputs the data and outputs the latent space. If not provided, a default model will be constructed from the arguments. None decoder Model Keras/tensorflow model object that inputs the latent space and outputs the reconstructed data. If not provided, a default model will be constructed from the arguments. None name str String indicating the name of the model. 'autoencoder' x_dim int Integer indicating the number of features in the input data. None latent_dim int Integer indicating the number of dimensions in the latent space. 50 encoder_units Iterable[int] Integer list indicating the number of units of the encoder layers. Only used if encoder is not provided. [128, 128] decoder_units Iterable[int] An integer list indicating the number of units of the decoder layers. Only used if decoder is not provided. [128, 128] reconstruction_loss Callable Loss function applied to the reconstructed data and to be added by the decoder. Only used if decoder is not provided. Can also be added later by calling compile() . None use_conditions bool Boolean, whether to force the unpacking of conditions from the inputs. False **kwargs Other arguments passed on to DenseStack for constructung encoder/ decoder networks. {} call ( self , inputs ) Full forward pass through model compile ( self , optimizer = 'adam' , loss = None , ** kwargs ) Configures the model for training. Parameters: Name Type Description Default optimizer String (name of optimizer) or optimizer instance. See tf.keras.optimizers . 'adam' loss String (name of objective function), objective function or tf.keras.losses.Loss instance. See tf.keras.losses . An objective function is any callable with the signature loss = fn(y_true, y_pred) , where y_true = ground truth values with shape = [batch_size, d0, .. dN] , except sparse loss functions such as sparse categorical crossentropy where shape = [batch_size, d0, .. dN-1] . y_pred = predicted values with shape = [batch_size, d0, .. dN] . It returns a weighted loss float tensor. If a custom Loss instance is used and reduction is set to NONE, return value has the shape [batch_size, d0, .. dN-1] ie. per-sample or per-timestep loss values; otherwise, it is a scalar. If the model has multiple outputs, you can use a different loss on each output by passing a dictionary or a list of losses. The loss value that will be minimized by the model will then be the sum of all individual losses. None metrics List of metrics to be evaluated by the model during training and testing. Each of this can be a string (name of a built-in function), function or a tf.keras.metrics.Metric instance. See tf.keras.metrics . Typically you will use metrics=['accuracy'] . A function is any callable with the signature result = fn(y_true, y_pred) . To specify different metrics for different outputs of a multi-output model, you could also pass a dictionary, such as metrics={'output_a': 'accuracy', 'output_b': ['accuracy', 'mse']} . You can also pass a list (len = len(outputs)) of lists of metrics such as metrics=[['accuracy'], ['accuracy', 'mse']] or metrics=['accuracy', ['accuracy', 'mse']] . When you pass the strings 'accuracy' or 'acc', we convert this to one of tf.keras.metrics.BinaryAccuracy , tf.keras.metrics.CategoricalAccuracy , tf.keras.metrics.SparseCategoricalAccuracy based on the loss function used and the model output shape. We do a similar conversion for the strings 'crossentropy' and 'ce' as well. required loss_weights Optional list or dictionary specifying scalar coefficients (Python floats) to weight the loss contributions of different model outputs. The loss value that will be minimized by the model will then be the weighted sum of all individual losses, weighted by the loss_weights coefficients. If a list, it is expected to have a 1:1 mapping to the model's outputs. If a dict, it is expected to map output names (strings) to scalar coefficients. required weighted_metrics List of metrics to be evaluated and weighted by sample_weight or class_weight during training and testing. required run_eagerly Bool. Defaults to False . If True , this Model 's logic will not be wrapped in a tf.function . Recommended to leave this as None unless your Model cannot be run inside a tf.function . required steps_per_execution Int. Defaults to 1. The number of batches to run during each tf.function call. Running multiple batches inside a single tf.function call can greatly improve performance on TPUs or small models with a large Python overhead. At most, one full epoch will be run each execution. If a number larger than the size of the epoch is passed, the execution will be truncated to the size of the epoch. Note that if steps_per_execution is set to N , Callback.on_batch_begin and Callback.on_batch_end methods will only be called every N batches (i.e. before/after each tf.function execution). required **kwargs Arguments supported for backwards compatibility only. {} Exceptions: Type Description ValueError In case of invalid arguments for optimizer , loss or metrics . fit ( self , x , y = None , ** kwargs ) Trains the model for a fixed number of epochs (iterations on a dataset). Parameters: Name Type Description Default x Input data. It could be: - A Numpy array (or array-like), or a list of arrays (in case the model has multiple inputs). - A TensorFlow tensor, or a list of tensors (in case the model has multiple inputs). - A dict mapping input names to the corresponding array/tensors, if the model has named inputs. - A tf.data dataset. Should return a tuple of either (inputs, targets) or (inputs, targets, sample_weights) . - A generator or keras.utils.Sequence returning (inputs, targets) or (inputs, targets, sample_weights) . A more detailed description of unpacking behavior for iterator types (Dataset, generator, Sequence) is given below. required y Target data. Like the input data x , it could be either Numpy array(s) or TensorFlow tensor(s). It should be consistent with x (you cannot have Numpy inputs and tensor targets, or inversely). If x is a dataset, generator, or keras.utils.Sequence instance, y should not be specified (since targets will be obtained from x ). None batch_size Integer or None . Number of samples per gradient update. If unspecified, batch_size will default to 32. Do not specify the batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required epochs Integer. Number of epochs to train the model. An epoch is an iteration over the entire x and y data provided. Note that in conjunction with initial_epoch , epochs is to be understood as \"final epoch\". The model is not trained for a number of iterations given by epochs , but merely until the epoch of index epochs is reached. required verbose 0, 1, or 2. Verbosity mode. 0 = silent, 1 = progress bar, 2 = one line per epoch. Note that the progress bar is not particularly useful when logged to a file, so verbose=2 is recommended when not running interactively (eg, in a production environment). required callbacks List of keras.callbacks.Callback instances. List of callbacks to apply during training. See tf.keras.callbacks . Note tf.keras.callbacks.ProgbarLogger and tf.keras.callbacks.History callbacks are created automatically and need not be passed into model.fit . tf.keras.callbacks.ProgbarLogger is created or not based on verbose argument to model.fit . required validation_split Float between 0 and 1. Fraction of the training data to be used as validation data. The model will set apart this fraction of the training data, will not train on it, and will evaluate the loss and any model metrics on this data at the end of each epoch. The validation data is selected from the last samples in the x and y data provided, before shuffling. This argument is not supported when x is a dataset, generator or keras.utils.Sequence instance. required validation_data Data on which to evaluate the loss and any model metrics at the end of each epoch. The model will not be trained on this data. Thus, note the fact that the validation loss of data provided using validation_split or validation_data is not affected by regularization layers like noise and dropout. validation_data will override validation_split . validation_data could be: - tuple (x_val, y_val) of Numpy arrays or tensors - tuple (x_val, y_val, val_sample_weights) of Numpy arrays - dataset For the first two cases, batch_size must be provided. For the last case, validation_steps could be provided. Note that validation_data does not support all the data types that are supported in x , eg, dict, generator or keras.utils.Sequence . required shuffle Boolean (whether to shuffle the training data before each epoch) or str (for 'batch'). This argument is ignored when x is a generator. 'batch' is a special option for dealing with the limitations of HDF5 data; it shuffles in batch-sized chunks. Has no effect when steps_per_epoch is not None . required class_weight Optional dictionary mapping class indices (integers) to a weight (float) value, used for weighting the loss function (during training only). This can be useful to tell the model to \"pay more attention\" to samples from an under-represented class. required sample_weight Optional Numpy array of weights for the training samples, used for weighting the loss function (during training only). You can either pass a flat (1D) Numpy array with the same length as the input samples (1:1 mapping between weights and samples), or in the case of temporal data, you can pass a 2D array with shape (samples, sequence_length) , to apply a different weight to every timestep of every sample. This argument is not supported when x is a dataset, generator, or keras.utils.Sequence instance, instead provide the sample_weights as the third element of x . required initial_epoch Integer. Epoch at which to start training (useful for resuming a previous training run). required steps_per_epoch Integer or None . Total number of steps (batches of samples) before declaring one epoch finished and starting the next epoch. When training with input tensors such as TensorFlow data tensors, the default None is equal to the number of samples in your dataset divided by the batch size, or 1 if that cannot be determined. If x is a tf.data dataset, and 'steps_per_epoch' is None, the epoch will run until the input dataset is exhausted. When passing an infinitely repeating dataset, you must specify the steps_per_epoch argument. This argument is not supported with array inputs. required validation_steps Only relevant if validation_data is provided and is a tf.data dataset. Total number of steps (batches of samples) to draw before stopping when performing validation at the end of every epoch. If 'validation_steps' is None, validation will run until the validation_data dataset is exhausted. In the case of an infinitely repeated dataset, it will run into an infinite loop. If 'validation_steps' is specified and only part of the dataset will be consumed, the evaluation will start from the beginning of the dataset at each epoch. This ensures that the same validation samples are used every time. required validation_batch_size Integer or None . Number of samples per validation batch. If unspecified, will default to batch_size . Do not specify the validation_batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required validation_freq Only relevant if validation data is provided. Integer or collections_abc.Container instance (e.g. list, tuple, etc.). If an integer, specifies how many training epochs to run before a new validation run is performed, e.g. validation_freq=2 runs validation every 2 epochs. If a Container, specifies the epochs on which to run validation, e.g. validation_freq=[1, 2, 10] runs validation at the end of the 1st, 2nd, and 10th epochs. required max_queue_size Integer. Used for generator or keras.utils.Sequence input only. Maximum size for the generator queue. If unspecified, max_queue_size will default to 10. required workers Integer. Used for generator or keras.utils.Sequence input only. Maximum number of processes to spin up when using process-based threading. If unspecified, workers will default to 1. If 0, will execute the generator on the main thread. required use_multiprocessing Boolean. Used for generator or keras.utils.Sequence input only. If True , use process-based threading. If unspecified, use_multiprocessing will default to False . Note that because this implementation relies on multiprocessing, you should not pass non-picklable arguments to the generator as they can't be passed easily to children processes. required Unpacking behavior for iterator-like inputs: A common pattern is to pass a tf.data.Dataset, generator, or tf.keras.utils.Sequence to the x argument of fit, which will in fact yield not only features (x) but optionally targets (y) and sample weights. Keras requires that the output of such iterator-likes be unambiguous. The iterator should return a tuple of length 1, 2, or 3, where the optional second and third elements will be used for y and sample_weight respectively. Any other type provided will be wrapped in a length one tuple, effectively treating everything as 'x'. When yielding dicts, they should still adhere to the top-level tuple structure. e.g. ({\"x0\": x0, \"x1\": x1}, y) . Keras will not attempt to separate features, targets, and weights from the keys of a single dict. A notable unsupported data type is the namedtuple. The reason is that it behaves like both an ordered datatype (tuple) and a mapping datatype (dict). So given a namedtuple of the form: namedtuple(\"example_tuple\", [\"y\", \"x\"]) it is ambiguous whether to reverse the order of the elements when interpreting the value. Even worse is a tuple of the form: namedtuple(\"other_tuple\", [\"x\", \"y\", \"z\"]) where it is unclear if the tuple was intended to be unpacked into x, y, and sample_weight or passed through as a single element to x . As a result the data processing code will simply raise a ValueError if it encounters a namedtuple. (Along with instructions to remedy the issue.) Returns: Type Description A History object. Its History.history attribute is a record of training loss values and metrics values at successive epochs, as well as validation loss values and validation metrics values (if applicable). Exceptions: Type Description RuntimeError If the model was never compiled or, ValueError In case of mismatch between the provided input data and what the model expects or when the input data is empty. transform ( self , inputs ) Map data (x) to latent space (z). Parameters: Name Type Description Default inputs A numpy array with input data. required Returns: Type Description A numpy array with the coordinates of the input data in latent space.","title":"Autoencoder"},{"location":"api/models/Autoencoder/#autoencoder","text":"","title":"Autoencoder"},{"location":"api/models/Autoencoder/#latent.models.ae.Autoencoder","text":"Autoencoder base class. This model stacks together an encoder and a decoder model to produce an autoencoder which compresses input data in a latent space by minimizing the reconstruction error.","title":"Autoencoder"},{"location":"api/models/Autoencoder/#latent.models.ae.Autoencoder.__init__","text":"Parameters: Name Type Description Default encoder Model Keras/tensorflow model object that inputs the data and outputs the latent space. If not provided, a default model will be constructed from the arguments. None decoder Model Keras/tensorflow model object that inputs the latent space and outputs the reconstructed data. If not provided, a default model will be constructed from the arguments. None name str String indicating the name of the model. 'autoencoder' x_dim int Integer indicating the number of features in the input data. None latent_dim int Integer indicating the number of dimensions in the latent space. 50 encoder_units Iterable[int] Integer list indicating the number of units of the encoder layers. Only used if encoder is not provided. [128, 128] decoder_units Iterable[int] An integer list indicating the number of units of the decoder layers. Only used if decoder is not provided. [128, 128] reconstruction_loss Callable Loss function applied to the reconstructed data and to be added by the decoder. Only used if decoder is not provided. Can also be added later by calling compile() . None use_conditions bool Boolean, whether to force the unpacking of conditions from the inputs. False **kwargs Other arguments passed on to DenseStack for constructung encoder/ decoder networks. {}","title":"__init__()"},{"location":"api/models/Autoencoder/#latent.models.ae.Autoencoder.call","text":"Full forward pass through model","title":"call()"},{"location":"api/models/Autoencoder/#latent.models.ae.Autoencoder.compile","text":"Configures the model for training. Parameters: Name Type Description Default optimizer String (name of optimizer) or optimizer instance. See tf.keras.optimizers . 'adam' loss String (name of objective function), objective function or tf.keras.losses.Loss instance. See tf.keras.losses . An objective function is any callable with the signature loss = fn(y_true, y_pred) , where y_true = ground truth values with shape = [batch_size, d0, .. dN] , except sparse loss functions such as sparse categorical crossentropy where shape = [batch_size, d0, .. dN-1] . y_pred = predicted values with shape = [batch_size, d0, .. dN] . It returns a weighted loss float tensor. If a custom Loss instance is used and reduction is set to NONE, return value has the shape [batch_size, d0, .. dN-1] ie. per-sample or per-timestep loss values; otherwise, it is a scalar. If the model has multiple outputs, you can use a different loss on each output by passing a dictionary or a list of losses. The loss value that will be minimized by the model will then be the sum of all individual losses. None metrics List of metrics to be evaluated by the model during training and testing. Each of this can be a string (name of a built-in function), function or a tf.keras.metrics.Metric instance. See tf.keras.metrics . Typically you will use metrics=['accuracy'] . A function is any callable with the signature result = fn(y_true, y_pred) . To specify different metrics for different outputs of a multi-output model, you could also pass a dictionary, such as metrics={'output_a': 'accuracy', 'output_b': ['accuracy', 'mse']} . You can also pass a list (len = len(outputs)) of lists of metrics such as metrics=[['accuracy'], ['accuracy', 'mse']] or metrics=['accuracy', ['accuracy', 'mse']] . When you pass the strings 'accuracy' or 'acc', we convert this to one of tf.keras.metrics.BinaryAccuracy , tf.keras.metrics.CategoricalAccuracy , tf.keras.metrics.SparseCategoricalAccuracy based on the loss function used and the model output shape. We do a similar conversion for the strings 'crossentropy' and 'ce' as well. required loss_weights Optional list or dictionary specifying scalar coefficients (Python floats) to weight the loss contributions of different model outputs. The loss value that will be minimized by the model will then be the weighted sum of all individual losses, weighted by the loss_weights coefficients. If a list, it is expected to have a 1:1 mapping to the model's outputs. If a dict, it is expected to map output names (strings) to scalar coefficients. required weighted_metrics List of metrics to be evaluated and weighted by sample_weight or class_weight during training and testing. required run_eagerly Bool. Defaults to False . If True , this Model 's logic will not be wrapped in a tf.function . Recommended to leave this as None unless your Model cannot be run inside a tf.function . required steps_per_execution Int. Defaults to 1. The number of batches to run during each tf.function call. Running multiple batches inside a single tf.function call can greatly improve performance on TPUs or small models with a large Python overhead. At most, one full epoch will be run each execution. If a number larger than the size of the epoch is passed, the execution will be truncated to the size of the epoch. Note that if steps_per_execution is set to N , Callback.on_batch_begin and Callback.on_batch_end methods will only be called every N batches (i.e. before/after each tf.function execution). required **kwargs Arguments supported for backwards compatibility only. {} Exceptions: Type Description ValueError In case of invalid arguments for optimizer , loss or metrics .","title":"compile()"},{"location":"api/models/Autoencoder/#latent.models.ae.Autoencoder.fit","text":"Trains the model for a fixed number of epochs (iterations on a dataset). Parameters: Name Type Description Default x Input data. It could be: - A Numpy array (or array-like), or a list of arrays (in case the model has multiple inputs). - A TensorFlow tensor, or a list of tensors (in case the model has multiple inputs). - A dict mapping input names to the corresponding array/tensors, if the model has named inputs. - A tf.data dataset. Should return a tuple of either (inputs, targets) or (inputs, targets, sample_weights) . - A generator or keras.utils.Sequence returning (inputs, targets) or (inputs, targets, sample_weights) . A more detailed description of unpacking behavior for iterator types (Dataset, generator, Sequence) is given below. required y Target data. Like the input data x , it could be either Numpy array(s) or TensorFlow tensor(s). It should be consistent with x (you cannot have Numpy inputs and tensor targets, or inversely). If x is a dataset, generator, or keras.utils.Sequence instance, y should not be specified (since targets will be obtained from x ). None batch_size Integer or None . Number of samples per gradient update. If unspecified, batch_size will default to 32. Do not specify the batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required epochs Integer. Number of epochs to train the model. An epoch is an iteration over the entire x and y data provided. Note that in conjunction with initial_epoch , epochs is to be understood as \"final epoch\". The model is not trained for a number of iterations given by epochs , but merely until the epoch of index epochs is reached. required verbose 0, 1, or 2. Verbosity mode. 0 = silent, 1 = progress bar, 2 = one line per epoch. Note that the progress bar is not particularly useful when logged to a file, so verbose=2 is recommended when not running interactively (eg, in a production environment). required callbacks List of keras.callbacks.Callback instances. List of callbacks to apply during training. See tf.keras.callbacks . Note tf.keras.callbacks.ProgbarLogger and tf.keras.callbacks.History callbacks are created automatically and need not be passed into model.fit . tf.keras.callbacks.ProgbarLogger is created or not based on verbose argument to model.fit . required validation_split Float between 0 and 1. Fraction of the training data to be used as validation data. The model will set apart this fraction of the training data, will not train on it, and will evaluate the loss and any model metrics on this data at the end of each epoch. The validation data is selected from the last samples in the x and y data provided, before shuffling. This argument is not supported when x is a dataset, generator or keras.utils.Sequence instance. required validation_data Data on which to evaluate the loss and any model metrics at the end of each epoch. The model will not be trained on this data. Thus, note the fact that the validation loss of data provided using validation_split or validation_data is not affected by regularization layers like noise and dropout. validation_data will override validation_split . validation_data could be: - tuple (x_val, y_val) of Numpy arrays or tensors - tuple (x_val, y_val, val_sample_weights) of Numpy arrays - dataset For the first two cases, batch_size must be provided. For the last case, validation_steps could be provided. Note that validation_data does not support all the data types that are supported in x , eg, dict, generator or keras.utils.Sequence . required shuffle Boolean (whether to shuffle the training data before each epoch) or str (for 'batch'). This argument is ignored when x is a generator. 'batch' is a special option for dealing with the limitations of HDF5 data; it shuffles in batch-sized chunks. Has no effect when steps_per_epoch is not None . required class_weight Optional dictionary mapping class indices (integers) to a weight (float) value, used for weighting the loss function (during training only). This can be useful to tell the model to \"pay more attention\" to samples from an under-represented class. required sample_weight Optional Numpy array of weights for the training samples, used for weighting the loss function (during training only). You can either pass a flat (1D) Numpy array with the same length as the input samples (1:1 mapping between weights and samples), or in the case of temporal data, you can pass a 2D array with shape (samples, sequence_length) , to apply a different weight to every timestep of every sample. This argument is not supported when x is a dataset, generator, or keras.utils.Sequence instance, instead provide the sample_weights as the third element of x . required initial_epoch Integer. Epoch at which to start training (useful for resuming a previous training run). required steps_per_epoch Integer or None . Total number of steps (batches of samples) before declaring one epoch finished and starting the next epoch. When training with input tensors such as TensorFlow data tensors, the default None is equal to the number of samples in your dataset divided by the batch size, or 1 if that cannot be determined. If x is a tf.data dataset, and 'steps_per_epoch' is None, the epoch will run until the input dataset is exhausted. When passing an infinitely repeating dataset, you must specify the steps_per_epoch argument. This argument is not supported with array inputs. required validation_steps Only relevant if validation_data is provided and is a tf.data dataset. Total number of steps (batches of samples) to draw before stopping when performing validation at the end of every epoch. If 'validation_steps' is None, validation will run until the validation_data dataset is exhausted. In the case of an infinitely repeated dataset, it will run into an infinite loop. If 'validation_steps' is specified and only part of the dataset will be consumed, the evaluation will start from the beginning of the dataset at each epoch. This ensures that the same validation samples are used every time. required validation_batch_size Integer or None . Number of samples per validation batch. If unspecified, will default to batch_size . Do not specify the validation_batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required validation_freq Only relevant if validation data is provided. Integer or collections_abc.Container instance (e.g. list, tuple, etc.). If an integer, specifies how many training epochs to run before a new validation run is performed, e.g. validation_freq=2 runs validation every 2 epochs. If a Container, specifies the epochs on which to run validation, e.g. validation_freq=[1, 2, 10] runs validation at the end of the 1st, 2nd, and 10th epochs. required max_queue_size Integer. Used for generator or keras.utils.Sequence input only. Maximum size for the generator queue. If unspecified, max_queue_size will default to 10. required workers Integer. Used for generator or keras.utils.Sequence input only. Maximum number of processes to spin up when using process-based threading. If unspecified, workers will default to 1. If 0, will execute the generator on the main thread. required use_multiprocessing Boolean. Used for generator or keras.utils.Sequence input only. If True , use process-based threading. If unspecified, use_multiprocessing will default to False . Note that because this implementation relies on multiprocessing, you should not pass non-picklable arguments to the generator as they can't be passed easily to children processes. required Unpacking behavior for iterator-like inputs: A common pattern is to pass a tf.data.Dataset, generator, or tf.keras.utils.Sequence to the x argument of fit, which will in fact yield not only features (x) but optionally targets (y) and sample weights. Keras requires that the output of such iterator-likes be unambiguous. The iterator should return a tuple of length 1, 2, or 3, where the optional second and third elements will be used for y and sample_weight respectively. Any other type provided will be wrapped in a length one tuple, effectively treating everything as 'x'. When yielding dicts, they should still adhere to the top-level tuple structure. e.g. ({\"x0\": x0, \"x1\": x1}, y) . Keras will not attempt to separate features, targets, and weights from the keys of a single dict. A notable unsupported data type is the namedtuple. The reason is that it behaves like both an ordered datatype (tuple) and a mapping datatype (dict). So given a namedtuple of the form: namedtuple(\"example_tuple\", [\"y\", \"x\"]) it is ambiguous whether to reverse the order of the elements when interpreting the value. Even worse is a tuple of the form: namedtuple(\"other_tuple\", [\"x\", \"y\", \"z\"]) where it is unclear if the tuple was intended to be unpacked into x, y, and sample_weight or passed through as a single element to x . As a result the data processing code will simply raise a ValueError if it encounters a namedtuple. (Along with instructions to remedy the issue.) Returns: Type Description A History object. Its History.history attribute is a record of training loss values and metrics values at successive epochs, as well as validation loss values and validation metrics values (if applicable). Exceptions: Type Description RuntimeError If the model was never compiled or, ValueError In case of mismatch between the provided input data and what the model expects or when the input data is empty.","title":"fit()"},{"location":"api/models/Autoencoder/#latent.models.ae.Autoencoder.transform","text":"Map data (x) to latent space (z). Parameters: Name Type Description Default inputs A numpy array with input data. required Returns: Type Description A numpy array with the coordinates of the input data in latent space.","title":"transform()"},{"location":"api/models/NegativeBinomialAutoencoder/","text":"NegativeBinomialAutoencoder latent.models.ae.NegativeBinomialAutoencoder Autoencoder with fixed negative binomial decoder and reconstruction loss. __init__ ( self , encoder = None , name = 'nb_autoencoder' , x_dim = None , latent_dim = 50 , encoder_units = [ 128 , 128 ], decoder_units = [ 128 , 128 ], use_conditions = False , dispersion = 'constant' , ** kwargs ) special Parameters: Name Type Description Default encoder Model Keras/tensorflow model object that inputs the data and outputs the latent space. If not provided, a default model will be constructed from the arguments. None name str String indicating the name of the model. 'nb_autoencoder' x_dim int Integer indicating the number of features in the input data. None latent_dim int Integer indicating the number of dimensions in the latent space. 50 encoder_units Iterable[int] Integer list indicating the number of units of the encoder layers. Only used if encoder is not provided. [128, 128] decoder_units Iterable[int] An integer list indicating the number of units of the decoder layers. Only used if decoder is not provided. [128, 128] use_conditions bool Boolean, whether to force the unpacking of conditions from the inputs. False dispersion Union[Literal['gene', 'cell-gene', 'constant'], float] One of the following: 'gene' - dispersion parameter of NB is constant per gene across cells 'cell-gene' - dispersion can differ for every gene in every cell 'constant' - dispersion is constant across all genes and cells float - numeric value of fixed dispersion parameter 'constant' **kwargs Other arguments passed on to DenseStack for constructung encoder/decoder networks. {} call ( self , inputs ) inherited Full forward pass through model compile ( self , optimizer = 'adam' , loss = None , ** kwargs ) inherited Configures the model for training. Parameters: Name Type Description Default optimizer String (name of optimizer) or optimizer instance. See tf.keras.optimizers . 'adam' loss String (name of objective function), objective function or tf.keras.losses.Loss instance. See tf.keras.losses . An objective function is any callable with the signature loss = fn(y_true, y_pred) , where y_true = ground truth values with shape = [batch_size, d0, .. dN] , except sparse loss functions such as sparse categorical crossentropy where shape = [batch_size, d0, .. dN-1] . y_pred = predicted values with shape = [batch_size, d0, .. dN] . It returns a weighted loss float tensor. If a custom Loss instance is used and reduction is set to NONE, return value has the shape [batch_size, d0, .. dN-1] ie. per-sample or per-timestep loss values; otherwise, it is a scalar. If the model has multiple outputs, you can use a different loss on each output by passing a dictionary or a list of losses. The loss value that will be minimized by the model will then be the sum of all individual losses. None metrics List of metrics to be evaluated by the model during training and testing. Each of this can be a string (name of a built-in function), function or a tf.keras.metrics.Metric instance. See tf.keras.metrics . Typically you will use metrics=['accuracy'] . A function is any callable with the signature result = fn(y_true, y_pred) . To specify different metrics for different outputs of a multi-output model, you could also pass a dictionary, such as metrics={'output_a': 'accuracy', 'output_b': ['accuracy', 'mse']} . You can also pass a list (len = len(outputs)) of lists of metrics such as metrics=[['accuracy'], ['accuracy', 'mse']] or metrics=['accuracy', ['accuracy', 'mse']] . When you pass the strings 'accuracy' or 'acc', we convert this to one of tf.keras.metrics.BinaryAccuracy , tf.keras.metrics.CategoricalAccuracy , tf.keras.metrics.SparseCategoricalAccuracy based on the loss function used and the model output shape. We do a similar conversion for the strings 'crossentropy' and 'ce' as well. required loss_weights Optional list or dictionary specifying scalar coefficients (Python floats) to weight the loss contributions of different model outputs. The loss value that will be minimized by the model will then be the weighted sum of all individual losses, weighted by the loss_weights coefficients. If a list, it is expected to have a 1:1 mapping to the model's outputs. If a dict, it is expected to map output names (strings) to scalar coefficients. required weighted_metrics List of metrics to be evaluated and weighted by sample_weight or class_weight during training and testing. required run_eagerly Bool. Defaults to False . If True , this Model 's logic will not be wrapped in a tf.function . Recommended to leave this as None unless your Model cannot be run inside a tf.function . required steps_per_execution Int. Defaults to 1. The number of batches to run during each tf.function call. Running multiple batches inside a single tf.function call can greatly improve performance on TPUs or small models with a large Python overhead. At most, one full epoch will be run each execution. If a number larger than the size of the epoch is passed, the execution will be truncated to the size of the epoch. Note that if steps_per_execution is set to N , Callback.on_batch_begin and Callback.on_batch_end methods will only be called every N batches (i.e. before/after each tf.function execution). required **kwargs Arguments supported for backwards compatibility only. {} Exceptions: Type Description ValueError In case of invalid arguments for optimizer , loss or metrics . fit ( self , x , y = None , ** kwargs ) inherited Trains the model for a fixed number of epochs (iterations on a dataset). Parameters: Name Type Description Default x Input data. It could be: - A Numpy array (or array-like), or a list of arrays (in case the model has multiple inputs). - A TensorFlow tensor, or a list of tensors (in case the model has multiple inputs). - A dict mapping input names to the corresponding array/tensors, if the model has named inputs. - A tf.data dataset. Should return a tuple of either (inputs, targets) or (inputs, targets, sample_weights) . - A generator or keras.utils.Sequence returning (inputs, targets) or (inputs, targets, sample_weights) . A more detailed description of unpacking behavior for iterator types (Dataset, generator, Sequence) is given below. required y Target data. Like the input data x , it could be either Numpy array(s) or TensorFlow tensor(s). It should be consistent with x (you cannot have Numpy inputs and tensor targets, or inversely). If x is a dataset, generator, or keras.utils.Sequence instance, y should not be specified (since targets will be obtained from x ). None batch_size Integer or None . Number of samples per gradient update. If unspecified, batch_size will default to 32. Do not specify the batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required epochs Integer. Number of epochs to train the model. An epoch is an iteration over the entire x and y data provided. Note that in conjunction with initial_epoch , epochs is to be understood as \"final epoch\". The model is not trained for a number of iterations given by epochs , but merely until the epoch of index epochs is reached. required verbose 0, 1, or 2. Verbosity mode. 0 = silent, 1 = progress bar, 2 = one line per epoch. Note that the progress bar is not particularly useful when logged to a file, so verbose=2 is recommended when not running interactively (eg, in a production environment). required callbacks List of keras.callbacks.Callback instances. List of callbacks to apply during training. See tf.keras.callbacks . Note tf.keras.callbacks.ProgbarLogger and tf.keras.callbacks.History callbacks are created automatically and need not be passed into model.fit . tf.keras.callbacks.ProgbarLogger is created or not based on verbose argument to model.fit . required validation_split Float between 0 and 1. Fraction of the training data to be used as validation data. The model will set apart this fraction of the training data, will not train on it, and will evaluate the loss and any model metrics on this data at the end of each epoch. The validation data is selected from the last samples in the x and y data provided, before shuffling. This argument is not supported when x is a dataset, generator or keras.utils.Sequence instance. required validation_data Data on which to evaluate the loss and any model metrics at the end of each epoch. The model will not be trained on this data. Thus, note the fact that the validation loss of data provided using validation_split or validation_data is not affected by regularization layers like noise and dropout. validation_data will override validation_split . validation_data could be: - tuple (x_val, y_val) of Numpy arrays or tensors - tuple (x_val, y_val, val_sample_weights) of Numpy arrays - dataset For the first two cases, batch_size must be provided. For the last case, validation_steps could be provided. Note that validation_data does not support all the data types that are supported in x , eg, dict, generator or keras.utils.Sequence . required shuffle Boolean (whether to shuffle the training data before each epoch) or str (for 'batch'). This argument is ignored when x is a generator. 'batch' is a special option for dealing with the limitations of HDF5 data; it shuffles in batch-sized chunks. Has no effect when steps_per_epoch is not None . required class_weight Optional dictionary mapping class indices (integers) to a weight (float) value, used for weighting the loss function (during training only). This can be useful to tell the model to \"pay more attention\" to samples from an under-represented class. required sample_weight Optional Numpy array of weights for the training samples, used for weighting the loss function (during training only). You can either pass a flat (1D) Numpy array with the same length as the input samples (1:1 mapping between weights and samples), or in the case of temporal data, you can pass a 2D array with shape (samples, sequence_length) , to apply a different weight to every timestep of every sample. This argument is not supported when x is a dataset, generator, or keras.utils.Sequence instance, instead provide the sample_weights as the third element of x . required initial_epoch Integer. Epoch at which to start training (useful for resuming a previous training run). required steps_per_epoch Integer or None . Total number of steps (batches of samples) before declaring one epoch finished and starting the next epoch. When training with input tensors such as TensorFlow data tensors, the default None is equal to the number of samples in your dataset divided by the batch size, or 1 if that cannot be determined. If x is a tf.data dataset, and 'steps_per_epoch' is None, the epoch will run until the input dataset is exhausted. When passing an infinitely repeating dataset, you must specify the steps_per_epoch argument. This argument is not supported with array inputs. required validation_steps Only relevant if validation_data is provided and is a tf.data dataset. Total number of steps (batches of samples) to draw before stopping when performing validation at the end of every epoch. If 'validation_steps' is None, validation will run until the validation_data dataset is exhausted. In the case of an infinitely repeated dataset, it will run into an infinite loop. If 'validation_steps' is specified and only part of the dataset will be consumed, the evaluation will start from the beginning of the dataset at each epoch. This ensures that the same validation samples are used every time. required validation_batch_size Integer or None . Number of samples per validation batch. If unspecified, will default to batch_size . Do not specify the validation_batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required validation_freq Only relevant if validation data is provided. Integer or collections_abc.Container instance (e.g. list, tuple, etc.). If an integer, specifies how many training epochs to run before a new validation run is performed, e.g. validation_freq=2 runs validation every 2 epochs. If a Container, specifies the epochs on which to run validation, e.g. validation_freq=[1, 2, 10] runs validation at the end of the 1st, 2nd, and 10th epochs. required max_queue_size Integer. Used for generator or keras.utils.Sequence input only. Maximum size for the generator queue. If unspecified, max_queue_size will default to 10. required workers Integer. Used for generator or keras.utils.Sequence input only. Maximum number of processes to spin up when using process-based threading. If unspecified, workers will default to 1. If 0, will execute the generator on the main thread. required use_multiprocessing Boolean. Used for generator or keras.utils.Sequence input only. If True , use process-based threading. If unspecified, use_multiprocessing will default to False . Note that because this implementation relies on multiprocessing, you should not pass non-picklable arguments to the generator as they can't be passed easily to children processes. required Unpacking behavior for iterator-like inputs: A common pattern is to pass a tf.data.Dataset, generator, or tf.keras.utils.Sequence to the x argument of fit, which will in fact yield not only features (x) but optionally targets (y) and sample weights. Keras requires that the output of such iterator-likes be unambiguous. The iterator should return a tuple of length 1, 2, or 3, where the optional second and third elements will be used for y and sample_weight respectively. Any other type provided will be wrapped in a length one tuple, effectively treating everything as 'x'. When yielding dicts, they should still adhere to the top-level tuple structure. e.g. ({\"x0\": x0, \"x1\": x1}, y) . Keras will not attempt to separate features, targets, and weights from the keys of a single dict. A notable unsupported data type is the namedtuple. The reason is that it behaves like both an ordered datatype (tuple) and a mapping datatype (dict). So given a namedtuple of the form: namedtuple(\"example_tuple\", [\"y\", \"x\"]) it is ambiguous whether to reverse the order of the elements when interpreting the value. Even worse is a tuple of the form: namedtuple(\"other_tuple\", [\"x\", \"y\", \"z\"]) where it is unclear if the tuple was intended to be unpacked into x, y, and sample_weight or passed through as a single element to x . As a result the data processing code will simply raise a ValueError if it encounters a namedtuple. (Along with instructions to remedy the issue.) Returns: Type Description A History object. Its History.history attribute is a record of training loss values and metrics values at successive epochs, as well as validation loss values and validation metrics values (if applicable). Exceptions: Type Description RuntimeError If the model was never compiled or, ValueError In case of mismatch between the provided input data and what the model expects or when the input data is empty. transform ( self , inputs ) inherited Map data (x) to latent space (z). Parameters: Name Type Description Default inputs A numpy array with input data. required Returns: Type Description A numpy array with the coordinates of the input data in latent space.","title":"NegativeBinomialAutoencoder"},{"location":"api/models/NegativeBinomialAutoencoder/#negativebinomialautoencoder","text":"","title":"NegativeBinomialAutoencoder"},{"location":"api/models/NegativeBinomialAutoencoder/#latent.models.ae.NegativeBinomialAutoencoder","text":"Autoencoder with fixed negative binomial decoder and reconstruction loss.","title":"NegativeBinomialAutoencoder"},{"location":"api/models/NegativeBinomialAutoencoder/#latent.models.ae.NegativeBinomialAutoencoder.__init__","text":"Parameters: Name Type Description Default encoder Model Keras/tensorflow model object that inputs the data and outputs the latent space. If not provided, a default model will be constructed from the arguments. None name str String indicating the name of the model. 'nb_autoencoder' x_dim int Integer indicating the number of features in the input data. None latent_dim int Integer indicating the number of dimensions in the latent space. 50 encoder_units Iterable[int] Integer list indicating the number of units of the encoder layers. Only used if encoder is not provided. [128, 128] decoder_units Iterable[int] An integer list indicating the number of units of the decoder layers. Only used if decoder is not provided. [128, 128] use_conditions bool Boolean, whether to force the unpacking of conditions from the inputs. False dispersion Union[Literal['gene', 'cell-gene', 'constant'], float] One of the following: 'gene' - dispersion parameter of NB is constant per gene across cells 'cell-gene' - dispersion can differ for every gene in every cell 'constant' - dispersion is constant across all genes and cells float - numeric value of fixed dispersion parameter 'constant' **kwargs Other arguments passed on to DenseStack for constructung encoder/decoder networks. {}","title":"__init__()"},{"location":"api/models/NegativeBinomialAutoencoder/#latent.models.ae.NegativeBinomialAutoencoder.call","text":"Full forward pass through model","title":"call()"},{"location":"api/models/NegativeBinomialAutoencoder/#latent.models.ae.NegativeBinomialAutoencoder.compile","text":"Configures the model for training. Parameters: Name Type Description Default optimizer String (name of optimizer) or optimizer instance. See tf.keras.optimizers . 'adam' loss String (name of objective function), objective function or tf.keras.losses.Loss instance. See tf.keras.losses . An objective function is any callable with the signature loss = fn(y_true, y_pred) , where y_true = ground truth values with shape = [batch_size, d0, .. dN] , except sparse loss functions such as sparse categorical crossentropy where shape = [batch_size, d0, .. dN-1] . y_pred = predicted values with shape = [batch_size, d0, .. dN] . It returns a weighted loss float tensor. If a custom Loss instance is used and reduction is set to NONE, return value has the shape [batch_size, d0, .. dN-1] ie. per-sample or per-timestep loss values; otherwise, it is a scalar. If the model has multiple outputs, you can use a different loss on each output by passing a dictionary or a list of losses. The loss value that will be minimized by the model will then be the sum of all individual losses. None metrics List of metrics to be evaluated by the model during training and testing. Each of this can be a string (name of a built-in function), function or a tf.keras.metrics.Metric instance. See tf.keras.metrics . Typically you will use metrics=['accuracy'] . A function is any callable with the signature result = fn(y_true, y_pred) . To specify different metrics for different outputs of a multi-output model, you could also pass a dictionary, such as metrics={'output_a': 'accuracy', 'output_b': ['accuracy', 'mse']} . You can also pass a list (len = len(outputs)) of lists of metrics such as metrics=[['accuracy'], ['accuracy', 'mse']] or metrics=['accuracy', ['accuracy', 'mse']] . When you pass the strings 'accuracy' or 'acc', we convert this to one of tf.keras.metrics.BinaryAccuracy , tf.keras.metrics.CategoricalAccuracy , tf.keras.metrics.SparseCategoricalAccuracy based on the loss function used and the model output shape. We do a similar conversion for the strings 'crossentropy' and 'ce' as well. required loss_weights Optional list or dictionary specifying scalar coefficients (Python floats) to weight the loss contributions of different model outputs. The loss value that will be minimized by the model will then be the weighted sum of all individual losses, weighted by the loss_weights coefficients. If a list, it is expected to have a 1:1 mapping to the model's outputs. If a dict, it is expected to map output names (strings) to scalar coefficients. required weighted_metrics List of metrics to be evaluated and weighted by sample_weight or class_weight during training and testing. required run_eagerly Bool. Defaults to False . If True , this Model 's logic will not be wrapped in a tf.function . Recommended to leave this as None unless your Model cannot be run inside a tf.function . required steps_per_execution Int. Defaults to 1. The number of batches to run during each tf.function call. Running multiple batches inside a single tf.function call can greatly improve performance on TPUs or small models with a large Python overhead. At most, one full epoch will be run each execution. If a number larger than the size of the epoch is passed, the execution will be truncated to the size of the epoch. Note that if steps_per_execution is set to N , Callback.on_batch_begin and Callback.on_batch_end methods will only be called every N batches (i.e. before/after each tf.function execution). required **kwargs Arguments supported for backwards compatibility only. {} Exceptions: Type Description ValueError In case of invalid arguments for optimizer , loss or metrics .","title":"compile()"},{"location":"api/models/NegativeBinomialAutoencoder/#latent.models.ae.NegativeBinomialAutoencoder.fit","text":"Trains the model for a fixed number of epochs (iterations on a dataset). Parameters: Name Type Description Default x Input data. It could be: - A Numpy array (or array-like), or a list of arrays (in case the model has multiple inputs). - A TensorFlow tensor, or a list of tensors (in case the model has multiple inputs). - A dict mapping input names to the corresponding array/tensors, if the model has named inputs. - A tf.data dataset. Should return a tuple of either (inputs, targets) or (inputs, targets, sample_weights) . - A generator or keras.utils.Sequence returning (inputs, targets) or (inputs, targets, sample_weights) . A more detailed description of unpacking behavior for iterator types (Dataset, generator, Sequence) is given below. required y Target data. Like the input data x , it could be either Numpy array(s) or TensorFlow tensor(s). It should be consistent with x (you cannot have Numpy inputs and tensor targets, or inversely). If x is a dataset, generator, or keras.utils.Sequence instance, y should not be specified (since targets will be obtained from x ). None batch_size Integer or None . Number of samples per gradient update. If unspecified, batch_size will default to 32. Do not specify the batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required epochs Integer. Number of epochs to train the model. An epoch is an iteration over the entire x and y data provided. Note that in conjunction with initial_epoch , epochs is to be understood as \"final epoch\". The model is not trained for a number of iterations given by epochs , but merely until the epoch of index epochs is reached. required verbose 0, 1, or 2. Verbosity mode. 0 = silent, 1 = progress bar, 2 = one line per epoch. Note that the progress bar is not particularly useful when logged to a file, so verbose=2 is recommended when not running interactively (eg, in a production environment). required callbacks List of keras.callbacks.Callback instances. List of callbacks to apply during training. See tf.keras.callbacks . Note tf.keras.callbacks.ProgbarLogger and tf.keras.callbacks.History callbacks are created automatically and need not be passed into model.fit . tf.keras.callbacks.ProgbarLogger is created or not based on verbose argument to model.fit . required validation_split Float between 0 and 1. Fraction of the training data to be used as validation data. The model will set apart this fraction of the training data, will not train on it, and will evaluate the loss and any model metrics on this data at the end of each epoch. The validation data is selected from the last samples in the x and y data provided, before shuffling. This argument is not supported when x is a dataset, generator or keras.utils.Sequence instance. required validation_data Data on which to evaluate the loss and any model metrics at the end of each epoch. The model will not be trained on this data. Thus, note the fact that the validation loss of data provided using validation_split or validation_data is not affected by regularization layers like noise and dropout. validation_data will override validation_split . validation_data could be: - tuple (x_val, y_val) of Numpy arrays or tensors - tuple (x_val, y_val, val_sample_weights) of Numpy arrays - dataset For the first two cases, batch_size must be provided. For the last case, validation_steps could be provided. Note that validation_data does not support all the data types that are supported in x , eg, dict, generator or keras.utils.Sequence . required shuffle Boolean (whether to shuffle the training data before each epoch) or str (for 'batch'). This argument is ignored when x is a generator. 'batch' is a special option for dealing with the limitations of HDF5 data; it shuffles in batch-sized chunks. Has no effect when steps_per_epoch is not None . required class_weight Optional dictionary mapping class indices (integers) to a weight (float) value, used for weighting the loss function (during training only). This can be useful to tell the model to \"pay more attention\" to samples from an under-represented class. required sample_weight Optional Numpy array of weights for the training samples, used for weighting the loss function (during training only). You can either pass a flat (1D) Numpy array with the same length as the input samples (1:1 mapping between weights and samples), or in the case of temporal data, you can pass a 2D array with shape (samples, sequence_length) , to apply a different weight to every timestep of every sample. This argument is not supported when x is a dataset, generator, or keras.utils.Sequence instance, instead provide the sample_weights as the third element of x . required initial_epoch Integer. Epoch at which to start training (useful for resuming a previous training run). required steps_per_epoch Integer or None . Total number of steps (batches of samples) before declaring one epoch finished and starting the next epoch. When training with input tensors such as TensorFlow data tensors, the default None is equal to the number of samples in your dataset divided by the batch size, or 1 if that cannot be determined. If x is a tf.data dataset, and 'steps_per_epoch' is None, the epoch will run until the input dataset is exhausted. When passing an infinitely repeating dataset, you must specify the steps_per_epoch argument. This argument is not supported with array inputs. required validation_steps Only relevant if validation_data is provided and is a tf.data dataset. Total number of steps (batches of samples) to draw before stopping when performing validation at the end of every epoch. If 'validation_steps' is None, validation will run until the validation_data dataset is exhausted. In the case of an infinitely repeated dataset, it will run into an infinite loop. If 'validation_steps' is specified and only part of the dataset will be consumed, the evaluation will start from the beginning of the dataset at each epoch. This ensures that the same validation samples are used every time. required validation_batch_size Integer or None . Number of samples per validation batch. If unspecified, will default to batch_size . Do not specify the validation_batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required validation_freq Only relevant if validation data is provided. Integer or collections_abc.Container instance (e.g. list, tuple, etc.). If an integer, specifies how many training epochs to run before a new validation run is performed, e.g. validation_freq=2 runs validation every 2 epochs. If a Container, specifies the epochs on which to run validation, e.g. validation_freq=[1, 2, 10] runs validation at the end of the 1st, 2nd, and 10th epochs. required max_queue_size Integer. Used for generator or keras.utils.Sequence input only. Maximum size for the generator queue. If unspecified, max_queue_size will default to 10. required workers Integer. Used for generator or keras.utils.Sequence input only. Maximum number of processes to spin up when using process-based threading. If unspecified, workers will default to 1. If 0, will execute the generator on the main thread. required use_multiprocessing Boolean. Used for generator or keras.utils.Sequence input only. If True , use process-based threading. If unspecified, use_multiprocessing will default to False . Note that because this implementation relies on multiprocessing, you should not pass non-picklable arguments to the generator as they can't be passed easily to children processes. required Unpacking behavior for iterator-like inputs: A common pattern is to pass a tf.data.Dataset, generator, or tf.keras.utils.Sequence to the x argument of fit, which will in fact yield not only features (x) but optionally targets (y) and sample weights. Keras requires that the output of such iterator-likes be unambiguous. The iterator should return a tuple of length 1, 2, or 3, where the optional second and third elements will be used for y and sample_weight respectively. Any other type provided will be wrapped in a length one tuple, effectively treating everything as 'x'. When yielding dicts, they should still adhere to the top-level tuple structure. e.g. ({\"x0\": x0, \"x1\": x1}, y) . Keras will not attempt to separate features, targets, and weights from the keys of a single dict. A notable unsupported data type is the namedtuple. The reason is that it behaves like both an ordered datatype (tuple) and a mapping datatype (dict). So given a namedtuple of the form: namedtuple(\"example_tuple\", [\"y\", \"x\"]) it is ambiguous whether to reverse the order of the elements when interpreting the value. Even worse is a tuple of the form: namedtuple(\"other_tuple\", [\"x\", \"y\", \"z\"]) where it is unclear if the tuple was intended to be unpacked into x, y, and sample_weight or passed through as a single element to x . As a result the data processing code will simply raise a ValueError if it encounters a namedtuple. (Along with instructions to remedy the issue.) Returns: Type Description A History object. Its History.history attribute is a record of training loss values and metrics values at successive epochs, as well as validation loss values and validation metrics values (if applicable). Exceptions: Type Description RuntimeError If the model was never compiled or, ValueError In case of mismatch between the provided input data and what the model expects or when the input data is empty.","title":"fit()"},{"location":"api/models/NegativeBinomialAutoencoder/#latent.models.ae.NegativeBinomialAutoencoder.transform","text":"Map data (x) to latent space (z). Parameters: Name Type Description Default inputs A numpy array with input data. required Returns: Type Description A numpy array with the coordinates of the input data in latent space.","title":"transform()"},{"location":"api/models/NegativeBinomialVAE/","text":"NegativeBinomialVAE latent.models.vae.NegativeBinomialVAE Negative binomial variational autoencoder with fixed variational encoder and negative binomial decoder networks. __init__ ( self , name = 'nb_vae' , x_dim = None , latent_dim = 50 , encoder_units = [ 128 , 128 ], decoder_units = [ 128 , 128 ], reconstruction_loss = None , use_conditions = False , dispersion = 'constant' , kld_weight = 1e-05 , prior = 'normal' , latent_dist = 'independent' , iaf_units = [ 256 , 256 ], n_pseudoinputs = 200 , ** kwargs ) special Parameters: Name Type Description Default decoder Keras/tensorflow model object that inputs the latent space and outputs the reconstructed data. If not provided, a default model will be constructed from the arguments. required name str String indicating the name of the model. 'nb_vae' x_dim int Integer indicating the number of features in the input data. None latent_dim int Integer indicating the number of dimensions in the latent space. 50 encoder_units Iterable[int] Integer list indicating the number of units of the encoder layers. Only used if encoder is not provided. [128, 128] decoder_units Iterable[int] An integer list indicating the number of units of the decoder layers. Only used if decoder is not provided. [128, 128] reconstruction_loss Callable Loss function applied to the reconstructed data and to be added by the decoder. Only used if decoder is not provided. Can also be added later by calling compile() . None use_conditions bool Boolean, whether to force the unpacking of conditions from the inputs. False dispersion Union[Literal['gene', 'cell-gene', 'constant'], float] One of the following: 'gene' - dispersion parameter of NB is constant per gene across cells 'cell-gene' - dispersion can differ for every gene in every cell 'constant' - dispersion is constant across all genes and cells float - numeric value of fixed dispersion parameter 'constant' kld_weight float Float indicating the weight of the KL Divergence regularization loss. 1e-05 prior Literal['normal', 'iaf', 'vamp'] The choice of prior distribution. One of the following: 'normal' - A unit gaussian (normal) distribution. 'iaf' - A unit gaussian with a Inverse Autoregressive Flows bijector ( Kingma 2016 ) 'vamp' - A variational mixture of posteriors (VAMP) prior ( Tomczak 2017 ) 'normal' latent_dist Literal['independent', 'multivariate'] The choice of latent distribution. One of the following: 'independent' - A independent normal produced by tfpl.IndependentNormal . 'multivariate' - A multivariate normal produced by tfpl.MultivariateNormalTriL . 'independent' iaf_units Iterable[int] Integer list indicating the units in the IAF bijector network. Only used if prior = 'iaf' . [256, 256] n_pseudoinputs int Integer indicating the number of pseudoinputs for the VAMP prior. Only used if prior = 'vamp' . 200 **kwargs Other arguments passed on to DenseStack for constructung encoder/ decoder networks. {} call ( self , inputs ) inherited Full forward pass through model compile ( self , optimizer = 'adam' , loss = None , ** kwargs ) inherited Configures the model for training. Parameters: Name Type Description Default optimizer String (name of optimizer) or optimizer instance. See tf.keras.optimizers . 'adam' loss String (name of objective function), objective function or tf.keras.losses.Loss instance. See tf.keras.losses . An objective function is any callable with the signature loss = fn(y_true, y_pred) , where y_true = ground truth values with shape = [batch_size, d0, .. dN] , except sparse loss functions such as sparse categorical crossentropy where shape = [batch_size, d0, .. dN-1] . y_pred = predicted values with shape = [batch_size, d0, .. dN] . It returns a weighted loss float tensor. If a custom Loss instance is used and reduction is set to NONE, return value has the shape [batch_size, d0, .. dN-1] ie. per-sample or per-timestep loss values; otherwise, it is a scalar. If the model has multiple outputs, you can use a different loss on each output by passing a dictionary or a list of losses. The loss value that will be minimized by the model will then be the sum of all individual losses. None metrics List of metrics to be evaluated by the model during training and testing. Each of this can be a string (name of a built-in function), function or a tf.keras.metrics.Metric instance. See tf.keras.metrics . Typically you will use metrics=['accuracy'] . A function is any callable with the signature result = fn(y_true, y_pred) . To specify different metrics for different outputs of a multi-output model, you could also pass a dictionary, such as metrics={'output_a': 'accuracy', 'output_b': ['accuracy', 'mse']} . You can also pass a list (len = len(outputs)) of lists of metrics such as metrics=[['accuracy'], ['accuracy', 'mse']] or metrics=['accuracy', ['accuracy', 'mse']] . When you pass the strings 'accuracy' or 'acc', we convert this to one of tf.keras.metrics.BinaryAccuracy , tf.keras.metrics.CategoricalAccuracy , tf.keras.metrics.SparseCategoricalAccuracy based on the loss function used and the model output shape. We do a similar conversion for the strings 'crossentropy' and 'ce' as well. required loss_weights Optional list or dictionary specifying scalar coefficients (Python floats) to weight the loss contributions of different model outputs. The loss value that will be minimized by the model will then be the weighted sum of all individual losses, weighted by the loss_weights coefficients. If a list, it is expected to have a 1:1 mapping to the model's outputs. If a dict, it is expected to map output names (strings) to scalar coefficients. required weighted_metrics List of metrics to be evaluated and weighted by sample_weight or class_weight during training and testing. required run_eagerly Bool. Defaults to False . If True , this Model 's logic will not be wrapped in a tf.function . Recommended to leave this as None unless your Model cannot be run inside a tf.function . required steps_per_execution Int. Defaults to 1. The number of batches to run during each tf.function call. Running multiple batches inside a single tf.function call can greatly improve performance on TPUs or small models with a large Python overhead. At most, one full epoch will be run each execution. If a number larger than the size of the epoch is passed, the execution will be truncated to the size of the epoch. Note that if steps_per_execution is set to N , Callback.on_batch_begin and Callback.on_batch_end methods will only be called every N batches (i.e. before/after each tf.function execution). required **kwargs Arguments supported for backwards compatibility only. {} Exceptions: Type Description ValueError In case of invalid arguments for optimizer , loss or metrics . fit ( self , x , y = None , ** kwargs ) inherited Trains the model for a fixed number of epochs (iterations on a dataset). Parameters: Name Type Description Default x Input data. It could be: - A Numpy array (or array-like), or a list of arrays (in case the model has multiple inputs). - A TensorFlow tensor, or a list of tensors (in case the model has multiple inputs). - A dict mapping input names to the corresponding array/tensors, if the model has named inputs. - A tf.data dataset. Should return a tuple of either (inputs, targets) or (inputs, targets, sample_weights) . - A generator or keras.utils.Sequence returning (inputs, targets) or (inputs, targets, sample_weights) . A more detailed description of unpacking behavior for iterator types (Dataset, generator, Sequence) is given below. required y Target data. Like the input data x , it could be either Numpy array(s) or TensorFlow tensor(s). It should be consistent with x (you cannot have Numpy inputs and tensor targets, or inversely). If x is a dataset, generator, or keras.utils.Sequence instance, y should not be specified (since targets will be obtained from x ). None batch_size Integer or None . Number of samples per gradient update. If unspecified, batch_size will default to 32. Do not specify the batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required epochs Integer. Number of epochs to train the model. An epoch is an iteration over the entire x and y data provided. Note that in conjunction with initial_epoch , epochs is to be understood as \"final epoch\". The model is not trained for a number of iterations given by epochs , but merely until the epoch of index epochs is reached. required verbose 0, 1, or 2. Verbosity mode. 0 = silent, 1 = progress bar, 2 = one line per epoch. Note that the progress bar is not particularly useful when logged to a file, so verbose=2 is recommended when not running interactively (eg, in a production environment). required callbacks List of keras.callbacks.Callback instances. List of callbacks to apply during training. See tf.keras.callbacks . Note tf.keras.callbacks.ProgbarLogger and tf.keras.callbacks.History callbacks are created automatically and need not be passed into model.fit . tf.keras.callbacks.ProgbarLogger is created or not based on verbose argument to model.fit . required validation_split Float between 0 and 1. Fraction of the training data to be used as validation data. The model will set apart this fraction of the training data, will not train on it, and will evaluate the loss and any model metrics on this data at the end of each epoch. The validation data is selected from the last samples in the x and y data provided, before shuffling. This argument is not supported when x is a dataset, generator or keras.utils.Sequence instance. required validation_data Data on which to evaluate the loss and any model metrics at the end of each epoch. The model will not be trained on this data. Thus, note the fact that the validation loss of data provided using validation_split or validation_data is not affected by regularization layers like noise and dropout. validation_data will override validation_split . validation_data could be: - tuple (x_val, y_val) of Numpy arrays or tensors - tuple (x_val, y_val, val_sample_weights) of Numpy arrays - dataset For the first two cases, batch_size must be provided. For the last case, validation_steps could be provided. Note that validation_data does not support all the data types that are supported in x , eg, dict, generator or keras.utils.Sequence . required shuffle Boolean (whether to shuffle the training data before each epoch) or str (for 'batch'). This argument is ignored when x is a generator. 'batch' is a special option for dealing with the limitations of HDF5 data; it shuffles in batch-sized chunks. Has no effect when steps_per_epoch is not None . required class_weight Optional dictionary mapping class indices (integers) to a weight (float) value, used for weighting the loss function (during training only). This can be useful to tell the model to \"pay more attention\" to samples from an under-represented class. required sample_weight Optional Numpy array of weights for the training samples, used for weighting the loss function (during training only). You can either pass a flat (1D) Numpy array with the same length as the input samples (1:1 mapping between weights and samples), or in the case of temporal data, you can pass a 2D array with shape (samples, sequence_length) , to apply a different weight to every timestep of every sample. This argument is not supported when x is a dataset, generator, or keras.utils.Sequence instance, instead provide the sample_weights as the third element of x . required initial_epoch Integer. Epoch at which to start training (useful for resuming a previous training run). required steps_per_epoch Integer or None . Total number of steps (batches of samples) before declaring one epoch finished and starting the next epoch. When training with input tensors such as TensorFlow data tensors, the default None is equal to the number of samples in your dataset divided by the batch size, or 1 if that cannot be determined. If x is a tf.data dataset, and 'steps_per_epoch' is None, the epoch will run until the input dataset is exhausted. When passing an infinitely repeating dataset, you must specify the steps_per_epoch argument. This argument is not supported with array inputs. required validation_steps Only relevant if validation_data is provided and is a tf.data dataset. Total number of steps (batches of samples) to draw before stopping when performing validation at the end of every epoch. If 'validation_steps' is None, validation will run until the validation_data dataset is exhausted. In the case of an infinitely repeated dataset, it will run into an infinite loop. If 'validation_steps' is specified and only part of the dataset will be consumed, the evaluation will start from the beginning of the dataset at each epoch. This ensures that the same validation samples are used every time. required validation_batch_size Integer or None . Number of samples per validation batch. If unspecified, will default to batch_size . Do not specify the validation_batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required validation_freq Only relevant if validation data is provided. Integer or collections_abc.Container instance (e.g. list, tuple, etc.). If an integer, specifies how many training epochs to run before a new validation run is performed, e.g. validation_freq=2 runs validation every 2 epochs. If a Container, specifies the epochs on which to run validation, e.g. validation_freq=[1, 2, 10] runs validation at the end of the 1st, 2nd, and 10th epochs. required max_queue_size Integer. Used for generator or keras.utils.Sequence input only. Maximum size for the generator queue. If unspecified, max_queue_size will default to 10. required workers Integer. Used for generator or keras.utils.Sequence input only. Maximum number of processes to spin up when using process-based threading. If unspecified, workers will default to 1. If 0, will execute the generator on the main thread. required use_multiprocessing Boolean. Used for generator or keras.utils.Sequence input only. If True , use process-based threading. If unspecified, use_multiprocessing will default to False . Note that because this implementation relies on multiprocessing, you should not pass non-picklable arguments to the generator as they can't be passed easily to children processes. required Unpacking behavior for iterator-like inputs: A common pattern is to pass a tf.data.Dataset, generator, or tf.keras.utils.Sequence to the x argument of fit, which will in fact yield not only features (x) but optionally targets (y) and sample weights. Keras requires that the output of such iterator-likes be unambiguous. The iterator should return a tuple of length 1, 2, or 3, where the optional second and third elements will be used for y and sample_weight respectively. Any other type provided will be wrapped in a length one tuple, effectively treating everything as 'x'. When yielding dicts, they should still adhere to the top-level tuple structure. e.g. ({\"x0\": x0, \"x1\": x1}, y) . Keras will not attempt to separate features, targets, and weights from the keys of a single dict. A notable unsupported data type is the namedtuple. The reason is that it behaves like both an ordered datatype (tuple) and a mapping datatype (dict). So given a namedtuple of the form: namedtuple(\"example_tuple\", [\"y\", \"x\"]) it is ambiguous whether to reverse the order of the elements when interpreting the value. Even worse is a tuple of the form: namedtuple(\"other_tuple\", [\"x\", \"y\", \"z\"]) where it is unclear if the tuple was intended to be unpacked into x, y, and sample_weight or passed through as a single element to x . As a result the data processing code will simply raise a ValueError if it encounters a namedtuple. (Along with instructions to remedy the issue.) Returns: Type Description A History object. Its History.history attribute is a record of training loss values and metrics values at successive epochs, as well as validation loss values and validation metrics values (if applicable). Exceptions: Type Description RuntimeError If the model was never compiled or, ValueError In case of mismatch between the provided input data and what the model expects or when the input data is empty. transform ( self , inputs ) inherited Map data (x) to latent space (z). Parameters: Name Type Description Default inputs A numpy array with input data. required Returns: Type Description A numpy array with the coordinates of the input data in latent space.","title":"NegativeBinomialVAE"},{"location":"api/models/NegativeBinomialVAE/#negativebinomialvae","text":"","title":"NegativeBinomialVAE"},{"location":"api/models/NegativeBinomialVAE/#latent.models.vae.NegativeBinomialVAE","text":"Negative binomial variational autoencoder with fixed variational encoder and negative binomial decoder networks.","title":"NegativeBinomialVAE"},{"location":"api/models/NegativeBinomialVAE/#latent.models.vae.NegativeBinomialVAE.__init__","text":"Parameters: Name Type Description Default decoder Keras/tensorflow model object that inputs the latent space and outputs the reconstructed data. If not provided, a default model will be constructed from the arguments. required name str String indicating the name of the model. 'nb_vae' x_dim int Integer indicating the number of features in the input data. None latent_dim int Integer indicating the number of dimensions in the latent space. 50 encoder_units Iterable[int] Integer list indicating the number of units of the encoder layers. Only used if encoder is not provided. [128, 128] decoder_units Iterable[int] An integer list indicating the number of units of the decoder layers. Only used if decoder is not provided. [128, 128] reconstruction_loss Callable Loss function applied to the reconstructed data and to be added by the decoder. Only used if decoder is not provided. Can also be added later by calling compile() . None use_conditions bool Boolean, whether to force the unpacking of conditions from the inputs. False dispersion Union[Literal['gene', 'cell-gene', 'constant'], float] One of the following: 'gene' - dispersion parameter of NB is constant per gene across cells 'cell-gene' - dispersion can differ for every gene in every cell 'constant' - dispersion is constant across all genes and cells float - numeric value of fixed dispersion parameter 'constant' kld_weight float Float indicating the weight of the KL Divergence regularization loss. 1e-05 prior Literal['normal', 'iaf', 'vamp'] The choice of prior distribution. One of the following: 'normal' - A unit gaussian (normal) distribution. 'iaf' - A unit gaussian with a Inverse Autoregressive Flows bijector ( Kingma 2016 ) 'vamp' - A variational mixture of posteriors (VAMP) prior ( Tomczak 2017 ) 'normal' latent_dist Literal['independent', 'multivariate'] The choice of latent distribution. One of the following: 'independent' - A independent normal produced by tfpl.IndependentNormal . 'multivariate' - A multivariate normal produced by tfpl.MultivariateNormalTriL . 'independent' iaf_units Iterable[int] Integer list indicating the units in the IAF bijector network. Only used if prior = 'iaf' . [256, 256] n_pseudoinputs int Integer indicating the number of pseudoinputs for the VAMP prior. Only used if prior = 'vamp' . 200 **kwargs Other arguments passed on to DenseStack for constructung encoder/ decoder networks. {}","title":"__init__()"},{"location":"api/models/NegativeBinomialVAE/#latent.models.vae.NegativeBinomialVAE.call","text":"Full forward pass through model","title":"call()"},{"location":"api/models/NegativeBinomialVAE/#latent.models.vae.NegativeBinomialVAE.compile","text":"Configures the model for training. Parameters: Name Type Description Default optimizer String (name of optimizer) or optimizer instance. See tf.keras.optimizers . 'adam' loss String (name of objective function), objective function or tf.keras.losses.Loss instance. See tf.keras.losses . An objective function is any callable with the signature loss = fn(y_true, y_pred) , where y_true = ground truth values with shape = [batch_size, d0, .. dN] , except sparse loss functions such as sparse categorical crossentropy where shape = [batch_size, d0, .. dN-1] . y_pred = predicted values with shape = [batch_size, d0, .. dN] . It returns a weighted loss float tensor. If a custom Loss instance is used and reduction is set to NONE, return value has the shape [batch_size, d0, .. dN-1] ie. per-sample or per-timestep loss values; otherwise, it is a scalar. If the model has multiple outputs, you can use a different loss on each output by passing a dictionary or a list of losses. The loss value that will be minimized by the model will then be the sum of all individual losses. None metrics List of metrics to be evaluated by the model during training and testing. Each of this can be a string (name of a built-in function), function or a tf.keras.metrics.Metric instance. See tf.keras.metrics . Typically you will use metrics=['accuracy'] . A function is any callable with the signature result = fn(y_true, y_pred) . To specify different metrics for different outputs of a multi-output model, you could also pass a dictionary, such as metrics={'output_a': 'accuracy', 'output_b': ['accuracy', 'mse']} . You can also pass a list (len = len(outputs)) of lists of metrics such as metrics=[['accuracy'], ['accuracy', 'mse']] or metrics=['accuracy', ['accuracy', 'mse']] . When you pass the strings 'accuracy' or 'acc', we convert this to one of tf.keras.metrics.BinaryAccuracy , tf.keras.metrics.CategoricalAccuracy , tf.keras.metrics.SparseCategoricalAccuracy based on the loss function used and the model output shape. We do a similar conversion for the strings 'crossentropy' and 'ce' as well. required loss_weights Optional list or dictionary specifying scalar coefficients (Python floats) to weight the loss contributions of different model outputs. The loss value that will be minimized by the model will then be the weighted sum of all individual losses, weighted by the loss_weights coefficients. If a list, it is expected to have a 1:1 mapping to the model's outputs. If a dict, it is expected to map output names (strings) to scalar coefficients. required weighted_metrics List of metrics to be evaluated and weighted by sample_weight or class_weight during training and testing. required run_eagerly Bool. Defaults to False . If True , this Model 's logic will not be wrapped in a tf.function . Recommended to leave this as None unless your Model cannot be run inside a tf.function . required steps_per_execution Int. Defaults to 1. The number of batches to run during each tf.function call. Running multiple batches inside a single tf.function call can greatly improve performance on TPUs or small models with a large Python overhead. At most, one full epoch will be run each execution. If a number larger than the size of the epoch is passed, the execution will be truncated to the size of the epoch. Note that if steps_per_execution is set to N , Callback.on_batch_begin and Callback.on_batch_end methods will only be called every N batches (i.e. before/after each tf.function execution). required **kwargs Arguments supported for backwards compatibility only. {} Exceptions: Type Description ValueError In case of invalid arguments for optimizer , loss or metrics .","title":"compile()"},{"location":"api/models/NegativeBinomialVAE/#latent.models.vae.NegativeBinomialVAE.fit","text":"Trains the model for a fixed number of epochs (iterations on a dataset). Parameters: Name Type Description Default x Input data. It could be: - A Numpy array (or array-like), or a list of arrays (in case the model has multiple inputs). - A TensorFlow tensor, or a list of tensors (in case the model has multiple inputs). - A dict mapping input names to the corresponding array/tensors, if the model has named inputs. - A tf.data dataset. Should return a tuple of either (inputs, targets) or (inputs, targets, sample_weights) . - A generator or keras.utils.Sequence returning (inputs, targets) or (inputs, targets, sample_weights) . A more detailed description of unpacking behavior for iterator types (Dataset, generator, Sequence) is given below. required y Target data. Like the input data x , it could be either Numpy array(s) or TensorFlow tensor(s). It should be consistent with x (you cannot have Numpy inputs and tensor targets, or inversely). If x is a dataset, generator, or keras.utils.Sequence instance, y should not be specified (since targets will be obtained from x ). None batch_size Integer or None . Number of samples per gradient update. If unspecified, batch_size will default to 32. Do not specify the batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required epochs Integer. Number of epochs to train the model. An epoch is an iteration over the entire x and y data provided. Note that in conjunction with initial_epoch , epochs is to be understood as \"final epoch\". The model is not trained for a number of iterations given by epochs , but merely until the epoch of index epochs is reached. required verbose 0, 1, or 2. Verbosity mode. 0 = silent, 1 = progress bar, 2 = one line per epoch. Note that the progress bar is not particularly useful when logged to a file, so verbose=2 is recommended when not running interactively (eg, in a production environment). required callbacks List of keras.callbacks.Callback instances. List of callbacks to apply during training. See tf.keras.callbacks . Note tf.keras.callbacks.ProgbarLogger and tf.keras.callbacks.History callbacks are created automatically and need not be passed into model.fit . tf.keras.callbacks.ProgbarLogger is created or not based on verbose argument to model.fit . required validation_split Float between 0 and 1. Fraction of the training data to be used as validation data. The model will set apart this fraction of the training data, will not train on it, and will evaluate the loss and any model metrics on this data at the end of each epoch. The validation data is selected from the last samples in the x and y data provided, before shuffling. This argument is not supported when x is a dataset, generator or keras.utils.Sequence instance. required validation_data Data on which to evaluate the loss and any model metrics at the end of each epoch. The model will not be trained on this data. Thus, note the fact that the validation loss of data provided using validation_split or validation_data is not affected by regularization layers like noise and dropout. validation_data will override validation_split . validation_data could be: - tuple (x_val, y_val) of Numpy arrays or tensors - tuple (x_val, y_val, val_sample_weights) of Numpy arrays - dataset For the first two cases, batch_size must be provided. For the last case, validation_steps could be provided. Note that validation_data does not support all the data types that are supported in x , eg, dict, generator or keras.utils.Sequence . required shuffle Boolean (whether to shuffle the training data before each epoch) or str (for 'batch'). This argument is ignored when x is a generator. 'batch' is a special option for dealing with the limitations of HDF5 data; it shuffles in batch-sized chunks. Has no effect when steps_per_epoch is not None . required class_weight Optional dictionary mapping class indices (integers) to a weight (float) value, used for weighting the loss function (during training only). This can be useful to tell the model to \"pay more attention\" to samples from an under-represented class. required sample_weight Optional Numpy array of weights for the training samples, used for weighting the loss function (during training only). You can either pass a flat (1D) Numpy array with the same length as the input samples (1:1 mapping between weights and samples), or in the case of temporal data, you can pass a 2D array with shape (samples, sequence_length) , to apply a different weight to every timestep of every sample. This argument is not supported when x is a dataset, generator, or keras.utils.Sequence instance, instead provide the sample_weights as the third element of x . required initial_epoch Integer. Epoch at which to start training (useful for resuming a previous training run). required steps_per_epoch Integer or None . Total number of steps (batches of samples) before declaring one epoch finished and starting the next epoch. When training with input tensors such as TensorFlow data tensors, the default None is equal to the number of samples in your dataset divided by the batch size, or 1 if that cannot be determined. If x is a tf.data dataset, and 'steps_per_epoch' is None, the epoch will run until the input dataset is exhausted. When passing an infinitely repeating dataset, you must specify the steps_per_epoch argument. This argument is not supported with array inputs. required validation_steps Only relevant if validation_data is provided and is a tf.data dataset. Total number of steps (batches of samples) to draw before stopping when performing validation at the end of every epoch. If 'validation_steps' is None, validation will run until the validation_data dataset is exhausted. In the case of an infinitely repeated dataset, it will run into an infinite loop. If 'validation_steps' is specified and only part of the dataset will be consumed, the evaluation will start from the beginning of the dataset at each epoch. This ensures that the same validation samples are used every time. required validation_batch_size Integer or None . Number of samples per validation batch. If unspecified, will default to batch_size . Do not specify the validation_batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required validation_freq Only relevant if validation data is provided. Integer or collections_abc.Container instance (e.g. list, tuple, etc.). If an integer, specifies how many training epochs to run before a new validation run is performed, e.g. validation_freq=2 runs validation every 2 epochs. If a Container, specifies the epochs on which to run validation, e.g. validation_freq=[1, 2, 10] runs validation at the end of the 1st, 2nd, and 10th epochs. required max_queue_size Integer. Used for generator or keras.utils.Sequence input only. Maximum size for the generator queue. If unspecified, max_queue_size will default to 10. required workers Integer. Used for generator or keras.utils.Sequence input only. Maximum number of processes to spin up when using process-based threading. If unspecified, workers will default to 1. If 0, will execute the generator on the main thread. required use_multiprocessing Boolean. Used for generator or keras.utils.Sequence input only. If True , use process-based threading. If unspecified, use_multiprocessing will default to False . Note that because this implementation relies on multiprocessing, you should not pass non-picklable arguments to the generator as they can't be passed easily to children processes. required Unpacking behavior for iterator-like inputs: A common pattern is to pass a tf.data.Dataset, generator, or tf.keras.utils.Sequence to the x argument of fit, which will in fact yield not only features (x) but optionally targets (y) and sample weights. Keras requires that the output of such iterator-likes be unambiguous. The iterator should return a tuple of length 1, 2, or 3, where the optional second and third elements will be used for y and sample_weight respectively. Any other type provided will be wrapped in a length one tuple, effectively treating everything as 'x'. When yielding dicts, they should still adhere to the top-level tuple structure. e.g. ({\"x0\": x0, \"x1\": x1}, y) . Keras will not attempt to separate features, targets, and weights from the keys of a single dict. A notable unsupported data type is the namedtuple. The reason is that it behaves like both an ordered datatype (tuple) and a mapping datatype (dict). So given a namedtuple of the form: namedtuple(\"example_tuple\", [\"y\", \"x\"]) it is ambiguous whether to reverse the order of the elements when interpreting the value. Even worse is a tuple of the form: namedtuple(\"other_tuple\", [\"x\", \"y\", \"z\"]) where it is unclear if the tuple was intended to be unpacked into x, y, and sample_weight or passed through as a single element to x . As a result the data processing code will simply raise a ValueError if it encounters a namedtuple. (Along with instructions to remedy the issue.) Returns: Type Description A History object. Its History.history attribute is a record of training loss values and metrics values at successive epochs, as well as validation loss values and validation metrics values (if applicable). Exceptions: Type Description RuntimeError If the model was never compiled or, ValueError In case of mismatch between the provided input data and what the model expects or when the input data is empty.","title":"fit()"},{"location":"api/models/NegativeBinomialVAE/#latent.models.vae.NegativeBinomialVAE.transform","text":"Map data (x) to latent space (z). Parameters: Name Type Description Default inputs A numpy array with input data. required Returns: Type Description A numpy array with the coordinates of the input data in latent space.","title":"transform()"},{"location":"api/models/PoissonAutoencoder/","text":"PoissonAutoencoder latent.models.ae.PoissonAutoencoder Autoencoder with fixed poisson decoder and reconstruction loss. __init__ ( self , encoder = None , name = 'poisson_autoencoder' , x_dim = None , latent_dim = 50 , encoder_units = [ 128 , 128 ], decoder_units = [ 128 , 128 ], use_conditions = False , ** kwargs ) special Parameters: Name Type Description Default encoder Model Keras/tensorflow model object that inputs the data and outputs the latent space. If not provided, a default model will be constructed from the arguments. None name str String indicating the name of the model. 'poisson_autoencoder' x_dim int Integer indicating the number of features in the input data. None latent_dim int Integer indicating the number of dimensions in the latent space. 50 encoder_units Iterable[int] Integer list indicating the number of units of the encoder layers. Only used if encoder is not provided. [128, 128] decoder_units Iterable[int] An integer list indicating the number of units of the decoder layers. Only used if decoder is not provided. [128, 128] use_conditions bool Boolean, whether to force the unpacking of conditions from the inputs. False **kwargs Other arguments passed on to DenseStack for constructung encoder/decoder networks. {} call ( self , inputs ) inherited Full forward pass through model compile ( self , optimizer = 'adam' , loss = None , ** kwargs ) inherited Configures the model for training. Parameters: Name Type Description Default optimizer String (name of optimizer) or optimizer instance. See tf.keras.optimizers . 'adam' loss String (name of objective function), objective function or tf.keras.losses.Loss instance. See tf.keras.losses . An objective function is any callable with the signature loss = fn(y_true, y_pred) , where y_true = ground truth values with shape = [batch_size, d0, .. dN] , except sparse loss functions such as sparse categorical crossentropy where shape = [batch_size, d0, .. dN-1] . y_pred = predicted values with shape = [batch_size, d0, .. dN] . It returns a weighted loss float tensor. If a custom Loss instance is used and reduction is set to NONE, return value has the shape [batch_size, d0, .. dN-1] ie. per-sample or per-timestep loss values; otherwise, it is a scalar. If the model has multiple outputs, you can use a different loss on each output by passing a dictionary or a list of losses. The loss value that will be minimized by the model will then be the sum of all individual losses. None metrics List of metrics to be evaluated by the model during training and testing. Each of this can be a string (name of a built-in function), function or a tf.keras.metrics.Metric instance. See tf.keras.metrics . Typically you will use metrics=['accuracy'] . A function is any callable with the signature result = fn(y_true, y_pred) . To specify different metrics for different outputs of a multi-output model, you could also pass a dictionary, such as metrics={'output_a': 'accuracy', 'output_b': ['accuracy', 'mse']} . You can also pass a list (len = len(outputs)) of lists of metrics such as metrics=[['accuracy'], ['accuracy', 'mse']] or metrics=['accuracy', ['accuracy', 'mse']] . When you pass the strings 'accuracy' or 'acc', we convert this to one of tf.keras.metrics.BinaryAccuracy , tf.keras.metrics.CategoricalAccuracy , tf.keras.metrics.SparseCategoricalAccuracy based on the loss function used and the model output shape. We do a similar conversion for the strings 'crossentropy' and 'ce' as well. required loss_weights Optional list or dictionary specifying scalar coefficients (Python floats) to weight the loss contributions of different model outputs. The loss value that will be minimized by the model will then be the weighted sum of all individual losses, weighted by the loss_weights coefficients. If a list, it is expected to have a 1:1 mapping to the model's outputs. If a dict, it is expected to map output names (strings) to scalar coefficients. required weighted_metrics List of metrics to be evaluated and weighted by sample_weight or class_weight during training and testing. required run_eagerly Bool. Defaults to False . If True , this Model 's logic will not be wrapped in a tf.function . Recommended to leave this as None unless your Model cannot be run inside a tf.function . required steps_per_execution Int. Defaults to 1. The number of batches to run during each tf.function call. Running multiple batches inside a single tf.function call can greatly improve performance on TPUs or small models with a large Python overhead. At most, one full epoch will be run each execution. If a number larger than the size of the epoch is passed, the execution will be truncated to the size of the epoch. Note that if steps_per_execution is set to N , Callback.on_batch_begin and Callback.on_batch_end methods will only be called every N batches (i.e. before/after each tf.function execution). required **kwargs Arguments supported for backwards compatibility only. {} Exceptions: Type Description ValueError In case of invalid arguments for optimizer , loss or metrics . fit ( self , x , y = None , ** kwargs ) inherited Trains the model for a fixed number of epochs (iterations on a dataset). Parameters: Name Type Description Default x Input data. It could be: - A Numpy array (or array-like), or a list of arrays (in case the model has multiple inputs). - A TensorFlow tensor, or a list of tensors (in case the model has multiple inputs). - A dict mapping input names to the corresponding array/tensors, if the model has named inputs. - A tf.data dataset. Should return a tuple of either (inputs, targets) or (inputs, targets, sample_weights) . - A generator or keras.utils.Sequence returning (inputs, targets) or (inputs, targets, sample_weights) . A more detailed description of unpacking behavior for iterator types (Dataset, generator, Sequence) is given below. required y Target data. Like the input data x , it could be either Numpy array(s) or TensorFlow tensor(s). It should be consistent with x (you cannot have Numpy inputs and tensor targets, or inversely). If x is a dataset, generator, or keras.utils.Sequence instance, y should not be specified (since targets will be obtained from x ). None batch_size Integer or None . Number of samples per gradient update. If unspecified, batch_size will default to 32. Do not specify the batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required epochs Integer. Number of epochs to train the model. An epoch is an iteration over the entire x and y data provided. Note that in conjunction with initial_epoch , epochs is to be understood as \"final epoch\". The model is not trained for a number of iterations given by epochs , but merely until the epoch of index epochs is reached. required verbose 0, 1, or 2. Verbosity mode. 0 = silent, 1 = progress bar, 2 = one line per epoch. Note that the progress bar is not particularly useful when logged to a file, so verbose=2 is recommended when not running interactively (eg, in a production environment). required callbacks List of keras.callbacks.Callback instances. List of callbacks to apply during training. See tf.keras.callbacks . Note tf.keras.callbacks.ProgbarLogger and tf.keras.callbacks.History callbacks are created automatically and need not be passed into model.fit . tf.keras.callbacks.ProgbarLogger is created or not based on verbose argument to model.fit . required validation_split Float between 0 and 1. Fraction of the training data to be used as validation data. The model will set apart this fraction of the training data, will not train on it, and will evaluate the loss and any model metrics on this data at the end of each epoch. The validation data is selected from the last samples in the x and y data provided, before shuffling. This argument is not supported when x is a dataset, generator or keras.utils.Sequence instance. required validation_data Data on which to evaluate the loss and any model metrics at the end of each epoch. The model will not be trained on this data. Thus, note the fact that the validation loss of data provided using validation_split or validation_data is not affected by regularization layers like noise and dropout. validation_data will override validation_split . validation_data could be: - tuple (x_val, y_val) of Numpy arrays or tensors - tuple (x_val, y_val, val_sample_weights) of Numpy arrays - dataset For the first two cases, batch_size must be provided. For the last case, validation_steps could be provided. Note that validation_data does not support all the data types that are supported in x , eg, dict, generator or keras.utils.Sequence . required shuffle Boolean (whether to shuffle the training data before each epoch) or str (for 'batch'). This argument is ignored when x is a generator. 'batch' is a special option for dealing with the limitations of HDF5 data; it shuffles in batch-sized chunks. Has no effect when steps_per_epoch is not None . required class_weight Optional dictionary mapping class indices (integers) to a weight (float) value, used for weighting the loss function (during training only). This can be useful to tell the model to \"pay more attention\" to samples from an under-represented class. required sample_weight Optional Numpy array of weights for the training samples, used for weighting the loss function (during training only). You can either pass a flat (1D) Numpy array with the same length as the input samples (1:1 mapping between weights and samples), or in the case of temporal data, you can pass a 2D array with shape (samples, sequence_length) , to apply a different weight to every timestep of every sample. This argument is not supported when x is a dataset, generator, or keras.utils.Sequence instance, instead provide the sample_weights as the third element of x . required initial_epoch Integer. Epoch at which to start training (useful for resuming a previous training run). required steps_per_epoch Integer or None . Total number of steps (batches of samples) before declaring one epoch finished and starting the next epoch. When training with input tensors such as TensorFlow data tensors, the default None is equal to the number of samples in your dataset divided by the batch size, or 1 if that cannot be determined. If x is a tf.data dataset, and 'steps_per_epoch' is None, the epoch will run until the input dataset is exhausted. When passing an infinitely repeating dataset, you must specify the steps_per_epoch argument. This argument is not supported with array inputs. required validation_steps Only relevant if validation_data is provided and is a tf.data dataset. Total number of steps (batches of samples) to draw before stopping when performing validation at the end of every epoch. If 'validation_steps' is None, validation will run until the validation_data dataset is exhausted. In the case of an infinitely repeated dataset, it will run into an infinite loop. If 'validation_steps' is specified and only part of the dataset will be consumed, the evaluation will start from the beginning of the dataset at each epoch. This ensures that the same validation samples are used every time. required validation_batch_size Integer or None . Number of samples per validation batch. If unspecified, will default to batch_size . Do not specify the validation_batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required validation_freq Only relevant if validation data is provided. Integer or collections_abc.Container instance (e.g. list, tuple, etc.). If an integer, specifies how many training epochs to run before a new validation run is performed, e.g. validation_freq=2 runs validation every 2 epochs. If a Container, specifies the epochs on which to run validation, e.g. validation_freq=[1, 2, 10] runs validation at the end of the 1st, 2nd, and 10th epochs. required max_queue_size Integer. Used for generator or keras.utils.Sequence input only. Maximum size for the generator queue. If unspecified, max_queue_size will default to 10. required workers Integer. Used for generator or keras.utils.Sequence input only. Maximum number of processes to spin up when using process-based threading. If unspecified, workers will default to 1. If 0, will execute the generator on the main thread. required use_multiprocessing Boolean. Used for generator or keras.utils.Sequence input only. If True , use process-based threading. If unspecified, use_multiprocessing will default to False . Note that because this implementation relies on multiprocessing, you should not pass non-picklable arguments to the generator as they can't be passed easily to children processes. required Unpacking behavior for iterator-like inputs: A common pattern is to pass a tf.data.Dataset, generator, or tf.keras.utils.Sequence to the x argument of fit, which will in fact yield not only features (x) but optionally targets (y) and sample weights. Keras requires that the output of such iterator-likes be unambiguous. The iterator should return a tuple of length 1, 2, or 3, where the optional second and third elements will be used for y and sample_weight respectively. Any other type provided will be wrapped in a length one tuple, effectively treating everything as 'x'. When yielding dicts, they should still adhere to the top-level tuple structure. e.g. ({\"x0\": x0, \"x1\": x1}, y) . Keras will not attempt to separate features, targets, and weights from the keys of a single dict. A notable unsupported data type is the namedtuple. The reason is that it behaves like both an ordered datatype (tuple) and a mapping datatype (dict). So given a namedtuple of the form: namedtuple(\"example_tuple\", [\"y\", \"x\"]) it is ambiguous whether to reverse the order of the elements when interpreting the value. Even worse is a tuple of the form: namedtuple(\"other_tuple\", [\"x\", \"y\", \"z\"]) where it is unclear if the tuple was intended to be unpacked into x, y, and sample_weight or passed through as a single element to x . As a result the data processing code will simply raise a ValueError if it encounters a namedtuple. (Along with instructions to remedy the issue.) Returns: Type Description A History object. Its History.history attribute is a record of training loss values and metrics values at successive epochs, as well as validation loss values and validation metrics values (if applicable). Exceptions: Type Description RuntimeError If the model was never compiled or, ValueError In case of mismatch between the provided input data and what the model expects or when the input data is empty. transform ( self , inputs ) inherited Map data (x) to latent space (z). Parameters: Name Type Description Default inputs A numpy array with input data. required Returns: Type Description A numpy array with the coordinates of the input data in latent space.","title":"PoissonAutoencoder"},{"location":"api/models/PoissonAutoencoder/#poissonautoencoder","text":"","title":"PoissonAutoencoder"},{"location":"api/models/PoissonAutoencoder/#latent.models.ae.PoissonAutoencoder","text":"Autoencoder with fixed poisson decoder and reconstruction loss.","title":"PoissonAutoencoder"},{"location":"api/models/PoissonAutoencoder/#latent.models.ae.PoissonAutoencoder.__init__","text":"Parameters: Name Type Description Default encoder Model Keras/tensorflow model object that inputs the data and outputs the latent space. If not provided, a default model will be constructed from the arguments. None name str String indicating the name of the model. 'poisson_autoencoder' x_dim int Integer indicating the number of features in the input data. None latent_dim int Integer indicating the number of dimensions in the latent space. 50 encoder_units Iterable[int] Integer list indicating the number of units of the encoder layers. Only used if encoder is not provided. [128, 128] decoder_units Iterable[int] An integer list indicating the number of units of the decoder layers. Only used if decoder is not provided. [128, 128] use_conditions bool Boolean, whether to force the unpacking of conditions from the inputs. False **kwargs Other arguments passed on to DenseStack for constructung encoder/decoder networks. {}","title":"__init__()"},{"location":"api/models/PoissonAutoencoder/#latent.models.ae.PoissonAutoencoder.call","text":"Full forward pass through model","title":"call()"},{"location":"api/models/PoissonAutoencoder/#latent.models.ae.PoissonAutoencoder.compile","text":"Configures the model for training. Parameters: Name Type Description Default optimizer String (name of optimizer) or optimizer instance. See tf.keras.optimizers . 'adam' loss String (name of objective function), objective function or tf.keras.losses.Loss instance. See tf.keras.losses . An objective function is any callable with the signature loss = fn(y_true, y_pred) , where y_true = ground truth values with shape = [batch_size, d0, .. dN] , except sparse loss functions such as sparse categorical crossentropy where shape = [batch_size, d0, .. dN-1] . y_pred = predicted values with shape = [batch_size, d0, .. dN] . It returns a weighted loss float tensor. If a custom Loss instance is used and reduction is set to NONE, return value has the shape [batch_size, d0, .. dN-1] ie. per-sample or per-timestep loss values; otherwise, it is a scalar. If the model has multiple outputs, you can use a different loss on each output by passing a dictionary or a list of losses. The loss value that will be minimized by the model will then be the sum of all individual losses. None metrics List of metrics to be evaluated by the model during training and testing. Each of this can be a string (name of a built-in function), function or a tf.keras.metrics.Metric instance. See tf.keras.metrics . Typically you will use metrics=['accuracy'] . A function is any callable with the signature result = fn(y_true, y_pred) . To specify different metrics for different outputs of a multi-output model, you could also pass a dictionary, such as metrics={'output_a': 'accuracy', 'output_b': ['accuracy', 'mse']} . You can also pass a list (len = len(outputs)) of lists of metrics such as metrics=[['accuracy'], ['accuracy', 'mse']] or metrics=['accuracy', ['accuracy', 'mse']] . When you pass the strings 'accuracy' or 'acc', we convert this to one of tf.keras.metrics.BinaryAccuracy , tf.keras.metrics.CategoricalAccuracy , tf.keras.metrics.SparseCategoricalAccuracy based on the loss function used and the model output shape. We do a similar conversion for the strings 'crossentropy' and 'ce' as well. required loss_weights Optional list or dictionary specifying scalar coefficients (Python floats) to weight the loss contributions of different model outputs. The loss value that will be minimized by the model will then be the weighted sum of all individual losses, weighted by the loss_weights coefficients. If a list, it is expected to have a 1:1 mapping to the model's outputs. If a dict, it is expected to map output names (strings) to scalar coefficients. required weighted_metrics List of metrics to be evaluated and weighted by sample_weight or class_weight during training and testing. required run_eagerly Bool. Defaults to False . If True , this Model 's logic will not be wrapped in a tf.function . Recommended to leave this as None unless your Model cannot be run inside a tf.function . required steps_per_execution Int. Defaults to 1. The number of batches to run during each tf.function call. Running multiple batches inside a single tf.function call can greatly improve performance on TPUs or small models with a large Python overhead. At most, one full epoch will be run each execution. If a number larger than the size of the epoch is passed, the execution will be truncated to the size of the epoch. Note that if steps_per_execution is set to N , Callback.on_batch_begin and Callback.on_batch_end methods will only be called every N batches (i.e. before/after each tf.function execution). required **kwargs Arguments supported for backwards compatibility only. {} Exceptions: Type Description ValueError In case of invalid arguments for optimizer , loss or metrics .","title":"compile()"},{"location":"api/models/PoissonAutoencoder/#latent.models.ae.PoissonAutoencoder.fit","text":"Trains the model for a fixed number of epochs (iterations on a dataset). Parameters: Name Type Description Default x Input data. It could be: - A Numpy array (or array-like), or a list of arrays (in case the model has multiple inputs). - A TensorFlow tensor, or a list of tensors (in case the model has multiple inputs). - A dict mapping input names to the corresponding array/tensors, if the model has named inputs. - A tf.data dataset. Should return a tuple of either (inputs, targets) or (inputs, targets, sample_weights) . - A generator or keras.utils.Sequence returning (inputs, targets) or (inputs, targets, sample_weights) . A more detailed description of unpacking behavior for iterator types (Dataset, generator, Sequence) is given below. required y Target data. Like the input data x , it could be either Numpy array(s) or TensorFlow tensor(s). It should be consistent with x (you cannot have Numpy inputs and tensor targets, or inversely). If x is a dataset, generator, or keras.utils.Sequence instance, y should not be specified (since targets will be obtained from x ). None batch_size Integer or None . Number of samples per gradient update. If unspecified, batch_size will default to 32. Do not specify the batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required epochs Integer. Number of epochs to train the model. An epoch is an iteration over the entire x and y data provided. Note that in conjunction with initial_epoch , epochs is to be understood as \"final epoch\". The model is not trained for a number of iterations given by epochs , but merely until the epoch of index epochs is reached. required verbose 0, 1, or 2. Verbosity mode. 0 = silent, 1 = progress bar, 2 = one line per epoch. Note that the progress bar is not particularly useful when logged to a file, so verbose=2 is recommended when not running interactively (eg, in a production environment). required callbacks List of keras.callbacks.Callback instances. List of callbacks to apply during training. See tf.keras.callbacks . Note tf.keras.callbacks.ProgbarLogger and tf.keras.callbacks.History callbacks are created automatically and need not be passed into model.fit . tf.keras.callbacks.ProgbarLogger is created or not based on verbose argument to model.fit . required validation_split Float between 0 and 1. Fraction of the training data to be used as validation data. The model will set apart this fraction of the training data, will not train on it, and will evaluate the loss and any model metrics on this data at the end of each epoch. The validation data is selected from the last samples in the x and y data provided, before shuffling. This argument is not supported when x is a dataset, generator or keras.utils.Sequence instance. required validation_data Data on which to evaluate the loss and any model metrics at the end of each epoch. The model will not be trained on this data. Thus, note the fact that the validation loss of data provided using validation_split or validation_data is not affected by regularization layers like noise and dropout. validation_data will override validation_split . validation_data could be: - tuple (x_val, y_val) of Numpy arrays or tensors - tuple (x_val, y_val, val_sample_weights) of Numpy arrays - dataset For the first two cases, batch_size must be provided. For the last case, validation_steps could be provided. Note that validation_data does not support all the data types that are supported in x , eg, dict, generator or keras.utils.Sequence . required shuffle Boolean (whether to shuffle the training data before each epoch) or str (for 'batch'). This argument is ignored when x is a generator. 'batch' is a special option for dealing with the limitations of HDF5 data; it shuffles in batch-sized chunks. Has no effect when steps_per_epoch is not None . required class_weight Optional dictionary mapping class indices (integers) to a weight (float) value, used for weighting the loss function (during training only). This can be useful to tell the model to \"pay more attention\" to samples from an under-represented class. required sample_weight Optional Numpy array of weights for the training samples, used for weighting the loss function (during training only). You can either pass a flat (1D) Numpy array with the same length as the input samples (1:1 mapping between weights and samples), or in the case of temporal data, you can pass a 2D array with shape (samples, sequence_length) , to apply a different weight to every timestep of every sample. This argument is not supported when x is a dataset, generator, or keras.utils.Sequence instance, instead provide the sample_weights as the third element of x . required initial_epoch Integer. Epoch at which to start training (useful for resuming a previous training run). required steps_per_epoch Integer or None . Total number of steps (batches of samples) before declaring one epoch finished and starting the next epoch. When training with input tensors such as TensorFlow data tensors, the default None is equal to the number of samples in your dataset divided by the batch size, or 1 if that cannot be determined. If x is a tf.data dataset, and 'steps_per_epoch' is None, the epoch will run until the input dataset is exhausted. When passing an infinitely repeating dataset, you must specify the steps_per_epoch argument. This argument is not supported with array inputs. required validation_steps Only relevant if validation_data is provided and is a tf.data dataset. Total number of steps (batches of samples) to draw before stopping when performing validation at the end of every epoch. If 'validation_steps' is None, validation will run until the validation_data dataset is exhausted. In the case of an infinitely repeated dataset, it will run into an infinite loop. If 'validation_steps' is specified and only part of the dataset will be consumed, the evaluation will start from the beginning of the dataset at each epoch. This ensures that the same validation samples are used every time. required validation_batch_size Integer or None . Number of samples per validation batch. If unspecified, will default to batch_size . Do not specify the validation_batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required validation_freq Only relevant if validation data is provided. Integer or collections_abc.Container instance (e.g. list, tuple, etc.). If an integer, specifies how many training epochs to run before a new validation run is performed, e.g. validation_freq=2 runs validation every 2 epochs. If a Container, specifies the epochs on which to run validation, e.g. validation_freq=[1, 2, 10] runs validation at the end of the 1st, 2nd, and 10th epochs. required max_queue_size Integer. Used for generator or keras.utils.Sequence input only. Maximum size for the generator queue. If unspecified, max_queue_size will default to 10. required workers Integer. Used for generator or keras.utils.Sequence input only. Maximum number of processes to spin up when using process-based threading. If unspecified, workers will default to 1. If 0, will execute the generator on the main thread. required use_multiprocessing Boolean. Used for generator or keras.utils.Sequence input only. If True , use process-based threading. If unspecified, use_multiprocessing will default to False . Note that because this implementation relies on multiprocessing, you should not pass non-picklable arguments to the generator as they can't be passed easily to children processes. required Unpacking behavior for iterator-like inputs: A common pattern is to pass a tf.data.Dataset, generator, or tf.keras.utils.Sequence to the x argument of fit, which will in fact yield not only features (x) but optionally targets (y) and sample weights. Keras requires that the output of such iterator-likes be unambiguous. The iterator should return a tuple of length 1, 2, or 3, where the optional second and third elements will be used for y and sample_weight respectively. Any other type provided will be wrapped in a length one tuple, effectively treating everything as 'x'. When yielding dicts, they should still adhere to the top-level tuple structure. e.g. ({\"x0\": x0, \"x1\": x1}, y) . Keras will not attempt to separate features, targets, and weights from the keys of a single dict. A notable unsupported data type is the namedtuple. The reason is that it behaves like both an ordered datatype (tuple) and a mapping datatype (dict). So given a namedtuple of the form: namedtuple(\"example_tuple\", [\"y\", \"x\"]) it is ambiguous whether to reverse the order of the elements when interpreting the value. Even worse is a tuple of the form: namedtuple(\"other_tuple\", [\"x\", \"y\", \"z\"]) where it is unclear if the tuple was intended to be unpacked into x, y, and sample_weight or passed through as a single element to x . As a result the data processing code will simply raise a ValueError if it encounters a namedtuple. (Along with instructions to remedy the issue.) Returns: Type Description A History object. Its History.history attribute is a record of training loss values and metrics values at successive epochs, as well as validation loss values and validation metrics values (if applicable). Exceptions: Type Description RuntimeError If the model was never compiled or, ValueError In case of mismatch between the provided input data and what the model expects or when the input data is empty.","title":"fit()"},{"location":"api/models/PoissonAutoencoder/#latent.models.ae.PoissonAutoencoder.transform","text":"Map data (x) to latent space (z). Parameters: Name Type Description Default inputs A numpy array with input data. required Returns: Type Description A numpy array with the coordinates of the input data in latent space.","title":"transform()"},{"location":"api/models/PoissonVAE/","text":"PoissonVAE latent.models.vae.PoissonVAE Poisson Variational Autoencoder with fixed variational encoder and poisson decoder networks. __init__ ( self , name = 'poisson_vae' , x_dim = None , latent_dim = 50 , encoder_units = [ 128 , 128 ], decoder_units = [ 128 , 128 ], reconstruction_loss = None , use_conditions = False , kld_weight = 1e-05 , prior = 'normal' , latent_dist = 'independent' , iaf_units = [ 256 , 256 ], n_pseudoinputs = 200 , ** kwargs ) special Parameters: Name Type Description Default decoder Keras/tensorflow model object that inputs the latent space and outputs the reconstructed data. If not provided, a default model will be constructed from the arguments. required name str String indicating the name of the model. 'poisson_vae' x_dim int Integer indicating the number of features in the input data. None latent_dim int Integer indicating the number of dimensions in the latent space. 50 encoder_units Iterable[int] Integer list indicating the number of units of the encoder layers. Only used if encoder is not provided. [128, 128] decoder_units Iterable[int] An integer list indicating the number of units of the decoder layers. Only used if decoder is not provided. [128, 128] reconstruction_loss Callable Loss function applied to the reconstructed data and to be added by the decoder. Only used if decoder is not provided. Can also be added later by calling compile() . None use_conditions bool Boolean, whether to force the unpacking of conditions from the inputs. False kld_weight float Float indicating the weight of the KL Divergence regularization loss. 1e-05 prior Literal['normal', 'iaf', 'vamp'] The choice of prior distribution. One of the following: 'normal' - A unit gaussian (normal) distribution. 'iaf' - A unit gaussian with a Inverse Autoregressive Flows bijector ( Kingma 2016 ) 'vamp' - A variational mixture of posteriors (VAMP) prior ( Tomczak 2017 ) 'normal' latent_dist Literal['independent', 'multivariate'] The choice of latent distribution. One of the following: 'independent' - A independent normal produced by tfpl.IndependentNormal . 'multivariate' - A multivariate normal produced by tfpl.MultivariateNormalTriL . 'independent' iaf_units Iterable[int] Integer list indicating the units in the IAF bijector network. Only used if prior = 'iaf' . [256, 256] n_pseudoinputs int Integer indicating the number of pseudoinputs for the VAMP prior. Only used if prior = 'vamp' . 200 **kwargs Other arguments passed on to DenseStack for constructung encoder/ decoder networks. {} call ( self , inputs ) inherited Full forward pass through model compile ( self , optimizer = 'adam' , loss = None , ** kwargs ) inherited Configures the model for training. Parameters: Name Type Description Default optimizer String (name of optimizer) or optimizer instance. See tf.keras.optimizers . 'adam' loss String (name of objective function), objective function or tf.keras.losses.Loss instance. See tf.keras.losses . An objective function is any callable with the signature loss = fn(y_true, y_pred) , where y_true = ground truth values with shape = [batch_size, d0, .. dN] , except sparse loss functions such as sparse categorical crossentropy where shape = [batch_size, d0, .. dN-1] . y_pred = predicted values with shape = [batch_size, d0, .. dN] . It returns a weighted loss float tensor. If a custom Loss instance is used and reduction is set to NONE, return value has the shape [batch_size, d0, .. dN-1] ie. per-sample or per-timestep loss values; otherwise, it is a scalar. If the model has multiple outputs, you can use a different loss on each output by passing a dictionary or a list of losses. The loss value that will be minimized by the model will then be the sum of all individual losses. None metrics List of metrics to be evaluated by the model during training and testing. Each of this can be a string (name of a built-in function), function or a tf.keras.metrics.Metric instance. See tf.keras.metrics . Typically you will use metrics=['accuracy'] . A function is any callable with the signature result = fn(y_true, y_pred) . To specify different metrics for different outputs of a multi-output model, you could also pass a dictionary, such as metrics={'output_a': 'accuracy', 'output_b': ['accuracy', 'mse']} . You can also pass a list (len = len(outputs)) of lists of metrics such as metrics=[['accuracy'], ['accuracy', 'mse']] or metrics=['accuracy', ['accuracy', 'mse']] . When you pass the strings 'accuracy' or 'acc', we convert this to one of tf.keras.metrics.BinaryAccuracy , tf.keras.metrics.CategoricalAccuracy , tf.keras.metrics.SparseCategoricalAccuracy based on the loss function used and the model output shape. We do a similar conversion for the strings 'crossentropy' and 'ce' as well. required loss_weights Optional list or dictionary specifying scalar coefficients (Python floats) to weight the loss contributions of different model outputs. The loss value that will be minimized by the model will then be the weighted sum of all individual losses, weighted by the loss_weights coefficients. If a list, it is expected to have a 1:1 mapping to the model's outputs. If a dict, it is expected to map output names (strings) to scalar coefficients. required weighted_metrics List of metrics to be evaluated and weighted by sample_weight or class_weight during training and testing. required run_eagerly Bool. Defaults to False . If True , this Model 's logic will not be wrapped in a tf.function . Recommended to leave this as None unless your Model cannot be run inside a tf.function . required steps_per_execution Int. Defaults to 1. The number of batches to run during each tf.function call. Running multiple batches inside a single tf.function call can greatly improve performance on TPUs or small models with a large Python overhead. At most, one full epoch will be run each execution. If a number larger than the size of the epoch is passed, the execution will be truncated to the size of the epoch. Note that if steps_per_execution is set to N , Callback.on_batch_begin and Callback.on_batch_end methods will only be called every N batches (i.e. before/after each tf.function execution). required **kwargs Arguments supported for backwards compatibility only. {} Exceptions: Type Description ValueError In case of invalid arguments for optimizer , loss or metrics . fit ( self , x , y = None , ** kwargs ) inherited Trains the model for a fixed number of epochs (iterations on a dataset). Parameters: Name Type Description Default x Input data. It could be: - A Numpy array (or array-like), or a list of arrays (in case the model has multiple inputs). - A TensorFlow tensor, or a list of tensors (in case the model has multiple inputs). - A dict mapping input names to the corresponding array/tensors, if the model has named inputs. - A tf.data dataset. Should return a tuple of either (inputs, targets) or (inputs, targets, sample_weights) . - A generator or keras.utils.Sequence returning (inputs, targets) or (inputs, targets, sample_weights) . A more detailed description of unpacking behavior for iterator types (Dataset, generator, Sequence) is given below. required y Target data. Like the input data x , it could be either Numpy array(s) or TensorFlow tensor(s). It should be consistent with x (you cannot have Numpy inputs and tensor targets, or inversely). If x is a dataset, generator, or keras.utils.Sequence instance, y should not be specified (since targets will be obtained from x ). None batch_size Integer or None . Number of samples per gradient update. If unspecified, batch_size will default to 32. Do not specify the batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required epochs Integer. Number of epochs to train the model. An epoch is an iteration over the entire x and y data provided. Note that in conjunction with initial_epoch , epochs is to be understood as \"final epoch\". The model is not trained for a number of iterations given by epochs , but merely until the epoch of index epochs is reached. required verbose 0, 1, or 2. Verbosity mode. 0 = silent, 1 = progress bar, 2 = one line per epoch. Note that the progress bar is not particularly useful when logged to a file, so verbose=2 is recommended when not running interactively (eg, in a production environment). required callbacks List of keras.callbacks.Callback instances. List of callbacks to apply during training. See tf.keras.callbacks . Note tf.keras.callbacks.ProgbarLogger and tf.keras.callbacks.History callbacks are created automatically and need not be passed into model.fit . tf.keras.callbacks.ProgbarLogger is created or not based on verbose argument to model.fit . required validation_split Float between 0 and 1. Fraction of the training data to be used as validation data. The model will set apart this fraction of the training data, will not train on it, and will evaluate the loss and any model metrics on this data at the end of each epoch. The validation data is selected from the last samples in the x and y data provided, before shuffling. This argument is not supported when x is a dataset, generator or keras.utils.Sequence instance. required validation_data Data on which to evaluate the loss and any model metrics at the end of each epoch. The model will not be trained on this data. Thus, note the fact that the validation loss of data provided using validation_split or validation_data is not affected by regularization layers like noise and dropout. validation_data will override validation_split . validation_data could be: - tuple (x_val, y_val) of Numpy arrays or tensors - tuple (x_val, y_val, val_sample_weights) of Numpy arrays - dataset For the first two cases, batch_size must be provided. For the last case, validation_steps could be provided. Note that validation_data does not support all the data types that are supported in x , eg, dict, generator or keras.utils.Sequence . required shuffle Boolean (whether to shuffle the training data before each epoch) or str (for 'batch'). This argument is ignored when x is a generator. 'batch' is a special option for dealing with the limitations of HDF5 data; it shuffles in batch-sized chunks. Has no effect when steps_per_epoch is not None . required class_weight Optional dictionary mapping class indices (integers) to a weight (float) value, used for weighting the loss function (during training only). This can be useful to tell the model to \"pay more attention\" to samples from an under-represented class. required sample_weight Optional Numpy array of weights for the training samples, used for weighting the loss function (during training only). You can either pass a flat (1D) Numpy array with the same length as the input samples (1:1 mapping between weights and samples), or in the case of temporal data, you can pass a 2D array with shape (samples, sequence_length) , to apply a different weight to every timestep of every sample. This argument is not supported when x is a dataset, generator, or keras.utils.Sequence instance, instead provide the sample_weights as the third element of x . required initial_epoch Integer. Epoch at which to start training (useful for resuming a previous training run). required steps_per_epoch Integer or None . Total number of steps (batches of samples) before declaring one epoch finished and starting the next epoch. When training with input tensors such as TensorFlow data tensors, the default None is equal to the number of samples in your dataset divided by the batch size, or 1 if that cannot be determined. If x is a tf.data dataset, and 'steps_per_epoch' is None, the epoch will run until the input dataset is exhausted. When passing an infinitely repeating dataset, you must specify the steps_per_epoch argument. This argument is not supported with array inputs. required validation_steps Only relevant if validation_data is provided and is a tf.data dataset. Total number of steps (batches of samples) to draw before stopping when performing validation at the end of every epoch. If 'validation_steps' is None, validation will run until the validation_data dataset is exhausted. In the case of an infinitely repeated dataset, it will run into an infinite loop. If 'validation_steps' is specified and only part of the dataset will be consumed, the evaluation will start from the beginning of the dataset at each epoch. This ensures that the same validation samples are used every time. required validation_batch_size Integer or None . Number of samples per validation batch. If unspecified, will default to batch_size . Do not specify the validation_batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required validation_freq Only relevant if validation data is provided. Integer or collections_abc.Container instance (e.g. list, tuple, etc.). If an integer, specifies how many training epochs to run before a new validation run is performed, e.g. validation_freq=2 runs validation every 2 epochs. If a Container, specifies the epochs on which to run validation, e.g. validation_freq=[1, 2, 10] runs validation at the end of the 1st, 2nd, and 10th epochs. required max_queue_size Integer. Used for generator or keras.utils.Sequence input only. Maximum size for the generator queue. If unspecified, max_queue_size will default to 10. required workers Integer. Used for generator or keras.utils.Sequence input only. Maximum number of processes to spin up when using process-based threading. If unspecified, workers will default to 1. If 0, will execute the generator on the main thread. required use_multiprocessing Boolean. Used for generator or keras.utils.Sequence input only. If True , use process-based threading. If unspecified, use_multiprocessing will default to False . Note that because this implementation relies on multiprocessing, you should not pass non-picklable arguments to the generator as they can't be passed easily to children processes. required Unpacking behavior for iterator-like inputs: A common pattern is to pass a tf.data.Dataset, generator, or tf.keras.utils.Sequence to the x argument of fit, which will in fact yield not only features (x) but optionally targets (y) and sample weights. Keras requires that the output of such iterator-likes be unambiguous. The iterator should return a tuple of length 1, 2, or 3, where the optional second and third elements will be used for y and sample_weight respectively. Any other type provided will be wrapped in a length one tuple, effectively treating everything as 'x'. When yielding dicts, they should still adhere to the top-level tuple structure. e.g. ({\"x0\": x0, \"x1\": x1}, y) . Keras will not attempt to separate features, targets, and weights from the keys of a single dict. A notable unsupported data type is the namedtuple. The reason is that it behaves like both an ordered datatype (tuple) and a mapping datatype (dict). So given a namedtuple of the form: namedtuple(\"example_tuple\", [\"y\", \"x\"]) it is ambiguous whether to reverse the order of the elements when interpreting the value. Even worse is a tuple of the form: namedtuple(\"other_tuple\", [\"x\", \"y\", \"z\"]) where it is unclear if the tuple was intended to be unpacked into x, y, and sample_weight or passed through as a single element to x . As a result the data processing code will simply raise a ValueError if it encounters a namedtuple. (Along with instructions to remedy the issue.) Returns: Type Description A History object. Its History.history attribute is a record of training loss values and metrics values at successive epochs, as well as validation loss values and validation metrics values (if applicable). Exceptions: Type Description RuntimeError If the model was never compiled or, ValueError In case of mismatch between the provided input data and what the model expects or when the input data is empty. transform ( self , inputs ) inherited Map data (x) to latent space (z). Parameters: Name Type Description Default inputs A numpy array with input data. required Returns: Type Description A numpy array with the coordinates of the input data in latent space.","title":"PoissonVAE"},{"location":"api/models/PoissonVAE/#poissonvae","text":"","title":"PoissonVAE"},{"location":"api/models/PoissonVAE/#latent.models.vae.PoissonVAE","text":"Poisson Variational Autoencoder with fixed variational encoder and poisson decoder networks.","title":"PoissonVAE"},{"location":"api/models/PoissonVAE/#latent.models.vae.PoissonVAE.__init__","text":"Parameters: Name Type Description Default decoder Keras/tensorflow model object that inputs the latent space and outputs the reconstructed data. If not provided, a default model will be constructed from the arguments. required name str String indicating the name of the model. 'poisson_vae' x_dim int Integer indicating the number of features in the input data. None latent_dim int Integer indicating the number of dimensions in the latent space. 50 encoder_units Iterable[int] Integer list indicating the number of units of the encoder layers. Only used if encoder is not provided. [128, 128] decoder_units Iterable[int] An integer list indicating the number of units of the decoder layers. Only used if decoder is not provided. [128, 128] reconstruction_loss Callable Loss function applied to the reconstructed data and to be added by the decoder. Only used if decoder is not provided. Can also be added later by calling compile() . None use_conditions bool Boolean, whether to force the unpacking of conditions from the inputs. False kld_weight float Float indicating the weight of the KL Divergence regularization loss. 1e-05 prior Literal['normal', 'iaf', 'vamp'] The choice of prior distribution. One of the following: 'normal' - A unit gaussian (normal) distribution. 'iaf' - A unit gaussian with a Inverse Autoregressive Flows bijector ( Kingma 2016 ) 'vamp' - A variational mixture of posteriors (VAMP) prior ( Tomczak 2017 ) 'normal' latent_dist Literal['independent', 'multivariate'] The choice of latent distribution. One of the following: 'independent' - A independent normal produced by tfpl.IndependentNormal . 'multivariate' - A multivariate normal produced by tfpl.MultivariateNormalTriL . 'independent' iaf_units Iterable[int] Integer list indicating the units in the IAF bijector network. Only used if prior = 'iaf' . [256, 256] n_pseudoinputs int Integer indicating the number of pseudoinputs for the VAMP prior. Only used if prior = 'vamp' . 200 **kwargs Other arguments passed on to DenseStack for constructung encoder/ decoder networks. {}","title":"__init__()"},{"location":"api/models/PoissonVAE/#latent.models.vae.PoissonVAE.call","text":"Full forward pass through model","title":"call()"},{"location":"api/models/PoissonVAE/#latent.models.vae.PoissonVAE.compile","text":"Configures the model for training. Parameters: Name Type Description Default optimizer String (name of optimizer) or optimizer instance. See tf.keras.optimizers . 'adam' loss String (name of objective function), objective function or tf.keras.losses.Loss instance. See tf.keras.losses . An objective function is any callable with the signature loss = fn(y_true, y_pred) , where y_true = ground truth values with shape = [batch_size, d0, .. dN] , except sparse loss functions such as sparse categorical crossentropy where shape = [batch_size, d0, .. dN-1] . y_pred = predicted values with shape = [batch_size, d0, .. dN] . It returns a weighted loss float tensor. If a custom Loss instance is used and reduction is set to NONE, return value has the shape [batch_size, d0, .. dN-1] ie. per-sample or per-timestep loss values; otherwise, it is a scalar. If the model has multiple outputs, you can use a different loss on each output by passing a dictionary or a list of losses. The loss value that will be minimized by the model will then be the sum of all individual losses. None metrics List of metrics to be evaluated by the model during training and testing. Each of this can be a string (name of a built-in function), function or a tf.keras.metrics.Metric instance. See tf.keras.metrics . Typically you will use metrics=['accuracy'] . A function is any callable with the signature result = fn(y_true, y_pred) . To specify different metrics for different outputs of a multi-output model, you could also pass a dictionary, such as metrics={'output_a': 'accuracy', 'output_b': ['accuracy', 'mse']} . You can also pass a list (len = len(outputs)) of lists of metrics such as metrics=[['accuracy'], ['accuracy', 'mse']] or metrics=['accuracy', ['accuracy', 'mse']] . When you pass the strings 'accuracy' or 'acc', we convert this to one of tf.keras.metrics.BinaryAccuracy , tf.keras.metrics.CategoricalAccuracy , tf.keras.metrics.SparseCategoricalAccuracy based on the loss function used and the model output shape. We do a similar conversion for the strings 'crossentropy' and 'ce' as well. required loss_weights Optional list or dictionary specifying scalar coefficients (Python floats) to weight the loss contributions of different model outputs. The loss value that will be minimized by the model will then be the weighted sum of all individual losses, weighted by the loss_weights coefficients. If a list, it is expected to have a 1:1 mapping to the model's outputs. If a dict, it is expected to map output names (strings) to scalar coefficients. required weighted_metrics List of metrics to be evaluated and weighted by sample_weight or class_weight during training and testing. required run_eagerly Bool. Defaults to False . If True , this Model 's logic will not be wrapped in a tf.function . Recommended to leave this as None unless your Model cannot be run inside a tf.function . required steps_per_execution Int. Defaults to 1. The number of batches to run during each tf.function call. Running multiple batches inside a single tf.function call can greatly improve performance on TPUs or small models with a large Python overhead. At most, one full epoch will be run each execution. If a number larger than the size of the epoch is passed, the execution will be truncated to the size of the epoch. Note that if steps_per_execution is set to N , Callback.on_batch_begin and Callback.on_batch_end methods will only be called every N batches (i.e. before/after each tf.function execution). required **kwargs Arguments supported for backwards compatibility only. {} Exceptions: Type Description ValueError In case of invalid arguments for optimizer , loss or metrics .","title":"compile()"},{"location":"api/models/PoissonVAE/#latent.models.vae.PoissonVAE.fit","text":"Trains the model for a fixed number of epochs (iterations on a dataset). Parameters: Name Type Description Default x Input data. It could be: - A Numpy array (or array-like), or a list of arrays (in case the model has multiple inputs). - A TensorFlow tensor, or a list of tensors (in case the model has multiple inputs). - A dict mapping input names to the corresponding array/tensors, if the model has named inputs. - A tf.data dataset. Should return a tuple of either (inputs, targets) or (inputs, targets, sample_weights) . - A generator or keras.utils.Sequence returning (inputs, targets) or (inputs, targets, sample_weights) . A more detailed description of unpacking behavior for iterator types (Dataset, generator, Sequence) is given below. required y Target data. Like the input data x , it could be either Numpy array(s) or TensorFlow tensor(s). It should be consistent with x (you cannot have Numpy inputs and tensor targets, or inversely). If x is a dataset, generator, or keras.utils.Sequence instance, y should not be specified (since targets will be obtained from x ). None batch_size Integer or None . Number of samples per gradient update. If unspecified, batch_size will default to 32. Do not specify the batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required epochs Integer. Number of epochs to train the model. An epoch is an iteration over the entire x and y data provided. Note that in conjunction with initial_epoch , epochs is to be understood as \"final epoch\". The model is not trained for a number of iterations given by epochs , but merely until the epoch of index epochs is reached. required verbose 0, 1, or 2. Verbosity mode. 0 = silent, 1 = progress bar, 2 = one line per epoch. Note that the progress bar is not particularly useful when logged to a file, so verbose=2 is recommended when not running interactively (eg, in a production environment). required callbacks List of keras.callbacks.Callback instances. List of callbacks to apply during training. See tf.keras.callbacks . Note tf.keras.callbacks.ProgbarLogger and tf.keras.callbacks.History callbacks are created automatically and need not be passed into model.fit . tf.keras.callbacks.ProgbarLogger is created or not based on verbose argument to model.fit . required validation_split Float between 0 and 1. Fraction of the training data to be used as validation data. The model will set apart this fraction of the training data, will not train on it, and will evaluate the loss and any model metrics on this data at the end of each epoch. The validation data is selected from the last samples in the x and y data provided, before shuffling. This argument is not supported when x is a dataset, generator or keras.utils.Sequence instance. required validation_data Data on which to evaluate the loss and any model metrics at the end of each epoch. The model will not be trained on this data. Thus, note the fact that the validation loss of data provided using validation_split or validation_data is not affected by regularization layers like noise and dropout. validation_data will override validation_split . validation_data could be: - tuple (x_val, y_val) of Numpy arrays or tensors - tuple (x_val, y_val, val_sample_weights) of Numpy arrays - dataset For the first two cases, batch_size must be provided. For the last case, validation_steps could be provided. Note that validation_data does not support all the data types that are supported in x , eg, dict, generator or keras.utils.Sequence . required shuffle Boolean (whether to shuffle the training data before each epoch) or str (for 'batch'). This argument is ignored when x is a generator. 'batch' is a special option for dealing with the limitations of HDF5 data; it shuffles in batch-sized chunks. Has no effect when steps_per_epoch is not None . required class_weight Optional dictionary mapping class indices (integers) to a weight (float) value, used for weighting the loss function (during training only). This can be useful to tell the model to \"pay more attention\" to samples from an under-represented class. required sample_weight Optional Numpy array of weights for the training samples, used for weighting the loss function (during training only). You can either pass a flat (1D) Numpy array with the same length as the input samples (1:1 mapping between weights and samples), or in the case of temporal data, you can pass a 2D array with shape (samples, sequence_length) , to apply a different weight to every timestep of every sample. This argument is not supported when x is a dataset, generator, or keras.utils.Sequence instance, instead provide the sample_weights as the third element of x . required initial_epoch Integer. Epoch at which to start training (useful for resuming a previous training run). required steps_per_epoch Integer or None . Total number of steps (batches of samples) before declaring one epoch finished and starting the next epoch. When training with input tensors such as TensorFlow data tensors, the default None is equal to the number of samples in your dataset divided by the batch size, or 1 if that cannot be determined. If x is a tf.data dataset, and 'steps_per_epoch' is None, the epoch will run until the input dataset is exhausted. When passing an infinitely repeating dataset, you must specify the steps_per_epoch argument. This argument is not supported with array inputs. required validation_steps Only relevant if validation_data is provided and is a tf.data dataset. Total number of steps (batches of samples) to draw before stopping when performing validation at the end of every epoch. If 'validation_steps' is None, validation will run until the validation_data dataset is exhausted. In the case of an infinitely repeated dataset, it will run into an infinite loop. If 'validation_steps' is specified and only part of the dataset will be consumed, the evaluation will start from the beginning of the dataset at each epoch. This ensures that the same validation samples are used every time. required validation_batch_size Integer or None . Number of samples per validation batch. If unspecified, will default to batch_size . Do not specify the validation_batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required validation_freq Only relevant if validation data is provided. Integer or collections_abc.Container instance (e.g. list, tuple, etc.). If an integer, specifies how many training epochs to run before a new validation run is performed, e.g. validation_freq=2 runs validation every 2 epochs. If a Container, specifies the epochs on which to run validation, e.g. validation_freq=[1, 2, 10] runs validation at the end of the 1st, 2nd, and 10th epochs. required max_queue_size Integer. Used for generator or keras.utils.Sequence input only. Maximum size for the generator queue. If unspecified, max_queue_size will default to 10. required workers Integer. Used for generator or keras.utils.Sequence input only. Maximum number of processes to spin up when using process-based threading. If unspecified, workers will default to 1. If 0, will execute the generator on the main thread. required use_multiprocessing Boolean. Used for generator or keras.utils.Sequence input only. If True , use process-based threading. If unspecified, use_multiprocessing will default to False . Note that because this implementation relies on multiprocessing, you should not pass non-picklable arguments to the generator as they can't be passed easily to children processes. required Unpacking behavior for iterator-like inputs: A common pattern is to pass a tf.data.Dataset, generator, or tf.keras.utils.Sequence to the x argument of fit, which will in fact yield not only features (x) but optionally targets (y) and sample weights. Keras requires that the output of such iterator-likes be unambiguous. The iterator should return a tuple of length 1, 2, or 3, where the optional second and third elements will be used for y and sample_weight respectively. Any other type provided will be wrapped in a length one tuple, effectively treating everything as 'x'. When yielding dicts, they should still adhere to the top-level tuple structure. e.g. ({\"x0\": x0, \"x1\": x1}, y) . Keras will not attempt to separate features, targets, and weights from the keys of a single dict. A notable unsupported data type is the namedtuple. The reason is that it behaves like both an ordered datatype (tuple) and a mapping datatype (dict). So given a namedtuple of the form: namedtuple(\"example_tuple\", [\"y\", \"x\"]) it is ambiguous whether to reverse the order of the elements when interpreting the value. Even worse is a tuple of the form: namedtuple(\"other_tuple\", [\"x\", \"y\", \"z\"]) where it is unclear if the tuple was intended to be unpacked into x, y, and sample_weight or passed through as a single element to x . As a result the data processing code will simply raise a ValueError if it encounters a namedtuple. (Along with instructions to remedy the issue.) Returns: Type Description A History object. Its History.history attribute is a record of training loss values and metrics values at successive epochs, as well as validation loss values and validation metrics values (if applicable). Exceptions: Type Description RuntimeError If the model was never compiled or, ValueError In case of mismatch between the provided input data and what the model expects or when the input data is empty.","title":"fit()"},{"location":"api/models/PoissonVAE/#latent.models.vae.PoissonVAE.transform","text":"Map data (x) to latent space (z). Parameters: Name Type Description Default inputs A numpy array with input data. required Returns: Type Description A numpy array with the coordinates of the input data in latent space.","title":"transform()"},{"location":"api/models/TopologicalAutoencoder/","text":"TopologicalAutoencoder latent.models.ae.TopologicalAutoencoder Autoencoder with fixed encoder adding topological loss on latent space ( Moor 2019 ). __init__ ( self , decoder = None , name = 'topological_autoencoder' , x_dim = None , latent_dim = 50 , encoder_units = [ 128 , 128 ], decoder_units = [ 128 , 128 ], use_conditions = False , topo_weight = 1.0 , ** kwargs ) special Parameters: Name Type Description Default decoder Model Keras/tensorflow model object that inputs the data and outputs the latent space. If not provided, a default model will be constructed from the arguments. None name str String indicating the name of the model. 'topological_autoencoder' x_dim int Integer indicating the number of features in the input data. None latent_dim int Integer indicating the number of dimensions in the latent space. 50 encoder_units Iterable[int] Integer list indicating the number of units of the encoder layers. Only used if encoder is not provided. [128, 128] decoder_units Iterable[int] An integer list indicating the number of units of the decoder layers. Only used if decoder is not provided. [128, 128] use_conditions bool Boolean, whether to force the unpacking of conditions from the inputs. False topo_weight float Float indicating the weight of the topological loss. 1.0 **kwargs Other arguments passed on to DenseStack for constructung encoder/decoder networks. {} call ( self , inputs ) inherited Full forward pass through model compile ( self , optimizer = 'adam' , loss = None , ** kwargs ) inherited Configures the model for training. Parameters: Name Type Description Default optimizer String (name of optimizer) or optimizer instance. See tf.keras.optimizers . 'adam' loss String (name of objective function), objective function or tf.keras.losses.Loss instance. See tf.keras.losses . An objective function is any callable with the signature loss = fn(y_true, y_pred) , where y_true = ground truth values with shape = [batch_size, d0, .. dN] , except sparse loss functions such as sparse categorical crossentropy where shape = [batch_size, d0, .. dN-1] . y_pred = predicted values with shape = [batch_size, d0, .. dN] . It returns a weighted loss float tensor. If a custom Loss instance is used and reduction is set to NONE, return value has the shape [batch_size, d0, .. dN-1] ie. per-sample or per-timestep loss values; otherwise, it is a scalar. If the model has multiple outputs, you can use a different loss on each output by passing a dictionary or a list of losses. The loss value that will be minimized by the model will then be the sum of all individual losses. None metrics List of metrics to be evaluated by the model during training and testing. Each of this can be a string (name of a built-in function), function or a tf.keras.metrics.Metric instance. See tf.keras.metrics . Typically you will use metrics=['accuracy'] . A function is any callable with the signature result = fn(y_true, y_pred) . To specify different metrics for different outputs of a multi-output model, you could also pass a dictionary, such as metrics={'output_a': 'accuracy', 'output_b': ['accuracy', 'mse']} . You can also pass a list (len = len(outputs)) of lists of metrics such as metrics=[['accuracy'], ['accuracy', 'mse']] or metrics=['accuracy', ['accuracy', 'mse']] . When you pass the strings 'accuracy' or 'acc', we convert this to one of tf.keras.metrics.BinaryAccuracy , tf.keras.metrics.CategoricalAccuracy , tf.keras.metrics.SparseCategoricalAccuracy based on the loss function used and the model output shape. We do a similar conversion for the strings 'crossentropy' and 'ce' as well. required loss_weights Optional list or dictionary specifying scalar coefficients (Python floats) to weight the loss contributions of different model outputs. The loss value that will be minimized by the model will then be the weighted sum of all individual losses, weighted by the loss_weights coefficients. If a list, it is expected to have a 1:1 mapping to the model's outputs. If a dict, it is expected to map output names (strings) to scalar coefficients. required weighted_metrics List of metrics to be evaluated and weighted by sample_weight or class_weight during training and testing. required run_eagerly Bool. Defaults to False . If True , this Model 's logic will not be wrapped in a tf.function . Recommended to leave this as None unless your Model cannot be run inside a tf.function . required steps_per_execution Int. Defaults to 1. The number of batches to run during each tf.function call. Running multiple batches inside a single tf.function call can greatly improve performance on TPUs or small models with a large Python overhead. At most, one full epoch will be run each execution. If a number larger than the size of the epoch is passed, the execution will be truncated to the size of the epoch. Note that if steps_per_execution is set to N , Callback.on_batch_begin and Callback.on_batch_end methods will only be called every N batches (i.e. before/after each tf.function execution). required **kwargs Arguments supported for backwards compatibility only. {} Exceptions: Type Description ValueError In case of invalid arguments for optimizer , loss or metrics . fit ( self , x , y = None , ** kwargs ) inherited Trains the model for a fixed number of epochs (iterations on a dataset). Parameters: Name Type Description Default x Input data. It could be: - A Numpy array (or array-like), or a list of arrays (in case the model has multiple inputs). - A TensorFlow tensor, or a list of tensors (in case the model has multiple inputs). - A dict mapping input names to the corresponding array/tensors, if the model has named inputs. - A tf.data dataset. Should return a tuple of either (inputs, targets) or (inputs, targets, sample_weights) . - A generator or keras.utils.Sequence returning (inputs, targets) or (inputs, targets, sample_weights) . A more detailed description of unpacking behavior for iterator types (Dataset, generator, Sequence) is given below. required y Target data. Like the input data x , it could be either Numpy array(s) or TensorFlow tensor(s). It should be consistent with x (you cannot have Numpy inputs and tensor targets, or inversely). If x is a dataset, generator, or keras.utils.Sequence instance, y should not be specified (since targets will be obtained from x ). None batch_size Integer or None . Number of samples per gradient update. If unspecified, batch_size will default to 32. Do not specify the batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required epochs Integer. Number of epochs to train the model. An epoch is an iteration over the entire x and y data provided. Note that in conjunction with initial_epoch , epochs is to be understood as \"final epoch\". The model is not trained for a number of iterations given by epochs , but merely until the epoch of index epochs is reached. required verbose 0, 1, or 2. Verbosity mode. 0 = silent, 1 = progress bar, 2 = one line per epoch. Note that the progress bar is not particularly useful when logged to a file, so verbose=2 is recommended when not running interactively (eg, in a production environment). required callbacks List of keras.callbacks.Callback instances. List of callbacks to apply during training. See tf.keras.callbacks . Note tf.keras.callbacks.ProgbarLogger and tf.keras.callbacks.History callbacks are created automatically and need not be passed into model.fit . tf.keras.callbacks.ProgbarLogger is created or not based on verbose argument to model.fit . required validation_split Float between 0 and 1. Fraction of the training data to be used as validation data. The model will set apart this fraction of the training data, will not train on it, and will evaluate the loss and any model metrics on this data at the end of each epoch. The validation data is selected from the last samples in the x and y data provided, before shuffling. This argument is not supported when x is a dataset, generator or keras.utils.Sequence instance. required validation_data Data on which to evaluate the loss and any model metrics at the end of each epoch. The model will not be trained on this data. Thus, note the fact that the validation loss of data provided using validation_split or validation_data is not affected by regularization layers like noise and dropout. validation_data will override validation_split . validation_data could be: - tuple (x_val, y_val) of Numpy arrays or tensors - tuple (x_val, y_val, val_sample_weights) of Numpy arrays - dataset For the first two cases, batch_size must be provided. For the last case, validation_steps could be provided. Note that validation_data does not support all the data types that are supported in x , eg, dict, generator or keras.utils.Sequence . required shuffle Boolean (whether to shuffle the training data before each epoch) or str (for 'batch'). This argument is ignored when x is a generator. 'batch' is a special option for dealing with the limitations of HDF5 data; it shuffles in batch-sized chunks. Has no effect when steps_per_epoch is not None . required class_weight Optional dictionary mapping class indices (integers) to a weight (float) value, used for weighting the loss function (during training only). This can be useful to tell the model to \"pay more attention\" to samples from an under-represented class. required sample_weight Optional Numpy array of weights for the training samples, used for weighting the loss function (during training only). You can either pass a flat (1D) Numpy array with the same length as the input samples (1:1 mapping between weights and samples), or in the case of temporal data, you can pass a 2D array with shape (samples, sequence_length) , to apply a different weight to every timestep of every sample. This argument is not supported when x is a dataset, generator, or keras.utils.Sequence instance, instead provide the sample_weights as the third element of x . required initial_epoch Integer. Epoch at which to start training (useful for resuming a previous training run). required steps_per_epoch Integer or None . Total number of steps (batches of samples) before declaring one epoch finished and starting the next epoch. When training with input tensors such as TensorFlow data tensors, the default None is equal to the number of samples in your dataset divided by the batch size, or 1 if that cannot be determined. If x is a tf.data dataset, and 'steps_per_epoch' is None, the epoch will run until the input dataset is exhausted. When passing an infinitely repeating dataset, you must specify the steps_per_epoch argument. This argument is not supported with array inputs. required validation_steps Only relevant if validation_data is provided and is a tf.data dataset. Total number of steps (batches of samples) to draw before stopping when performing validation at the end of every epoch. If 'validation_steps' is None, validation will run until the validation_data dataset is exhausted. In the case of an infinitely repeated dataset, it will run into an infinite loop. If 'validation_steps' is specified and only part of the dataset will be consumed, the evaluation will start from the beginning of the dataset at each epoch. This ensures that the same validation samples are used every time. required validation_batch_size Integer or None . Number of samples per validation batch. If unspecified, will default to batch_size . Do not specify the validation_batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required validation_freq Only relevant if validation data is provided. Integer or collections_abc.Container instance (e.g. list, tuple, etc.). If an integer, specifies how many training epochs to run before a new validation run is performed, e.g. validation_freq=2 runs validation every 2 epochs. If a Container, specifies the epochs on which to run validation, e.g. validation_freq=[1, 2, 10] runs validation at the end of the 1st, 2nd, and 10th epochs. required max_queue_size Integer. Used for generator or keras.utils.Sequence input only. Maximum size for the generator queue. If unspecified, max_queue_size will default to 10. required workers Integer. Used for generator or keras.utils.Sequence input only. Maximum number of processes to spin up when using process-based threading. If unspecified, workers will default to 1. If 0, will execute the generator on the main thread. required use_multiprocessing Boolean. Used for generator or keras.utils.Sequence input only. If True , use process-based threading. If unspecified, use_multiprocessing will default to False . Note that because this implementation relies on multiprocessing, you should not pass non-picklable arguments to the generator as they can't be passed easily to children processes. required Unpacking behavior for iterator-like inputs: A common pattern is to pass a tf.data.Dataset, generator, or tf.keras.utils.Sequence to the x argument of fit, which will in fact yield not only features (x) but optionally targets (y) and sample weights. Keras requires that the output of such iterator-likes be unambiguous. The iterator should return a tuple of length 1, 2, or 3, where the optional second and third elements will be used for y and sample_weight respectively. Any other type provided will be wrapped in a length one tuple, effectively treating everything as 'x'. When yielding dicts, they should still adhere to the top-level tuple structure. e.g. ({\"x0\": x0, \"x1\": x1}, y) . Keras will not attempt to separate features, targets, and weights from the keys of a single dict. A notable unsupported data type is the namedtuple. The reason is that it behaves like both an ordered datatype (tuple) and a mapping datatype (dict). So given a namedtuple of the form: namedtuple(\"example_tuple\", [\"y\", \"x\"]) it is ambiguous whether to reverse the order of the elements when interpreting the value. Even worse is a tuple of the form: namedtuple(\"other_tuple\", [\"x\", \"y\", \"z\"]) where it is unclear if the tuple was intended to be unpacked into x, y, and sample_weight or passed through as a single element to x . As a result the data processing code will simply raise a ValueError if it encounters a namedtuple. (Along with instructions to remedy the issue.) Returns: Type Description A History object. Its History.history attribute is a record of training loss values and metrics values at successive epochs, as well as validation loss values and validation metrics values (if applicable). Exceptions: Type Description RuntimeError If the model was never compiled or, ValueError In case of mismatch between the provided input data and what the model expects or when the input data is empty. transform ( self , inputs ) inherited Map data (x) to latent space (z). Parameters: Name Type Description Default inputs A numpy array with input data. required Returns: Type Description A numpy array with the coordinates of the input data in latent space.","title":"TopologicalAutoencoder"},{"location":"api/models/TopologicalAutoencoder/#topologicalautoencoder","text":"","title":"TopologicalAutoencoder"},{"location":"api/models/TopologicalAutoencoder/#latent.models.ae.TopologicalAutoencoder","text":"Autoencoder with fixed encoder adding topological loss on latent space ( Moor 2019 ).","title":"TopologicalAutoencoder"},{"location":"api/models/TopologicalAutoencoder/#latent.models.ae.TopologicalAutoencoder.__init__","text":"Parameters: Name Type Description Default decoder Model Keras/tensorflow model object that inputs the data and outputs the latent space. If not provided, a default model will be constructed from the arguments. None name str String indicating the name of the model. 'topological_autoencoder' x_dim int Integer indicating the number of features in the input data. None latent_dim int Integer indicating the number of dimensions in the latent space. 50 encoder_units Iterable[int] Integer list indicating the number of units of the encoder layers. Only used if encoder is not provided. [128, 128] decoder_units Iterable[int] An integer list indicating the number of units of the decoder layers. Only used if decoder is not provided. [128, 128] use_conditions bool Boolean, whether to force the unpacking of conditions from the inputs. False topo_weight float Float indicating the weight of the topological loss. 1.0 **kwargs Other arguments passed on to DenseStack for constructung encoder/decoder networks. {}","title":"__init__()"},{"location":"api/models/TopologicalAutoencoder/#latent.models.ae.TopologicalAutoencoder.call","text":"Full forward pass through model","title":"call()"},{"location":"api/models/TopologicalAutoencoder/#latent.models.ae.TopologicalAutoencoder.compile","text":"Configures the model for training. Parameters: Name Type Description Default optimizer String (name of optimizer) or optimizer instance. See tf.keras.optimizers . 'adam' loss String (name of objective function), objective function or tf.keras.losses.Loss instance. See tf.keras.losses . An objective function is any callable with the signature loss = fn(y_true, y_pred) , where y_true = ground truth values with shape = [batch_size, d0, .. dN] , except sparse loss functions such as sparse categorical crossentropy where shape = [batch_size, d0, .. dN-1] . y_pred = predicted values with shape = [batch_size, d0, .. dN] . It returns a weighted loss float tensor. If a custom Loss instance is used and reduction is set to NONE, return value has the shape [batch_size, d0, .. dN-1] ie. per-sample or per-timestep loss values; otherwise, it is a scalar. If the model has multiple outputs, you can use a different loss on each output by passing a dictionary or a list of losses. The loss value that will be minimized by the model will then be the sum of all individual losses. None metrics List of metrics to be evaluated by the model during training and testing. Each of this can be a string (name of a built-in function), function or a tf.keras.metrics.Metric instance. See tf.keras.metrics . Typically you will use metrics=['accuracy'] . A function is any callable with the signature result = fn(y_true, y_pred) . To specify different metrics for different outputs of a multi-output model, you could also pass a dictionary, such as metrics={'output_a': 'accuracy', 'output_b': ['accuracy', 'mse']} . You can also pass a list (len = len(outputs)) of lists of metrics such as metrics=[['accuracy'], ['accuracy', 'mse']] or metrics=['accuracy', ['accuracy', 'mse']] . When you pass the strings 'accuracy' or 'acc', we convert this to one of tf.keras.metrics.BinaryAccuracy , tf.keras.metrics.CategoricalAccuracy , tf.keras.metrics.SparseCategoricalAccuracy based on the loss function used and the model output shape. We do a similar conversion for the strings 'crossentropy' and 'ce' as well. required loss_weights Optional list or dictionary specifying scalar coefficients (Python floats) to weight the loss contributions of different model outputs. The loss value that will be minimized by the model will then be the weighted sum of all individual losses, weighted by the loss_weights coefficients. If a list, it is expected to have a 1:1 mapping to the model's outputs. If a dict, it is expected to map output names (strings) to scalar coefficients. required weighted_metrics List of metrics to be evaluated and weighted by sample_weight or class_weight during training and testing. required run_eagerly Bool. Defaults to False . If True , this Model 's logic will not be wrapped in a tf.function . Recommended to leave this as None unless your Model cannot be run inside a tf.function . required steps_per_execution Int. Defaults to 1. The number of batches to run during each tf.function call. Running multiple batches inside a single tf.function call can greatly improve performance on TPUs or small models with a large Python overhead. At most, one full epoch will be run each execution. If a number larger than the size of the epoch is passed, the execution will be truncated to the size of the epoch. Note that if steps_per_execution is set to N , Callback.on_batch_begin and Callback.on_batch_end methods will only be called every N batches (i.e. before/after each tf.function execution). required **kwargs Arguments supported for backwards compatibility only. {} Exceptions: Type Description ValueError In case of invalid arguments for optimizer , loss or metrics .","title":"compile()"},{"location":"api/models/TopologicalAutoencoder/#latent.models.ae.TopologicalAutoencoder.fit","text":"Trains the model for a fixed number of epochs (iterations on a dataset). Parameters: Name Type Description Default x Input data. It could be: - A Numpy array (or array-like), or a list of arrays (in case the model has multiple inputs). - A TensorFlow tensor, or a list of tensors (in case the model has multiple inputs). - A dict mapping input names to the corresponding array/tensors, if the model has named inputs. - A tf.data dataset. Should return a tuple of either (inputs, targets) or (inputs, targets, sample_weights) . - A generator or keras.utils.Sequence returning (inputs, targets) or (inputs, targets, sample_weights) . A more detailed description of unpacking behavior for iterator types (Dataset, generator, Sequence) is given below. required y Target data. Like the input data x , it could be either Numpy array(s) or TensorFlow tensor(s). It should be consistent with x (you cannot have Numpy inputs and tensor targets, or inversely). If x is a dataset, generator, or keras.utils.Sequence instance, y should not be specified (since targets will be obtained from x ). None batch_size Integer or None . Number of samples per gradient update. If unspecified, batch_size will default to 32. Do not specify the batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required epochs Integer. Number of epochs to train the model. An epoch is an iteration over the entire x and y data provided. Note that in conjunction with initial_epoch , epochs is to be understood as \"final epoch\". The model is not trained for a number of iterations given by epochs , but merely until the epoch of index epochs is reached. required verbose 0, 1, or 2. Verbosity mode. 0 = silent, 1 = progress bar, 2 = one line per epoch. Note that the progress bar is not particularly useful when logged to a file, so verbose=2 is recommended when not running interactively (eg, in a production environment). required callbacks List of keras.callbacks.Callback instances. List of callbacks to apply during training. See tf.keras.callbacks . Note tf.keras.callbacks.ProgbarLogger and tf.keras.callbacks.History callbacks are created automatically and need not be passed into model.fit . tf.keras.callbacks.ProgbarLogger is created or not based on verbose argument to model.fit . required validation_split Float between 0 and 1. Fraction of the training data to be used as validation data. The model will set apart this fraction of the training data, will not train on it, and will evaluate the loss and any model metrics on this data at the end of each epoch. The validation data is selected from the last samples in the x and y data provided, before shuffling. This argument is not supported when x is a dataset, generator or keras.utils.Sequence instance. required validation_data Data on which to evaluate the loss and any model metrics at the end of each epoch. The model will not be trained on this data. Thus, note the fact that the validation loss of data provided using validation_split or validation_data is not affected by regularization layers like noise and dropout. validation_data will override validation_split . validation_data could be: - tuple (x_val, y_val) of Numpy arrays or tensors - tuple (x_val, y_val, val_sample_weights) of Numpy arrays - dataset For the first two cases, batch_size must be provided. For the last case, validation_steps could be provided. Note that validation_data does not support all the data types that are supported in x , eg, dict, generator or keras.utils.Sequence . required shuffle Boolean (whether to shuffle the training data before each epoch) or str (for 'batch'). This argument is ignored when x is a generator. 'batch' is a special option for dealing with the limitations of HDF5 data; it shuffles in batch-sized chunks. Has no effect when steps_per_epoch is not None . required class_weight Optional dictionary mapping class indices (integers) to a weight (float) value, used for weighting the loss function (during training only). This can be useful to tell the model to \"pay more attention\" to samples from an under-represented class. required sample_weight Optional Numpy array of weights for the training samples, used for weighting the loss function (during training only). You can either pass a flat (1D) Numpy array with the same length as the input samples (1:1 mapping between weights and samples), or in the case of temporal data, you can pass a 2D array with shape (samples, sequence_length) , to apply a different weight to every timestep of every sample. This argument is not supported when x is a dataset, generator, or keras.utils.Sequence instance, instead provide the sample_weights as the third element of x . required initial_epoch Integer. Epoch at which to start training (useful for resuming a previous training run). required steps_per_epoch Integer or None . Total number of steps (batches of samples) before declaring one epoch finished and starting the next epoch. When training with input tensors such as TensorFlow data tensors, the default None is equal to the number of samples in your dataset divided by the batch size, or 1 if that cannot be determined. If x is a tf.data dataset, and 'steps_per_epoch' is None, the epoch will run until the input dataset is exhausted. When passing an infinitely repeating dataset, you must specify the steps_per_epoch argument. This argument is not supported with array inputs. required validation_steps Only relevant if validation_data is provided and is a tf.data dataset. Total number of steps (batches of samples) to draw before stopping when performing validation at the end of every epoch. If 'validation_steps' is None, validation will run until the validation_data dataset is exhausted. In the case of an infinitely repeated dataset, it will run into an infinite loop. If 'validation_steps' is specified and only part of the dataset will be consumed, the evaluation will start from the beginning of the dataset at each epoch. This ensures that the same validation samples are used every time. required validation_batch_size Integer or None . Number of samples per validation batch. If unspecified, will default to batch_size . Do not specify the validation_batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required validation_freq Only relevant if validation data is provided. Integer or collections_abc.Container instance (e.g. list, tuple, etc.). If an integer, specifies how many training epochs to run before a new validation run is performed, e.g. validation_freq=2 runs validation every 2 epochs. If a Container, specifies the epochs on which to run validation, e.g. validation_freq=[1, 2, 10] runs validation at the end of the 1st, 2nd, and 10th epochs. required max_queue_size Integer. Used for generator or keras.utils.Sequence input only. Maximum size for the generator queue. If unspecified, max_queue_size will default to 10. required workers Integer. Used for generator or keras.utils.Sequence input only. Maximum number of processes to spin up when using process-based threading. If unspecified, workers will default to 1. If 0, will execute the generator on the main thread. required use_multiprocessing Boolean. Used for generator or keras.utils.Sequence input only. If True , use process-based threading. If unspecified, use_multiprocessing will default to False . Note that because this implementation relies on multiprocessing, you should not pass non-picklable arguments to the generator as they can't be passed easily to children processes. required Unpacking behavior for iterator-like inputs: A common pattern is to pass a tf.data.Dataset, generator, or tf.keras.utils.Sequence to the x argument of fit, which will in fact yield not only features (x) but optionally targets (y) and sample weights. Keras requires that the output of such iterator-likes be unambiguous. The iterator should return a tuple of length 1, 2, or 3, where the optional second and third elements will be used for y and sample_weight respectively. Any other type provided will be wrapped in a length one tuple, effectively treating everything as 'x'. When yielding dicts, they should still adhere to the top-level tuple structure. e.g. ({\"x0\": x0, \"x1\": x1}, y) . Keras will not attempt to separate features, targets, and weights from the keys of a single dict. A notable unsupported data type is the namedtuple. The reason is that it behaves like both an ordered datatype (tuple) and a mapping datatype (dict). So given a namedtuple of the form: namedtuple(\"example_tuple\", [\"y\", \"x\"]) it is ambiguous whether to reverse the order of the elements when interpreting the value. Even worse is a tuple of the form: namedtuple(\"other_tuple\", [\"x\", \"y\", \"z\"]) where it is unclear if the tuple was intended to be unpacked into x, y, and sample_weight or passed through as a single element to x . As a result the data processing code will simply raise a ValueError if it encounters a namedtuple. (Along with instructions to remedy the issue.) Returns: Type Description A History object. Its History.history attribute is a record of training loss values and metrics values at successive epochs, as well as validation loss values and validation metrics values (if applicable). Exceptions: Type Description RuntimeError If the model was never compiled or, ValueError In case of mismatch between the provided input data and what the model expects or when the input data is empty.","title":"fit()"},{"location":"api/models/TopologicalAutoencoder/#latent.models.ae.TopologicalAutoencoder.transform","text":"Map data (x) to latent space (z). Parameters: Name Type Description Default inputs A numpy array with input data. required Returns: Type Description A numpy array with the coordinates of the input data in latent space.","title":"transform()"},{"location":"api/models/TopologicalVariationalAutoencoder/","text":"TopologicalVariationalAutoencoder latent.models.vae.TopologicalVariationalAutoencoder Variational autoencoder model with topological loss on latent space __init__ ( self , decoder = None , name = 'variational_autoencoder' , x_dim = None , latent_dim = 50 , encoder_units = [ 128 , 128 ], decoder_units = [ 128 , 128 ], reconstruction_loss = None , use_conditions = False , kld_weight = 1e-05 , topo_weight = 1.0 , prior = 'normal' , latent_dist = 'independent' , iaf_units = [ 256 , 256 ], n_pseudoinputs = 200 , ** kwargs ) special Parameters: Name Type Description Default decoder Model Keras/tensorflow model object that inputs the latent space and outputs the reconstructed data. If not provided, a default model will be constructed from the arguments. None name str String indicating the name of the model. 'variational_autoencoder' x_dim int Integer indicating the number of features in the input data. None latent_dim int Integer indicating the number of dimensions in the latent space. 50 encoder_units Iterable[int] Integer list indicating the number of units of the encoder layers. Only used if encoder is not provided. [128, 128] decoder_units Iterable[int] An integer list indicating the number of units of the decoder layers. Only used if decoder is not provided. [128, 128] reconstruction_loss Callable Loss function applied to the reconstructed data and to be added by the decoder. Only used if decoder is not provided. Can also be added later by calling compile() . None use_conditions bool Boolean, whether to force the unpacking of conditions from the inputs. False kld_weight float Float indicating the weight of the KL Divergence regularization loss. 1e-05 topo_weight float Float indicating the weight of the topological loss. 1.0 prior Literal['normal', 'iaf', 'vamp'] The choice of prior distribution. One of the following: 'normal' - A unit gaussian (normal) distribution. 'iaf' - A unit gaussian with a Inverse Autoregressive Flows bijector ( Kingma 2016 ) 'vamp' - A variational mixture of posteriors (VAMP) prior ( Tomczak 2017 ) 'normal' latent_dist Literal['independent', 'multivariate'] The choice of latent distribution. One of the following: 'independent' - A independent normal produced by tfpl.IndependentNormal . 'multivariate' - A multivariate normal produced by tfpl.MultivariateNormalTriL . 'independent' iaf_units Iterable[int] Integer list indicating the units in the IAF bijector network. Only used if prior = 'iaf' . [256, 256] n_pseudoinputs int Integer indicating the number of pseudoinputs for the VAMP prior. Only used if prior = 'vamp' . 200 **kwargs Other arguments passed on to DenseStack for constructung encoder/ decoder networks. {} call ( self , inputs ) inherited Full forward pass through model compile ( self , optimizer = 'adam' , loss = None , ** kwargs ) inherited Configures the model for training. Parameters: Name Type Description Default optimizer String (name of optimizer) or optimizer instance. See tf.keras.optimizers . 'adam' loss String (name of objective function), objective function or tf.keras.losses.Loss instance. See tf.keras.losses . An objective function is any callable with the signature loss = fn(y_true, y_pred) , where y_true = ground truth values with shape = [batch_size, d0, .. dN] , except sparse loss functions such as sparse categorical crossentropy where shape = [batch_size, d0, .. dN-1] . y_pred = predicted values with shape = [batch_size, d0, .. dN] . It returns a weighted loss float tensor. If a custom Loss instance is used and reduction is set to NONE, return value has the shape [batch_size, d0, .. dN-1] ie. per-sample or per-timestep loss values; otherwise, it is a scalar. If the model has multiple outputs, you can use a different loss on each output by passing a dictionary or a list of losses. The loss value that will be minimized by the model will then be the sum of all individual losses. None metrics List of metrics to be evaluated by the model during training and testing. Each of this can be a string (name of a built-in function), function or a tf.keras.metrics.Metric instance. See tf.keras.metrics . Typically you will use metrics=['accuracy'] . A function is any callable with the signature result = fn(y_true, y_pred) . To specify different metrics for different outputs of a multi-output model, you could also pass a dictionary, such as metrics={'output_a': 'accuracy', 'output_b': ['accuracy', 'mse']} . You can also pass a list (len = len(outputs)) of lists of metrics such as metrics=[['accuracy'], ['accuracy', 'mse']] or metrics=['accuracy', ['accuracy', 'mse']] . When you pass the strings 'accuracy' or 'acc', we convert this to one of tf.keras.metrics.BinaryAccuracy , tf.keras.metrics.CategoricalAccuracy , tf.keras.metrics.SparseCategoricalAccuracy based on the loss function used and the model output shape. We do a similar conversion for the strings 'crossentropy' and 'ce' as well. required loss_weights Optional list or dictionary specifying scalar coefficients (Python floats) to weight the loss contributions of different model outputs. The loss value that will be minimized by the model will then be the weighted sum of all individual losses, weighted by the loss_weights coefficients. If a list, it is expected to have a 1:1 mapping to the model's outputs. If a dict, it is expected to map output names (strings) to scalar coefficients. required weighted_metrics List of metrics to be evaluated and weighted by sample_weight or class_weight during training and testing. required run_eagerly Bool. Defaults to False . If True , this Model 's logic will not be wrapped in a tf.function . Recommended to leave this as None unless your Model cannot be run inside a tf.function . required steps_per_execution Int. Defaults to 1. The number of batches to run during each tf.function call. Running multiple batches inside a single tf.function call can greatly improve performance on TPUs or small models with a large Python overhead. At most, one full epoch will be run each execution. If a number larger than the size of the epoch is passed, the execution will be truncated to the size of the epoch. Note that if steps_per_execution is set to N , Callback.on_batch_begin and Callback.on_batch_end methods will only be called every N batches (i.e. before/after each tf.function execution). required **kwargs Arguments supported for backwards compatibility only. {} Exceptions: Type Description ValueError In case of invalid arguments for optimizer , loss or metrics . fit ( self , x , y = None , ** kwargs ) inherited Trains the model for a fixed number of epochs (iterations on a dataset). Parameters: Name Type Description Default x Input data. It could be: - A Numpy array (or array-like), or a list of arrays (in case the model has multiple inputs). - A TensorFlow tensor, or a list of tensors (in case the model has multiple inputs). - A dict mapping input names to the corresponding array/tensors, if the model has named inputs. - A tf.data dataset. Should return a tuple of either (inputs, targets) or (inputs, targets, sample_weights) . - A generator or keras.utils.Sequence returning (inputs, targets) or (inputs, targets, sample_weights) . A more detailed description of unpacking behavior for iterator types (Dataset, generator, Sequence) is given below. required y Target data. Like the input data x , it could be either Numpy array(s) or TensorFlow tensor(s). It should be consistent with x (you cannot have Numpy inputs and tensor targets, or inversely). If x is a dataset, generator, or keras.utils.Sequence instance, y should not be specified (since targets will be obtained from x ). None batch_size Integer or None . Number of samples per gradient update. If unspecified, batch_size will default to 32. Do not specify the batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required epochs Integer. Number of epochs to train the model. An epoch is an iteration over the entire x and y data provided. Note that in conjunction with initial_epoch , epochs is to be understood as \"final epoch\". The model is not trained for a number of iterations given by epochs , but merely until the epoch of index epochs is reached. required verbose 0, 1, or 2. Verbosity mode. 0 = silent, 1 = progress bar, 2 = one line per epoch. Note that the progress bar is not particularly useful when logged to a file, so verbose=2 is recommended when not running interactively (eg, in a production environment). required callbacks List of keras.callbacks.Callback instances. List of callbacks to apply during training. See tf.keras.callbacks . Note tf.keras.callbacks.ProgbarLogger and tf.keras.callbacks.History callbacks are created automatically and need not be passed into model.fit . tf.keras.callbacks.ProgbarLogger is created or not based on verbose argument to model.fit . required validation_split Float between 0 and 1. Fraction of the training data to be used as validation data. The model will set apart this fraction of the training data, will not train on it, and will evaluate the loss and any model metrics on this data at the end of each epoch. The validation data is selected from the last samples in the x and y data provided, before shuffling. This argument is not supported when x is a dataset, generator or keras.utils.Sequence instance. required validation_data Data on which to evaluate the loss and any model metrics at the end of each epoch. The model will not be trained on this data. Thus, note the fact that the validation loss of data provided using validation_split or validation_data is not affected by regularization layers like noise and dropout. validation_data will override validation_split . validation_data could be: - tuple (x_val, y_val) of Numpy arrays or tensors - tuple (x_val, y_val, val_sample_weights) of Numpy arrays - dataset For the first two cases, batch_size must be provided. For the last case, validation_steps could be provided. Note that validation_data does not support all the data types that are supported in x , eg, dict, generator or keras.utils.Sequence . required shuffle Boolean (whether to shuffle the training data before each epoch) or str (for 'batch'). This argument is ignored when x is a generator. 'batch' is a special option for dealing with the limitations of HDF5 data; it shuffles in batch-sized chunks. Has no effect when steps_per_epoch is not None . required class_weight Optional dictionary mapping class indices (integers) to a weight (float) value, used for weighting the loss function (during training only). This can be useful to tell the model to \"pay more attention\" to samples from an under-represented class. required sample_weight Optional Numpy array of weights for the training samples, used for weighting the loss function (during training only). You can either pass a flat (1D) Numpy array with the same length as the input samples (1:1 mapping between weights and samples), or in the case of temporal data, you can pass a 2D array with shape (samples, sequence_length) , to apply a different weight to every timestep of every sample. This argument is not supported when x is a dataset, generator, or keras.utils.Sequence instance, instead provide the sample_weights as the third element of x . required initial_epoch Integer. Epoch at which to start training (useful for resuming a previous training run). required steps_per_epoch Integer or None . Total number of steps (batches of samples) before declaring one epoch finished and starting the next epoch. When training with input tensors such as TensorFlow data tensors, the default None is equal to the number of samples in your dataset divided by the batch size, or 1 if that cannot be determined. If x is a tf.data dataset, and 'steps_per_epoch' is None, the epoch will run until the input dataset is exhausted. When passing an infinitely repeating dataset, you must specify the steps_per_epoch argument. This argument is not supported with array inputs. required validation_steps Only relevant if validation_data is provided and is a tf.data dataset. Total number of steps (batches of samples) to draw before stopping when performing validation at the end of every epoch. If 'validation_steps' is None, validation will run until the validation_data dataset is exhausted. In the case of an infinitely repeated dataset, it will run into an infinite loop. If 'validation_steps' is specified and only part of the dataset will be consumed, the evaluation will start from the beginning of the dataset at each epoch. This ensures that the same validation samples are used every time. required validation_batch_size Integer or None . Number of samples per validation batch. If unspecified, will default to batch_size . Do not specify the validation_batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required validation_freq Only relevant if validation data is provided. Integer or collections_abc.Container instance (e.g. list, tuple, etc.). If an integer, specifies how many training epochs to run before a new validation run is performed, e.g. validation_freq=2 runs validation every 2 epochs. If a Container, specifies the epochs on which to run validation, e.g. validation_freq=[1, 2, 10] runs validation at the end of the 1st, 2nd, and 10th epochs. required max_queue_size Integer. Used for generator or keras.utils.Sequence input only. Maximum size for the generator queue. If unspecified, max_queue_size will default to 10. required workers Integer. Used for generator or keras.utils.Sequence input only. Maximum number of processes to spin up when using process-based threading. If unspecified, workers will default to 1. If 0, will execute the generator on the main thread. required use_multiprocessing Boolean. Used for generator or keras.utils.Sequence input only. If True , use process-based threading. If unspecified, use_multiprocessing will default to False . Note that because this implementation relies on multiprocessing, you should not pass non-picklable arguments to the generator as they can't be passed easily to children processes. required Unpacking behavior for iterator-like inputs: A common pattern is to pass a tf.data.Dataset, generator, or tf.keras.utils.Sequence to the x argument of fit, which will in fact yield not only features (x) but optionally targets (y) and sample weights. Keras requires that the output of such iterator-likes be unambiguous. The iterator should return a tuple of length 1, 2, or 3, where the optional second and third elements will be used for y and sample_weight respectively. Any other type provided will be wrapped in a length one tuple, effectively treating everything as 'x'. When yielding dicts, they should still adhere to the top-level tuple structure. e.g. ({\"x0\": x0, \"x1\": x1}, y) . Keras will not attempt to separate features, targets, and weights from the keys of a single dict. A notable unsupported data type is the namedtuple. The reason is that it behaves like both an ordered datatype (tuple) and a mapping datatype (dict). So given a namedtuple of the form: namedtuple(\"example_tuple\", [\"y\", \"x\"]) it is ambiguous whether to reverse the order of the elements when interpreting the value. Even worse is a tuple of the form: namedtuple(\"other_tuple\", [\"x\", \"y\", \"z\"]) where it is unclear if the tuple was intended to be unpacked into x, y, and sample_weight or passed through as a single element to x . As a result the data processing code will simply raise a ValueError if it encounters a namedtuple. (Along with instructions to remedy the issue.) Returns: Type Description A History object. Its History.history attribute is a record of training loss values and metrics values at successive epochs, as well as validation loss values and validation metrics values (if applicable). Exceptions: Type Description RuntimeError If the model was never compiled or, ValueError In case of mismatch between the provided input data and what the model expects or when the input data is empty. transform ( self , inputs ) inherited Map data (x) to latent space (z). Parameters: Name Type Description Default inputs A numpy array with input data. required Returns: Type Description A numpy array with the coordinates of the input data in latent space.","title":"TopologicalVariationalAutoencoder"},{"location":"api/models/TopologicalVariationalAutoencoder/#topologicalvariationalautoencoder","text":"","title":"TopologicalVariationalAutoencoder"},{"location":"api/models/TopologicalVariationalAutoencoder/#latent.models.vae.TopologicalVariationalAutoencoder","text":"Variational autoencoder model with topological loss on latent space","title":"TopologicalVariationalAutoencoder"},{"location":"api/models/TopologicalVariationalAutoencoder/#latent.models.vae.TopologicalVariationalAutoencoder.__init__","text":"Parameters: Name Type Description Default decoder Model Keras/tensorflow model object that inputs the latent space and outputs the reconstructed data. If not provided, a default model will be constructed from the arguments. None name str String indicating the name of the model. 'variational_autoencoder' x_dim int Integer indicating the number of features in the input data. None latent_dim int Integer indicating the number of dimensions in the latent space. 50 encoder_units Iterable[int] Integer list indicating the number of units of the encoder layers. Only used if encoder is not provided. [128, 128] decoder_units Iterable[int] An integer list indicating the number of units of the decoder layers. Only used if decoder is not provided. [128, 128] reconstruction_loss Callable Loss function applied to the reconstructed data and to be added by the decoder. Only used if decoder is not provided. Can also be added later by calling compile() . None use_conditions bool Boolean, whether to force the unpacking of conditions from the inputs. False kld_weight float Float indicating the weight of the KL Divergence regularization loss. 1e-05 topo_weight float Float indicating the weight of the topological loss. 1.0 prior Literal['normal', 'iaf', 'vamp'] The choice of prior distribution. One of the following: 'normal' - A unit gaussian (normal) distribution. 'iaf' - A unit gaussian with a Inverse Autoregressive Flows bijector ( Kingma 2016 ) 'vamp' - A variational mixture of posteriors (VAMP) prior ( Tomczak 2017 ) 'normal' latent_dist Literal['independent', 'multivariate'] The choice of latent distribution. One of the following: 'independent' - A independent normal produced by tfpl.IndependentNormal . 'multivariate' - A multivariate normal produced by tfpl.MultivariateNormalTriL . 'independent' iaf_units Iterable[int] Integer list indicating the units in the IAF bijector network. Only used if prior = 'iaf' . [256, 256] n_pseudoinputs int Integer indicating the number of pseudoinputs for the VAMP prior. Only used if prior = 'vamp' . 200 **kwargs Other arguments passed on to DenseStack for constructung encoder/ decoder networks. {}","title":"__init__()"},{"location":"api/models/TopologicalVariationalAutoencoder/#latent.models.vae.TopologicalVariationalAutoencoder.call","text":"Full forward pass through model","title":"call()"},{"location":"api/models/TopologicalVariationalAutoencoder/#latent.models.vae.TopologicalVariationalAutoencoder.compile","text":"Configures the model for training. Parameters: Name Type Description Default optimizer String (name of optimizer) or optimizer instance. See tf.keras.optimizers . 'adam' loss String (name of objective function), objective function or tf.keras.losses.Loss instance. See tf.keras.losses . An objective function is any callable with the signature loss = fn(y_true, y_pred) , where y_true = ground truth values with shape = [batch_size, d0, .. dN] , except sparse loss functions such as sparse categorical crossentropy where shape = [batch_size, d0, .. dN-1] . y_pred = predicted values with shape = [batch_size, d0, .. dN] . It returns a weighted loss float tensor. If a custom Loss instance is used and reduction is set to NONE, return value has the shape [batch_size, d0, .. dN-1] ie. per-sample or per-timestep loss values; otherwise, it is a scalar. If the model has multiple outputs, you can use a different loss on each output by passing a dictionary or a list of losses. The loss value that will be minimized by the model will then be the sum of all individual losses. None metrics List of metrics to be evaluated by the model during training and testing. Each of this can be a string (name of a built-in function), function or a tf.keras.metrics.Metric instance. See tf.keras.metrics . Typically you will use metrics=['accuracy'] . A function is any callable with the signature result = fn(y_true, y_pred) . To specify different metrics for different outputs of a multi-output model, you could also pass a dictionary, such as metrics={'output_a': 'accuracy', 'output_b': ['accuracy', 'mse']} . You can also pass a list (len = len(outputs)) of lists of metrics such as metrics=[['accuracy'], ['accuracy', 'mse']] or metrics=['accuracy', ['accuracy', 'mse']] . When you pass the strings 'accuracy' or 'acc', we convert this to one of tf.keras.metrics.BinaryAccuracy , tf.keras.metrics.CategoricalAccuracy , tf.keras.metrics.SparseCategoricalAccuracy based on the loss function used and the model output shape. We do a similar conversion for the strings 'crossentropy' and 'ce' as well. required loss_weights Optional list or dictionary specifying scalar coefficients (Python floats) to weight the loss contributions of different model outputs. The loss value that will be minimized by the model will then be the weighted sum of all individual losses, weighted by the loss_weights coefficients. If a list, it is expected to have a 1:1 mapping to the model's outputs. If a dict, it is expected to map output names (strings) to scalar coefficients. required weighted_metrics List of metrics to be evaluated and weighted by sample_weight or class_weight during training and testing. required run_eagerly Bool. Defaults to False . If True , this Model 's logic will not be wrapped in a tf.function . Recommended to leave this as None unless your Model cannot be run inside a tf.function . required steps_per_execution Int. Defaults to 1. The number of batches to run during each tf.function call. Running multiple batches inside a single tf.function call can greatly improve performance on TPUs or small models with a large Python overhead. At most, one full epoch will be run each execution. If a number larger than the size of the epoch is passed, the execution will be truncated to the size of the epoch. Note that if steps_per_execution is set to N , Callback.on_batch_begin and Callback.on_batch_end methods will only be called every N batches (i.e. before/after each tf.function execution). required **kwargs Arguments supported for backwards compatibility only. {} Exceptions: Type Description ValueError In case of invalid arguments for optimizer , loss or metrics .","title":"compile()"},{"location":"api/models/TopologicalVariationalAutoencoder/#latent.models.vae.TopologicalVariationalAutoencoder.fit","text":"Trains the model for a fixed number of epochs (iterations on a dataset). Parameters: Name Type Description Default x Input data. It could be: - A Numpy array (or array-like), or a list of arrays (in case the model has multiple inputs). - A TensorFlow tensor, or a list of tensors (in case the model has multiple inputs). - A dict mapping input names to the corresponding array/tensors, if the model has named inputs. - A tf.data dataset. Should return a tuple of either (inputs, targets) or (inputs, targets, sample_weights) . - A generator or keras.utils.Sequence returning (inputs, targets) or (inputs, targets, sample_weights) . A more detailed description of unpacking behavior for iterator types (Dataset, generator, Sequence) is given below. required y Target data. Like the input data x , it could be either Numpy array(s) or TensorFlow tensor(s). It should be consistent with x (you cannot have Numpy inputs and tensor targets, or inversely). If x is a dataset, generator, or keras.utils.Sequence instance, y should not be specified (since targets will be obtained from x ). None batch_size Integer or None . Number of samples per gradient update. If unspecified, batch_size will default to 32. Do not specify the batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required epochs Integer. Number of epochs to train the model. An epoch is an iteration over the entire x and y data provided. Note that in conjunction with initial_epoch , epochs is to be understood as \"final epoch\". The model is not trained for a number of iterations given by epochs , but merely until the epoch of index epochs is reached. required verbose 0, 1, or 2. Verbosity mode. 0 = silent, 1 = progress bar, 2 = one line per epoch. Note that the progress bar is not particularly useful when logged to a file, so verbose=2 is recommended when not running interactively (eg, in a production environment). required callbacks List of keras.callbacks.Callback instances. List of callbacks to apply during training. See tf.keras.callbacks . Note tf.keras.callbacks.ProgbarLogger and tf.keras.callbacks.History callbacks are created automatically and need not be passed into model.fit . tf.keras.callbacks.ProgbarLogger is created or not based on verbose argument to model.fit . required validation_split Float between 0 and 1. Fraction of the training data to be used as validation data. The model will set apart this fraction of the training data, will not train on it, and will evaluate the loss and any model metrics on this data at the end of each epoch. The validation data is selected from the last samples in the x and y data provided, before shuffling. This argument is not supported when x is a dataset, generator or keras.utils.Sequence instance. required validation_data Data on which to evaluate the loss and any model metrics at the end of each epoch. The model will not be trained on this data. Thus, note the fact that the validation loss of data provided using validation_split or validation_data is not affected by regularization layers like noise and dropout. validation_data will override validation_split . validation_data could be: - tuple (x_val, y_val) of Numpy arrays or tensors - tuple (x_val, y_val, val_sample_weights) of Numpy arrays - dataset For the first two cases, batch_size must be provided. For the last case, validation_steps could be provided. Note that validation_data does not support all the data types that are supported in x , eg, dict, generator or keras.utils.Sequence . required shuffle Boolean (whether to shuffle the training data before each epoch) or str (for 'batch'). This argument is ignored when x is a generator. 'batch' is a special option for dealing with the limitations of HDF5 data; it shuffles in batch-sized chunks. Has no effect when steps_per_epoch is not None . required class_weight Optional dictionary mapping class indices (integers) to a weight (float) value, used for weighting the loss function (during training only). This can be useful to tell the model to \"pay more attention\" to samples from an under-represented class. required sample_weight Optional Numpy array of weights for the training samples, used for weighting the loss function (during training only). You can either pass a flat (1D) Numpy array with the same length as the input samples (1:1 mapping between weights and samples), or in the case of temporal data, you can pass a 2D array with shape (samples, sequence_length) , to apply a different weight to every timestep of every sample. This argument is not supported when x is a dataset, generator, or keras.utils.Sequence instance, instead provide the sample_weights as the third element of x . required initial_epoch Integer. Epoch at which to start training (useful for resuming a previous training run). required steps_per_epoch Integer or None . Total number of steps (batches of samples) before declaring one epoch finished and starting the next epoch. When training with input tensors such as TensorFlow data tensors, the default None is equal to the number of samples in your dataset divided by the batch size, or 1 if that cannot be determined. If x is a tf.data dataset, and 'steps_per_epoch' is None, the epoch will run until the input dataset is exhausted. When passing an infinitely repeating dataset, you must specify the steps_per_epoch argument. This argument is not supported with array inputs. required validation_steps Only relevant if validation_data is provided and is a tf.data dataset. Total number of steps (batches of samples) to draw before stopping when performing validation at the end of every epoch. If 'validation_steps' is None, validation will run until the validation_data dataset is exhausted. In the case of an infinitely repeated dataset, it will run into an infinite loop. If 'validation_steps' is specified and only part of the dataset will be consumed, the evaluation will start from the beginning of the dataset at each epoch. This ensures that the same validation samples are used every time. required validation_batch_size Integer or None . Number of samples per validation batch. If unspecified, will default to batch_size . Do not specify the validation_batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required validation_freq Only relevant if validation data is provided. Integer or collections_abc.Container instance (e.g. list, tuple, etc.). If an integer, specifies how many training epochs to run before a new validation run is performed, e.g. validation_freq=2 runs validation every 2 epochs. If a Container, specifies the epochs on which to run validation, e.g. validation_freq=[1, 2, 10] runs validation at the end of the 1st, 2nd, and 10th epochs. required max_queue_size Integer. Used for generator or keras.utils.Sequence input only. Maximum size for the generator queue. If unspecified, max_queue_size will default to 10. required workers Integer. Used for generator or keras.utils.Sequence input only. Maximum number of processes to spin up when using process-based threading. If unspecified, workers will default to 1. If 0, will execute the generator on the main thread. required use_multiprocessing Boolean. Used for generator or keras.utils.Sequence input only. If True , use process-based threading. If unspecified, use_multiprocessing will default to False . Note that because this implementation relies on multiprocessing, you should not pass non-picklable arguments to the generator as they can't be passed easily to children processes. required Unpacking behavior for iterator-like inputs: A common pattern is to pass a tf.data.Dataset, generator, or tf.keras.utils.Sequence to the x argument of fit, which will in fact yield not only features (x) but optionally targets (y) and sample weights. Keras requires that the output of such iterator-likes be unambiguous. The iterator should return a tuple of length 1, 2, or 3, where the optional second and third elements will be used for y and sample_weight respectively. Any other type provided will be wrapped in a length one tuple, effectively treating everything as 'x'. When yielding dicts, they should still adhere to the top-level tuple structure. e.g. ({\"x0\": x0, \"x1\": x1}, y) . Keras will not attempt to separate features, targets, and weights from the keys of a single dict. A notable unsupported data type is the namedtuple. The reason is that it behaves like both an ordered datatype (tuple) and a mapping datatype (dict). So given a namedtuple of the form: namedtuple(\"example_tuple\", [\"y\", \"x\"]) it is ambiguous whether to reverse the order of the elements when interpreting the value. Even worse is a tuple of the form: namedtuple(\"other_tuple\", [\"x\", \"y\", \"z\"]) where it is unclear if the tuple was intended to be unpacked into x, y, and sample_weight or passed through as a single element to x . As a result the data processing code will simply raise a ValueError if it encounters a namedtuple. (Along with instructions to remedy the issue.) Returns: Type Description A History object. Its History.history attribute is a record of training loss values and metrics values at successive epochs, as well as validation loss values and validation metrics values (if applicable). Exceptions: Type Description RuntimeError If the model was never compiled or, ValueError In case of mismatch between the provided input data and what the model expects or when the input data is empty.","title":"fit()"},{"location":"api/models/TopologicalVariationalAutoencoder/#latent.models.vae.TopologicalVariationalAutoencoder.transform","text":"Map data (x) to latent space (z). Parameters: Name Type Description Default inputs A numpy array with input data. required Returns: Type Description A numpy array with the coordinates of the input data in latent space.","title":"transform()"},{"location":"api/models/TwinAutoencoder/","text":"TwinAutoencoder latent.models.twae.TwinAutoencoder Twin autoencoder that joins two autoencoders in a shared latent space __init__ ( self , models , critic = 'mmd' , critic_weight = 1.0 , n_conditions = None , ** kwargs ) special Parameters: Name Type Description Default models Tuple[tensorflow.python.keras.engine.training.Model, tensorflow.python.keras.engine.training.Model] A list of size two with keras.Model autoencoder models. required critic Union[str, tensorflow.python.keras.engine.base_layer.Layer] A keras.Layer object thats add a loss based on the discrimination of latent representations. 'mmd' critic_weight float Positive float indicating the weight of the critic loss. 1.0 n_conditions int Number of conditions to match between the inputs. If given, the citic loss is calculated within conditions. None **kwargs Additional arguments passed to the critic {} call ( self , inputs ) Calls the model on new inputs. In this case call just reapplies all ops in the graph to the new inputs (e.g. build a new computational graph from the provided inputs). Parameters: Name Type Description Default inputs A tensor or list of tensors. required training Boolean or boolean scalar tensor, indicating whether to run the Network in training mode or inference mode. required mask A mask or list of masks. A mask can be either a tensor or None (no mask). required Returns: Type Description A tensor if there is a single output, or a list of tensors if there are more than one outputs. compile ( self , optimizer = 'adam' , loss = None , ** kwargs ) Configures the model for training. Parameters: Name Type Description Default optimizer String (name of optimizer) or optimizer instance. See tf.keras.optimizers . 'adam' loss String (name of objective function), objective function or tf.keras.losses.Loss instance. See tf.keras.losses . An objective function is any callable with the signature loss = fn(y_true, y_pred) , where y_true = ground truth values with shape = [batch_size, d0, .. dN] , except sparse loss functions such as sparse categorical crossentropy where shape = [batch_size, d0, .. dN-1] . y_pred = predicted values with shape = [batch_size, d0, .. dN] . It returns a weighted loss float tensor. If a custom Loss instance is used and reduction is set to NONE, return value has the shape [batch_size, d0, .. dN-1] ie. per-sample or per-timestep loss values; otherwise, it is a scalar. If the model has multiple outputs, you can use a different loss on each output by passing a dictionary or a list of losses. The loss value that will be minimized by the model will then be the sum of all individual losses. None metrics List of metrics to be evaluated by the model during training and testing. Each of this can be a string (name of a built-in function), function or a tf.keras.metrics.Metric instance. See tf.keras.metrics . Typically you will use metrics=['accuracy'] . A function is any callable with the signature result = fn(y_true, y_pred) . To specify different metrics for different outputs of a multi-output model, you could also pass a dictionary, such as metrics={'output_a': 'accuracy', 'output_b': ['accuracy', 'mse']} . You can also pass a list (len = len(outputs)) of lists of metrics such as metrics=[['accuracy'], ['accuracy', 'mse']] or metrics=['accuracy', ['accuracy', 'mse']] . When you pass the strings 'accuracy' or 'acc', we convert this to one of tf.keras.metrics.BinaryAccuracy , tf.keras.metrics.CategoricalAccuracy , tf.keras.metrics.SparseCategoricalAccuracy based on the loss function used and the model output shape. We do a similar conversion for the strings 'crossentropy' and 'ce' as well. required loss_weights Optional list or dictionary specifying scalar coefficients (Python floats) to weight the loss contributions of different model outputs. The loss value that will be minimized by the model will then be the weighted sum of all individual losses, weighted by the loss_weights coefficients. If a list, it is expected to have a 1:1 mapping to the model's outputs. If a dict, it is expected to map output names (strings) to scalar coefficients. required weighted_metrics List of metrics to be evaluated and weighted by sample_weight or class_weight during training and testing. required run_eagerly Bool. Defaults to False . If True , this Model 's logic will not be wrapped in a tf.function . Recommended to leave this as None unless your Model cannot be run inside a tf.function . required steps_per_execution Int. Defaults to 1. The number of batches to run during each tf.function call. Running multiple batches inside a single tf.function call can greatly improve performance on TPUs or small models with a large Python overhead. At most, one full epoch will be run each execution. If a number larger than the size of the epoch is passed, the execution will be truncated to the size of the epoch. Note that if steps_per_execution is set to N , Callback.on_batch_begin and Callback.on_batch_end methods will only be called every N batches (i.e. before/after each tf.function execution). required **kwargs Arguments supported for backwards compatibility only. {} Exceptions: Type Description ValueError In case of invalid arguments for optimizer , loss or metrics . fit ( self , x = None , y = None , batch_size = None , epochs = 1 , verbose = 1 , callbacks = None , validation_split = 0.0 , validation_data = None , shuffle = True , class_weight = None , sample_weight = None , initial_epoch = 0 , steps_per_epoch = None , validation_steps = None , validation_batch_size = None , validation_freq = 1 , max_queue_size = 10 , workers = 1 , use_multiprocessing = False ) inherited Trains the model for a fixed number of epochs (iterations on a dataset). Parameters: Name Type Description Default x Input data. It could be: - A Numpy array (or array-like), or a list of arrays (in case the model has multiple inputs). - A TensorFlow tensor, or a list of tensors (in case the model has multiple inputs). - A dict mapping input names to the corresponding array/tensors, if the model has named inputs. - A tf.data dataset. Should return a tuple of either (inputs, targets) or (inputs, targets, sample_weights) . - A generator or keras.utils.Sequence returning (inputs, targets) or (inputs, targets, sample_weights) . A more detailed description of unpacking behavior for iterator types (Dataset, generator, Sequence) is given below. None y Target data. Like the input data x , it could be either Numpy array(s) or TensorFlow tensor(s). It should be consistent with x (you cannot have Numpy inputs and tensor targets, or inversely). If x is a dataset, generator, or keras.utils.Sequence instance, y should not be specified (since targets will be obtained from x ). None batch_size Integer or None . Number of samples per gradient update. If unspecified, batch_size will default to 32. Do not specify the batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). None epochs Integer. Number of epochs to train the model. An epoch is an iteration over the entire x and y data provided. Note that in conjunction with initial_epoch , epochs is to be understood as \"final epoch\". The model is not trained for a number of iterations given by epochs , but merely until the epoch of index epochs is reached. 1 verbose 0, 1, or 2. Verbosity mode. 0 = silent, 1 = progress bar, 2 = one line per epoch. Note that the progress bar is not particularly useful when logged to a file, so verbose=2 is recommended when not running interactively (eg, in a production environment). 1 callbacks List of keras.callbacks.Callback instances. List of callbacks to apply during training. See tf.keras.callbacks . Note tf.keras.callbacks.ProgbarLogger and tf.keras.callbacks.History callbacks are created automatically and need not be passed into model.fit . tf.keras.callbacks.ProgbarLogger is created or not based on verbose argument to model.fit . None validation_split Float between 0 and 1. Fraction of the training data to be used as validation data. The model will set apart this fraction of the training data, will not train on it, and will evaluate the loss and any model metrics on this data at the end of each epoch. The validation data is selected from the last samples in the x and y data provided, before shuffling. This argument is not supported when x is a dataset, generator or keras.utils.Sequence instance. 0.0 validation_data Data on which to evaluate the loss and any model metrics at the end of each epoch. The model will not be trained on this data. Thus, note the fact that the validation loss of data provided using validation_split or validation_data is not affected by regularization layers like noise and dropout. validation_data will override validation_split . validation_data could be: - tuple (x_val, y_val) of Numpy arrays or tensors - tuple (x_val, y_val, val_sample_weights) of Numpy arrays - dataset For the first two cases, batch_size must be provided. For the last case, validation_steps could be provided. Note that validation_data does not support all the data types that are supported in x , eg, dict, generator or keras.utils.Sequence . None shuffle Boolean (whether to shuffle the training data before each epoch) or str (for 'batch'). This argument is ignored when x is a generator. 'batch' is a special option for dealing with the limitations of HDF5 data; it shuffles in batch-sized chunks. Has no effect when steps_per_epoch is not None . True class_weight Optional dictionary mapping class indices (integers) to a weight (float) value, used for weighting the loss function (during training only). This can be useful to tell the model to \"pay more attention\" to samples from an under-represented class. None sample_weight Optional Numpy array of weights for the training samples, used for weighting the loss function (during training only). You can either pass a flat (1D) Numpy array with the same length as the input samples (1:1 mapping between weights and samples), or in the case of temporal data, you can pass a 2D array with shape (samples, sequence_length) , to apply a different weight to every timestep of every sample. This argument is not supported when x is a dataset, generator, or keras.utils.Sequence instance, instead provide the sample_weights as the third element of x . None initial_epoch Integer. Epoch at which to start training (useful for resuming a previous training run). 0 steps_per_epoch Integer or None . Total number of steps (batches of samples) before declaring one epoch finished and starting the next epoch. When training with input tensors such as TensorFlow data tensors, the default None is equal to the number of samples in your dataset divided by the batch size, or 1 if that cannot be determined. If x is a tf.data dataset, and 'steps_per_epoch' is None, the epoch will run until the input dataset is exhausted. When passing an infinitely repeating dataset, you must specify the steps_per_epoch argument. This argument is not supported with array inputs. None validation_steps Only relevant if validation_data is provided and is a tf.data dataset. Total number of steps (batches of samples) to draw before stopping when performing validation at the end of every epoch. If 'validation_steps' is None, validation will run until the validation_data dataset is exhausted. In the case of an infinitely repeated dataset, it will run into an infinite loop. If 'validation_steps' is specified and only part of the dataset will be consumed, the evaluation will start from the beginning of the dataset at each epoch. This ensures that the same validation samples are used every time. None validation_batch_size Integer or None . Number of samples per validation batch. If unspecified, will default to batch_size . Do not specify the validation_batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). None validation_freq Only relevant if validation data is provided. Integer or collections_abc.Container instance (e.g. list, tuple, etc.). If an integer, specifies how many training epochs to run before a new validation run is performed, e.g. validation_freq=2 runs validation every 2 epochs. If a Container, specifies the epochs on which to run validation, e.g. validation_freq=[1, 2, 10] runs validation at the end of the 1st, 2nd, and 10th epochs. 1 max_queue_size Integer. Used for generator or keras.utils.Sequence input only. Maximum size for the generator queue. If unspecified, max_queue_size will default to 10. 10 workers Integer. Used for generator or keras.utils.Sequence input only. Maximum number of processes to spin up when using process-based threading. If unspecified, workers will default to 1. If 0, will execute the generator on the main thread. 1 use_multiprocessing Boolean. Used for generator or keras.utils.Sequence input only. If True , use process-based threading. If unspecified, use_multiprocessing will default to False . Note that because this implementation relies on multiprocessing, you should not pass non-picklable arguments to the generator as they can't be passed easily to children processes. False Unpacking behavior for iterator-like inputs: A common pattern is to pass a tf.data.Dataset, generator, or tf.keras.utils.Sequence to the x argument of fit, which will in fact yield not only features (x) but optionally targets (y) and sample weights. Keras requires that the output of such iterator-likes be unambiguous. The iterator should return a tuple of length 1, 2, or 3, where the optional second and third elements will be used for y and sample_weight respectively. Any other type provided will be wrapped in a length one tuple, effectively treating everything as 'x'. When yielding dicts, they should still adhere to the top-level tuple structure. e.g. ({\"x0\": x0, \"x1\": x1}, y) . Keras will not attempt to separate features, targets, and weights from the keys of a single dict. A notable unsupported data type is the namedtuple. The reason is that it behaves like both an ordered datatype (tuple) and a mapping datatype (dict). So given a namedtuple of the form: namedtuple(\"example_tuple\", [\"y\", \"x\"]) it is ambiguous whether to reverse the order of the elements when interpreting the value. Even worse is a tuple of the form: namedtuple(\"other_tuple\", [\"x\", \"y\", \"z\"]) where it is unclear if the tuple was intended to be unpacked into x, y, and sample_weight or passed through as a single element to x . As a result the data processing code will simply raise a ValueError if it encounters a namedtuple. (Along with instructions to remedy the issue.) Returns: Type Description A History object. Its History.history attribute is a record of training loss values and metrics values at successive epochs, as well as validation loss values and validation metrics values (if applicable). Exceptions: Type Description RuntimeError If the model was never compiled or, ValueError In case of mismatch between the provided input data and what the model expects or when the input data is empty. transform ( self , inputs , join_output = True ) Map data (x) to latent space (z). Parameters: Name Type Description Default inputs A numpy array with input data. required join_output Boolean, whether to concatenate outputs. True Returns: Type Description ndarray A numpy array with the coordinates of the input data in latent space.","title":"TwinAutoencoder"},{"location":"api/models/TwinAutoencoder/#twinautoencoder","text":"","title":"TwinAutoencoder"},{"location":"api/models/TwinAutoencoder/#latent.models.twae.TwinAutoencoder","text":"Twin autoencoder that joins two autoencoders in a shared latent space","title":"TwinAutoencoder"},{"location":"api/models/TwinAutoencoder/#latent.models.twae.TwinAutoencoder.__init__","text":"Parameters: Name Type Description Default models Tuple[tensorflow.python.keras.engine.training.Model, tensorflow.python.keras.engine.training.Model] A list of size two with keras.Model autoencoder models. required critic Union[str, tensorflow.python.keras.engine.base_layer.Layer] A keras.Layer object thats add a loss based on the discrimination of latent representations. 'mmd' critic_weight float Positive float indicating the weight of the critic loss. 1.0 n_conditions int Number of conditions to match between the inputs. If given, the citic loss is calculated within conditions. None **kwargs Additional arguments passed to the critic {}","title":"__init__()"},{"location":"api/models/TwinAutoencoder/#latent.models.twae.TwinAutoencoder.call","text":"Calls the model on new inputs. In this case call just reapplies all ops in the graph to the new inputs (e.g. build a new computational graph from the provided inputs). Parameters: Name Type Description Default inputs A tensor or list of tensors. required training Boolean or boolean scalar tensor, indicating whether to run the Network in training mode or inference mode. required mask A mask or list of masks. A mask can be either a tensor or None (no mask). required Returns: Type Description A tensor if there is a single output, or a list of tensors if there are more than one outputs.","title":"call()"},{"location":"api/models/TwinAutoencoder/#latent.models.twae.TwinAutoencoder.compile","text":"Configures the model for training. Parameters: Name Type Description Default optimizer String (name of optimizer) or optimizer instance. See tf.keras.optimizers . 'adam' loss String (name of objective function), objective function or tf.keras.losses.Loss instance. See tf.keras.losses . An objective function is any callable with the signature loss = fn(y_true, y_pred) , where y_true = ground truth values with shape = [batch_size, d0, .. dN] , except sparse loss functions such as sparse categorical crossentropy where shape = [batch_size, d0, .. dN-1] . y_pred = predicted values with shape = [batch_size, d0, .. dN] . It returns a weighted loss float tensor. If a custom Loss instance is used and reduction is set to NONE, return value has the shape [batch_size, d0, .. dN-1] ie. per-sample or per-timestep loss values; otherwise, it is a scalar. If the model has multiple outputs, you can use a different loss on each output by passing a dictionary or a list of losses. The loss value that will be minimized by the model will then be the sum of all individual losses. None metrics List of metrics to be evaluated by the model during training and testing. Each of this can be a string (name of a built-in function), function or a tf.keras.metrics.Metric instance. See tf.keras.metrics . Typically you will use metrics=['accuracy'] . A function is any callable with the signature result = fn(y_true, y_pred) . To specify different metrics for different outputs of a multi-output model, you could also pass a dictionary, such as metrics={'output_a': 'accuracy', 'output_b': ['accuracy', 'mse']} . You can also pass a list (len = len(outputs)) of lists of metrics such as metrics=[['accuracy'], ['accuracy', 'mse']] or metrics=['accuracy', ['accuracy', 'mse']] . When you pass the strings 'accuracy' or 'acc', we convert this to one of tf.keras.metrics.BinaryAccuracy , tf.keras.metrics.CategoricalAccuracy , tf.keras.metrics.SparseCategoricalAccuracy based on the loss function used and the model output shape. We do a similar conversion for the strings 'crossentropy' and 'ce' as well. required loss_weights Optional list or dictionary specifying scalar coefficients (Python floats) to weight the loss contributions of different model outputs. The loss value that will be minimized by the model will then be the weighted sum of all individual losses, weighted by the loss_weights coefficients. If a list, it is expected to have a 1:1 mapping to the model's outputs. If a dict, it is expected to map output names (strings) to scalar coefficients. required weighted_metrics List of metrics to be evaluated and weighted by sample_weight or class_weight during training and testing. required run_eagerly Bool. Defaults to False . If True , this Model 's logic will not be wrapped in a tf.function . Recommended to leave this as None unless your Model cannot be run inside a tf.function . required steps_per_execution Int. Defaults to 1. The number of batches to run during each tf.function call. Running multiple batches inside a single tf.function call can greatly improve performance on TPUs or small models with a large Python overhead. At most, one full epoch will be run each execution. If a number larger than the size of the epoch is passed, the execution will be truncated to the size of the epoch. Note that if steps_per_execution is set to N , Callback.on_batch_begin and Callback.on_batch_end methods will only be called every N batches (i.e. before/after each tf.function execution). required **kwargs Arguments supported for backwards compatibility only. {} Exceptions: Type Description ValueError In case of invalid arguments for optimizer , loss or metrics .","title":"compile()"},{"location":"api/models/TwinAutoencoder/#latent.models.twae.TwinAutoencoder.fit","text":"Trains the model for a fixed number of epochs (iterations on a dataset). Parameters: Name Type Description Default x Input data. It could be: - A Numpy array (or array-like), or a list of arrays (in case the model has multiple inputs). - A TensorFlow tensor, or a list of tensors (in case the model has multiple inputs). - A dict mapping input names to the corresponding array/tensors, if the model has named inputs. - A tf.data dataset. Should return a tuple of either (inputs, targets) or (inputs, targets, sample_weights) . - A generator or keras.utils.Sequence returning (inputs, targets) or (inputs, targets, sample_weights) . A more detailed description of unpacking behavior for iterator types (Dataset, generator, Sequence) is given below. None y Target data. Like the input data x , it could be either Numpy array(s) or TensorFlow tensor(s). It should be consistent with x (you cannot have Numpy inputs and tensor targets, or inversely). If x is a dataset, generator, or keras.utils.Sequence instance, y should not be specified (since targets will be obtained from x ). None batch_size Integer or None . Number of samples per gradient update. If unspecified, batch_size will default to 32. Do not specify the batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). None epochs Integer. Number of epochs to train the model. An epoch is an iteration over the entire x and y data provided. Note that in conjunction with initial_epoch , epochs is to be understood as \"final epoch\". The model is not trained for a number of iterations given by epochs , but merely until the epoch of index epochs is reached. 1 verbose 0, 1, or 2. Verbosity mode. 0 = silent, 1 = progress bar, 2 = one line per epoch. Note that the progress bar is not particularly useful when logged to a file, so verbose=2 is recommended when not running interactively (eg, in a production environment). 1 callbacks List of keras.callbacks.Callback instances. List of callbacks to apply during training. See tf.keras.callbacks . Note tf.keras.callbacks.ProgbarLogger and tf.keras.callbacks.History callbacks are created automatically and need not be passed into model.fit . tf.keras.callbacks.ProgbarLogger is created or not based on verbose argument to model.fit . None validation_split Float between 0 and 1. Fraction of the training data to be used as validation data. The model will set apart this fraction of the training data, will not train on it, and will evaluate the loss and any model metrics on this data at the end of each epoch. The validation data is selected from the last samples in the x and y data provided, before shuffling. This argument is not supported when x is a dataset, generator or keras.utils.Sequence instance. 0.0 validation_data Data on which to evaluate the loss and any model metrics at the end of each epoch. The model will not be trained on this data. Thus, note the fact that the validation loss of data provided using validation_split or validation_data is not affected by regularization layers like noise and dropout. validation_data will override validation_split . validation_data could be: - tuple (x_val, y_val) of Numpy arrays or tensors - tuple (x_val, y_val, val_sample_weights) of Numpy arrays - dataset For the first two cases, batch_size must be provided. For the last case, validation_steps could be provided. Note that validation_data does not support all the data types that are supported in x , eg, dict, generator or keras.utils.Sequence . None shuffle Boolean (whether to shuffle the training data before each epoch) or str (for 'batch'). This argument is ignored when x is a generator. 'batch' is a special option for dealing with the limitations of HDF5 data; it shuffles in batch-sized chunks. Has no effect when steps_per_epoch is not None . True class_weight Optional dictionary mapping class indices (integers) to a weight (float) value, used for weighting the loss function (during training only). This can be useful to tell the model to \"pay more attention\" to samples from an under-represented class. None sample_weight Optional Numpy array of weights for the training samples, used for weighting the loss function (during training only). You can either pass a flat (1D) Numpy array with the same length as the input samples (1:1 mapping between weights and samples), or in the case of temporal data, you can pass a 2D array with shape (samples, sequence_length) , to apply a different weight to every timestep of every sample. This argument is not supported when x is a dataset, generator, or keras.utils.Sequence instance, instead provide the sample_weights as the third element of x . None initial_epoch Integer. Epoch at which to start training (useful for resuming a previous training run). 0 steps_per_epoch Integer or None . Total number of steps (batches of samples) before declaring one epoch finished and starting the next epoch. When training with input tensors such as TensorFlow data tensors, the default None is equal to the number of samples in your dataset divided by the batch size, or 1 if that cannot be determined. If x is a tf.data dataset, and 'steps_per_epoch' is None, the epoch will run until the input dataset is exhausted. When passing an infinitely repeating dataset, you must specify the steps_per_epoch argument. This argument is not supported with array inputs. None validation_steps Only relevant if validation_data is provided and is a tf.data dataset. Total number of steps (batches of samples) to draw before stopping when performing validation at the end of every epoch. If 'validation_steps' is None, validation will run until the validation_data dataset is exhausted. In the case of an infinitely repeated dataset, it will run into an infinite loop. If 'validation_steps' is specified and only part of the dataset will be consumed, the evaluation will start from the beginning of the dataset at each epoch. This ensures that the same validation samples are used every time. None validation_batch_size Integer or None . Number of samples per validation batch. If unspecified, will default to batch_size . Do not specify the validation_batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). None validation_freq Only relevant if validation data is provided. Integer or collections_abc.Container instance (e.g. list, tuple, etc.). If an integer, specifies how many training epochs to run before a new validation run is performed, e.g. validation_freq=2 runs validation every 2 epochs. If a Container, specifies the epochs on which to run validation, e.g. validation_freq=[1, 2, 10] runs validation at the end of the 1st, 2nd, and 10th epochs. 1 max_queue_size Integer. Used for generator or keras.utils.Sequence input only. Maximum size for the generator queue. If unspecified, max_queue_size will default to 10. 10 workers Integer. Used for generator or keras.utils.Sequence input only. Maximum number of processes to spin up when using process-based threading. If unspecified, workers will default to 1. If 0, will execute the generator on the main thread. 1 use_multiprocessing Boolean. Used for generator or keras.utils.Sequence input only. If True , use process-based threading. If unspecified, use_multiprocessing will default to False . Note that because this implementation relies on multiprocessing, you should not pass non-picklable arguments to the generator as they can't be passed easily to children processes. False Unpacking behavior for iterator-like inputs: A common pattern is to pass a tf.data.Dataset, generator, or tf.keras.utils.Sequence to the x argument of fit, which will in fact yield not only features (x) but optionally targets (y) and sample weights. Keras requires that the output of such iterator-likes be unambiguous. The iterator should return a tuple of length 1, 2, or 3, where the optional second and third elements will be used for y and sample_weight respectively. Any other type provided will be wrapped in a length one tuple, effectively treating everything as 'x'. When yielding dicts, they should still adhere to the top-level tuple structure. e.g. ({\"x0\": x0, \"x1\": x1}, y) . Keras will not attempt to separate features, targets, and weights from the keys of a single dict. A notable unsupported data type is the namedtuple. The reason is that it behaves like both an ordered datatype (tuple) and a mapping datatype (dict). So given a namedtuple of the form: namedtuple(\"example_tuple\", [\"y\", \"x\"]) it is ambiguous whether to reverse the order of the elements when interpreting the value. Even worse is a tuple of the form: namedtuple(\"other_tuple\", [\"x\", \"y\", \"z\"]) where it is unclear if the tuple was intended to be unpacked into x, y, and sample_weight or passed through as a single element to x . As a result the data processing code will simply raise a ValueError if it encounters a namedtuple. (Along with instructions to remedy the issue.) Returns: Type Description A History object. Its History.history attribute is a record of training loss values and metrics values at successive epochs, as well as validation loss values and validation metrics values (if applicable). Exceptions: Type Description RuntimeError If the model was never compiled or, ValueError In case of mismatch between the provided input data and what the model expects or when the input data is empty.","title":"fit()"},{"location":"api/models/TwinAutoencoder/#latent.models.twae.TwinAutoencoder.transform","text":"Map data (x) to latent space (z). Parameters: Name Type Description Default inputs A numpy array with input data. required join_output Boolean, whether to concatenate outputs. True Returns: Type Description ndarray A numpy array with the coordinates of the input data in latent space.","title":"transform()"},{"location":"api/models/VariationalAutoencoder/","text":"VariationalAutoencoder latent.models.vae.VariationalAutoencoder Variational Autoencoder base class. This model uses a fixed variational encoder to fit a posterior distribution as the latent space trough regularization by a Kullback-Leibler Divergence loss. __init__ ( self , decoder = None , name = 'variational_autoencoder' , x_dim = None , latent_dim = 50 , encoder_units = [ 128 , 128 ], decoder_units = [ 128 , 128 ], reconstruction_loss = None , use_conditions = False , kld_weight = 1e-05 , prior = 'normal' , latent_dist = 'independent' , iaf_units = [ 256 , 256 ], n_pseudoinputs = 200 , ** kwargs ) special Parameters: Name Type Description Default decoder Model Keras/tensorflow model object that inputs the latent space and outputs the reconstructed data. If not provided, a default model will be constructed from the arguments. None name str String indicating the name of the model. 'variational_autoencoder' x_dim int Integer indicating the number of features in the input data. None latent_dim int Integer indicating the number of dimensions in the latent space. 50 encoder_units Iterable[int] Integer list indicating the number of units of the encoder layers. Only used if encoder is not provided. [128, 128] decoder_units Iterable[int] An integer list indicating the number of units of the decoder layers. Only used if decoder is not provided. [128, 128] reconstruction_loss Callable Loss function applied to the reconstructed data and to be added by the decoder. Only used if decoder is not provided. Can also be added later by calling compile() . None use_conditions bool Boolean, whether to force the unpacking of conditions from the inputs. False kld_weight float Float indicating the weight of the KL Divergence regularization loss. 1e-05 prior Literal['normal', 'iaf', 'vamp'] The choice of prior distribution. One of the following: 'normal' - A unit gaussian (normal) distribution. 'iaf' - A unit gaussian with a Inverse Autoregressive Flows bijector ( Kingma 2016 ) 'vamp' - A variational mixture of posteriors (VAMP) prior ( Tomczak 2017 ) 'normal' latent_dist Literal['independent', 'multivariate'] The choice of latent distribution. One of the following: 'independent' - A independent normal produced by tfpl.IndependentNormal . 'multivariate' - A multivariate normal produced by tfpl.MultivariateNormalTriL . 'independent' iaf_units Iterable[int] Integer list indicating the units in the IAF bijector network. Only used if prior = 'iaf' . [256, 256] n_pseudoinputs int Integer indicating the number of pseudoinputs for the VAMP prior. Only used if prior = 'vamp' . 200 **kwargs Other arguments passed on to DenseStack for constructung encoder/ decoder networks. {} call ( self , inputs ) inherited Full forward pass through model compile ( self , optimizer = 'adam' , loss = None , ** kwargs ) inherited Configures the model for training. Parameters: Name Type Description Default optimizer String (name of optimizer) or optimizer instance. See tf.keras.optimizers . 'adam' loss String (name of objective function), objective function or tf.keras.losses.Loss instance. See tf.keras.losses . An objective function is any callable with the signature loss = fn(y_true, y_pred) , where y_true = ground truth values with shape = [batch_size, d0, .. dN] , except sparse loss functions such as sparse categorical crossentropy where shape = [batch_size, d0, .. dN-1] . y_pred = predicted values with shape = [batch_size, d0, .. dN] . It returns a weighted loss float tensor. If a custom Loss instance is used and reduction is set to NONE, return value has the shape [batch_size, d0, .. dN-1] ie. per-sample or per-timestep loss values; otherwise, it is a scalar. If the model has multiple outputs, you can use a different loss on each output by passing a dictionary or a list of losses. The loss value that will be minimized by the model will then be the sum of all individual losses. None metrics List of metrics to be evaluated by the model during training and testing. Each of this can be a string (name of a built-in function), function or a tf.keras.metrics.Metric instance. See tf.keras.metrics . Typically you will use metrics=['accuracy'] . A function is any callable with the signature result = fn(y_true, y_pred) . To specify different metrics for different outputs of a multi-output model, you could also pass a dictionary, such as metrics={'output_a': 'accuracy', 'output_b': ['accuracy', 'mse']} . You can also pass a list (len = len(outputs)) of lists of metrics such as metrics=[['accuracy'], ['accuracy', 'mse']] or metrics=['accuracy', ['accuracy', 'mse']] . When you pass the strings 'accuracy' or 'acc', we convert this to one of tf.keras.metrics.BinaryAccuracy , tf.keras.metrics.CategoricalAccuracy , tf.keras.metrics.SparseCategoricalAccuracy based on the loss function used and the model output shape. We do a similar conversion for the strings 'crossentropy' and 'ce' as well. required loss_weights Optional list or dictionary specifying scalar coefficients (Python floats) to weight the loss contributions of different model outputs. The loss value that will be minimized by the model will then be the weighted sum of all individual losses, weighted by the loss_weights coefficients. If a list, it is expected to have a 1:1 mapping to the model's outputs. If a dict, it is expected to map output names (strings) to scalar coefficients. required weighted_metrics List of metrics to be evaluated and weighted by sample_weight or class_weight during training and testing. required run_eagerly Bool. Defaults to False . If True , this Model 's logic will not be wrapped in a tf.function . Recommended to leave this as None unless your Model cannot be run inside a tf.function . required steps_per_execution Int. Defaults to 1. The number of batches to run during each tf.function call. Running multiple batches inside a single tf.function call can greatly improve performance on TPUs or small models with a large Python overhead. At most, one full epoch will be run each execution. If a number larger than the size of the epoch is passed, the execution will be truncated to the size of the epoch. Note that if steps_per_execution is set to N , Callback.on_batch_begin and Callback.on_batch_end methods will only be called every N batches (i.e. before/after each tf.function execution). required **kwargs Arguments supported for backwards compatibility only. {} Exceptions: Type Description ValueError In case of invalid arguments for optimizer , loss or metrics . fit ( self , x , y = None , ** kwargs ) inherited Trains the model for a fixed number of epochs (iterations on a dataset). Parameters: Name Type Description Default x Input data. It could be: - A Numpy array (or array-like), or a list of arrays (in case the model has multiple inputs). - A TensorFlow tensor, or a list of tensors (in case the model has multiple inputs). - A dict mapping input names to the corresponding array/tensors, if the model has named inputs. - A tf.data dataset. Should return a tuple of either (inputs, targets) or (inputs, targets, sample_weights) . - A generator or keras.utils.Sequence returning (inputs, targets) or (inputs, targets, sample_weights) . A more detailed description of unpacking behavior for iterator types (Dataset, generator, Sequence) is given below. required y Target data. Like the input data x , it could be either Numpy array(s) or TensorFlow tensor(s). It should be consistent with x (you cannot have Numpy inputs and tensor targets, or inversely). If x is a dataset, generator, or keras.utils.Sequence instance, y should not be specified (since targets will be obtained from x ). None batch_size Integer or None . Number of samples per gradient update. If unspecified, batch_size will default to 32. Do not specify the batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required epochs Integer. Number of epochs to train the model. An epoch is an iteration over the entire x and y data provided. Note that in conjunction with initial_epoch , epochs is to be understood as \"final epoch\". The model is not trained for a number of iterations given by epochs , but merely until the epoch of index epochs is reached. required verbose 0, 1, or 2. Verbosity mode. 0 = silent, 1 = progress bar, 2 = one line per epoch. Note that the progress bar is not particularly useful when logged to a file, so verbose=2 is recommended when not running interactively (eg, in a production environment). required callbacks List of keras.callbacks.Callback instances. List of callbacks to apply during training. See tf.keras.callbacks . Note tf.keras.callbacks.ProgbarLogger and tf.keras.callbacks.History callbacks are created automatically and need not be passed into model.fit . tf.keras.callbacks.ProgbarLogger is created or not based on verbose argument to model.fit . required validation_split Float between 0 and 1. Fraction of the training data to be used as validation data. The model will set apart this fraction of the training data, will not train on it, and will evaluate the loss and any model metrics on this data at the end of each epoch. The validation data is selected from the last samples in the x and y data provided, before shuffling. This argument is not supported when x is a dataset, generator or keras.utils.Sequence instance. required validation_data Data on which to evaluate the loss and any model metrics at the end of each epoch. The model will not be trained on this data. Thus, note the fact that the validation loss of data provided using validation_split or validation_data is not affected by regularization layers like noise and dropout. validation_data will override validation_split . validation_data could be: - tuple (x_val, y_val) of Numpy arrays or tensors - tuple (x_val, y_val, val_sample_weights) of Numpy arrays - dataset For the first two cases, batch_size must be provided. For the last case, validation_steps could be provided. Note that validation_data does not support all the data types that are supported in x , eg, dict, generator or keras.utils.Sequence . required shuffle Boolean (whether to shuffle the training data before each epoch) or str (for 'batch'). This argument is ignored when x is a generator. 'batch' is a special option for dealing with the limitations of HDF5 data; it shuffles in batch-sized chunks. Has no effect when steps_per_epoch is not None . required class_weight Optional dictionary mapping class indices (integers) to a weight (float) value, used for weighting the loss function (during training only). This can be useful to tell the model to \"pay more attention\" to samples from an under-represented class. required sample_weight Optional Numpy array of weights for the training samples, used for weighting the loss function (during training only). You can either pass a flat (1D) Numpy array with the same length as the input samples (1:1 mapping between weights and samples), or in the case of temporal data, you can pass a 2D array with shape (samples, sequence_length) , to apply a different weight to every timestep of every sample. This argument is not supported when x is a dataset, generator, or keras.utils.Sequence instance, instead provide the sample_weights as the third element of x . required initial_epoch Integer. Epoch at which to start training (useful for resuming a previous training run). required steps_per_epoch Integer or None . Total number of steps (batches of samples) before declaring one epoch finished and starting the next epoch. When training with input tensors such as TensorFlow data tensors, the default None is equal to the number of samples in your dataset divided by the batch size, or 1 if that cannot be determined. If x is a tf.data dataset, and 'steps_per_epoch' is None, the epoch will run until the input dataset is exhausted. When passing an infinitely repeating dataset, you must specify the steps_per_epoch argument. This argument is not supported with array inputs. required validation_steps Only relevant if validation_data is provided and is a tf.data dataset. Total number of steps (batches of samples) to draw before stopping when performing validation at the end of every epoch. If 'validation_steps' is None, validation will run until the validation_data dataset is exhausted. In the case of an infinitely repeated dataset, it will run into an infinite loop. If 'validation_steps' is specified and only part of the dataset will be consumed, the evaluation will start from the beginning of the dataset at each epoch. This ensures that the same validation samples are used every time. required validation_batch_size Integer or None . Number of samples per validation batch. If unspecified, will default to batch_size . Do not specify the validation_batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required validation_freq Only relevant if validation data is provided. Integer or collections_abc.Container instance (e.g. list, tuple, etc.). If an integer, specifies how many training epochs to run before a new validation run is performed, e.g. validation_freq=2 runs validation every 2 epochs. If a Container, specifies the epochs on which to run validation, e.g. validation_freq=[1, 2, 10] runs validation at the end of the 1st, 2nd, and 10th epochs. required max_queue_size Integer. Used for generator or keras.utils.Sequence input only. Maximum size for the generator queue. If unspecified, max_queue_size will default to 10. required workers Integer. Used for generator or keras.utils.Sequence input only. Maximum number of processes to spin up when using process-based threading. If unspecified, workers will default to 1. If 0, will execute the generator on the main thread. required use_multiprocessing Boolean. Used for generator or keras.utils.Sequence input only. If True , use process-based threading. If unspecified, use_multiprocessing will default to False . Note that because this implementation relies on multiprocessing, you should not pass non-picklable arguments to the generator as they can't be passed easily to children processes. required Unpacking behavior for iterator-like inputs: A common pattern is to pass a tf.data.Dataset, generator, or tf.keras.utils.Sequence to the x argument of fit, which will in fact yield not only features (x) but optionally targets (y) and sample weights. Keras requires that the output of such iterator-likes be unambiguous. The iterator should return a tuple of length 1, 2, or 3, where the optional second and third elements will be used for y and sample_weight respectively. Any other type provided will be wrapped in a length one tuple, effectively treating everything as 'x'. When yielding dicts, they should still adhere to the top-level tuple structure. e.g. ({\"x0\": x0, \"x1\": x1}, y) . Keras will not attempt to separate features, targets, and weights from the keys of a single dict. A notable unsupported data type is the namedtuple. The reason is that it behaves like both an ordered datatype (tuple) and a mapping datatype (dict). So given a namedtuple of the form: namedtuple(\"example_tuple\", [\"y\", \"x\"]) it is ambiguous whether to reverse the order of the elements when interpreting the value. Even worse is a tuple of the form: namedtuple(\"other_tuple\", [\"x\", \"y\", \"z\"]) where it is unclear if the tuple was intended to be unpacked into x, y, and sample_weight or passed through as a single element to x . As a result the data processing code will simply raise a ValueError if it encounters a namedtuple. (Along with instructions to remedy the issue.) Returns: Type Description A History object. Its History.history attribute is a record of training loss values and metrics values at successive epochs, as well as validation loss values and validation metrics values (if applicable). Exceptions: Type Description RuntimeError If the model was never compiled or, ValueError In case of mismatch between the provided input data and what the model expects or when the input data is empty. transform ( self , inputs ) inherited Map data (x) to latent space (z). Parameters: Name Type Description Default inputs A numpy array with input data. required Returns: Type Description A numpy array with the coordinates of the input data in latent space.","title":"VariationalAutoencoder"},{"location":"api/models/VariationalAutoencoder/#variationalautoencoder","text":"","title":"VariationalAutoencoder"},{"location":"api/models/VariationalAutoencoder/#latent.models.vae.VariationalAutoencoder","text":"Variational Autoencoder base class. This model uses a fixed variational encoder to fit a posterior distribution as the latent space trough regularization by a Kullback-Leibler Divergence loss.","title":"VariationalAutoencoder"},{"location":"api/models/VariationalAutoencoder/#latent.models.vae.VariationalAutoencoder.__init__","text":"Parameters: Name Type Description Default decoder Model Keras/tensorflow model object that inputs the latent space and outputs the reconstructed data. If not provided, a default model will be constructed from the arguments. None name str String indicating the name of the model. 'variational_autoencoder' x_dim int Integer indicating the number of features in the input data. None latent_dim int Integer indicating the number of dimensions in the latent space. 50 encoder_units Iterable[int] Integer list indicating the number of units of the encoder layers. Only used if encoder is not provided. [128, 128] decoder_units Iterable[int] An integer list indicating the number of units of the decoder layers. Only used if decoder is not provided. [128, 128] reconstruction_loss Callable Loss function applied to the reconstructed data and to be added by the decoder. Only used if decoder is not provided. Can also be added later by calling compile() . None use_conditions bool Boolean, whether to force the unpacking of conditions from the inputs. False kld_weight float Float indicating the weight of the KL Divergence regularization loss. 1e-05 prior Literal['normal', 'iaf', 'vamp'] The choice of prior distribution. One of the following: 'normal' - A unit gaussian (normal) distribution. 'iaf' - A unit gaussian with a Inverse Autoregressive Flows bijector ( Kingma 2016 ) 'vamp' - A variational mixture of posteriors (VAMP) prior ( Tomczak 2017 ) 'normal' latent_dist Literal['independent', 'multivariate'] The choice of latent distribution. One of the following: 'independent' - A independent normal produced by tfpl.IndependentNormal . 'multivariate' - A multivariate normal produced by tfpl.MultivariateNormalTriL . 'independent' iaf_units Iterable[int] Integer list indicating the units in the IAF bijector network. Only used if prior = 'iaf' . [256, 256] n_pseudoinputs int Integer indicating the number of pseudoinputs for the VAMP prior. Only used if prior = 'vamp' . 200 **kwargs Other arguments passed on to DenseStack for constructung encoder/ decoder networks. {}","title":"__init__()"},{"location":"api/models/VariationalAutoencoder/#latent.models.vae.VariationalAutoencoder.call","text":"Full forward pass through model","title":"call()"},{"location":"api/models/VariationalAutoencoder/#latent.models.vae.VariationalAutoencoder.compile","text":"Configures the model for training. Parameters: Name Type Description Default optimizer String (name of optimizer) or optimizer instance. See tf.keras.optimizers . 'adam' loss String (name of objective function), objective function or tf.keras.losses.Loss instance. See tf.keras.losses . An objective function is any callable with the signature loss = fn(y_true, y_pred) , where y_true = ground truth values with shape = [batch_size, d0, .. dN] , except sparse loss functions such as sparse categorical crossentropy where shape = [batch_size, d0, .. dN-1] . y_pred = predicted values with shape = [batch_size, d0, .. dN] . It returns a weighted loss float tensor. If a custom Loss instance is used and reduction is set to NONE, return value has the shape [batch_size, d0, .. dN-1] ie. per-sample or per-timestep loss values; otherwise, it is a scalar. If the model has multiple outputs, you can use a different loss on each output by passing a dictionary or a list of losses. The loss value that will be minimized by the model will then be the sum of all individual losses. None metrics List of metrics to be evaluated by the model during training and testing. Each of this can be a string (name of a built-in function), function or a tf.keras.metrics.Metric instance. See tf.keras.metrics . Typically you will use metrics=['accuracy'] . A function is any callable with the signature result = fn(y_true, y_pred) . To specify different metrics for different outputs of a multi-output model, you could also pass a dictionary, such as metrics={'output_a': 'accuracy', 'output_b': ['accuracy', 'mse']} . You can also pass a list (len = len(outputs)) of lists of metrics such as metrics=[['accuracy'], ['accuracy', 'mse']] or metrics=['accuracy', ['accuracy', 'mse']] . When you pass the strings 'accuracy' or 'acc', we convert this to one of tf.keras.metrics.BinaryAccuracy , tf.keras.metrics.CategoricalAccuracy , tf.keras.metrics.SparseCategoricalAccuracy based on the loss function used and the model output shape. We do a similar conversion for the strings 'crossentropy' and 'ce' as well. required loss_weights Optional list or dictionary specifying scalar coefficients (Python floats) to weight the loss contributions of different model outputs. The loss value that will be minimized by the model will then be the weighted sum of all individual losses, weighted by the loss_weights coefficients. If a list, it is expected to have a 1:1 mapping to the model's outputs. If a dict, it is expected to map output names (strings) to scalar coefficients. required weighted_metrics List of metrics to be evaluated and weighted by sample_weight or class_weight during training and testing. required run_eagerly Bool. Defaults to False . If True , this Model 's logic will not be wrapped in a tf.function . Recommended to leave this as None unless your Model cannot be run inside a tf.function . required steps_per_execution Int. Defaults to 1. The number of batches to run during each tf.function call. Running multiple batches inside a single tf.function call can greatly improve performance on TPUs or small models with a large Python overhead. At most, one full epoch will be run each execution. If a number larger than the size of the epoch is passed, the execution will be truncated to the size of the epoch. Note that if steps_per_execution is set to N , Callback.on_batch_begin and Callback.on_batch_end methods will only be called every N batches (i.e. before/after each tf.function execution). required **kwargs Arguments supported for backwards compatibility only. {} Exceptions: Type Description ValueError In case of invalid arguments for optimizer , loss or metrics .","title":"compile()"},{"location":"api/models/VariationalAutoencoder/#latent.models.vae.VariationalAutoencoder.fit","text":"Trains the model for a fixed number of epochs (iterations on a dataset). Parameters: Name Type Description Default x Input data. It could be: - A Numpy array (or array-like), or a list of arrays (in case the model has multiple inputs). - A TensorFlow tensor, or a list of tensors (in case the model has multiple inputs). - A dict mapping input names to the corresponding array/tensors, if the model has named inputs. - A tf.data dataset. Should return a tuple of either (inputs, targets) or (inputs, targets, sample_weights) . - A generator or keras.utils.Sequence returning (inputs, targets) or (inputs, targets, sample_weights) . A more detailed description of unpacking behavior for iterator types (Dataset, generator, Sequence) is given below. required y Target data. Like the input data x , it could be either Numpy array(s) or TensorFlow tensor(s). It should be consistent with x (you cannot have Numpy inputs and tensor targets, or inversely). If x is a dataset, generator, or keras.utils.Sequence instance, y should not be specified (since targets will be obtained from x ). None batch_size Integer or None . Number of samples per gradient update. If unspecified, batch_size will default to 32. Do not specify the batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required epochs Integer. Number of epochs to train the model. An epoch is an iteration over the entire x and y data provided. Note that in conjunction with initial_epoch , epochs is to be understood as \"final epoch\". The model is not trained for a number of iterations given by epochs , but merely until the epoch of index epochs is reached. required verbose 0, 1, or 2. Verbosity mode. 0 = silent, 1 = progress bar, 2 = one line per epoch. Note that the progress bar is not particularly useful when logged to a file, so verbose=2 is recommended when not running interactively (eg, in a production environment). required callbacks List of keras.callbacks.Callback instances. List of callbacks to apply during training. See tf.keras.callbacks . Note tf.keras.callbacks.ProgbarLogger and tf.keras.callbacks.History callbacks are created automatically and need not be passed into model.fit . tf.keras.callbacks.ProgbarLogger is created or not based on verbose argument to model.fit . required validation_split Float between 0 and 1. Fraction of the training data to be used as validation data. The model will set apart this fraction of the training data, will not train on it, and will evaluate the loss and any model metrics on this data at the end of each epoch. The validation data is selected from the last samples in the x and y data provided, before shuffling. This argument is not supported when x is a dataset, generator or keras.utils.Sequence instance. required validation_data Data on which to evaluate the loss and any model metrics at the end of each epoch. The model will not be trained on this data. Thus, note the fact that the validation loss of data provided using validation_split or validation_data is not affected by regularization layers like noise and dropout. validation_data will override validation_split . validation_data could be: - tuple (x_val, y_val) of Numpy arrays or tensors - tuple (x_val, y_val, val_sample_weights) of Numpy arrays - dataset For the first two cases, batch_size must be provided. For the last case, validation_steps could be provided. Note that validation_data does not support all the data types that are supported in x , eg, dict, generator or keras.utils.Sequence . required shuffle Boolean (whether to shuffle the training data before each epoch) or str (for 'batch'). This argument is ignored when x is a generator. 'batch' is a special option for dealing with the limitations of HDF5 data; it shuffles in batch-sized chunks. Has no effect when steps_per_epoch is not None . required class_weight Optional dictionary mapping class indices (integers) to a weight (float) value, used for weighting the loss function (during training only). This can be useful to tell the model to \"pay more attention\" to samples from an under-represented class. required sample_weight Optional Numpy array of weights for the training samples, used for weighting the loss function (during training only). You can either pass a flat (1D) Numpy array with the same length as the input samples (1:1 mapping between weights and samples), or in the case of temporal data, you can pass a 2D array with shape (samples, sequence_length) , to apply a different weight to every timestep of every sample. This argument is not supported when x is a dataset, generator, or keras.utils.Sequence instance, instead provide the sample_weights as the third element of x . required initial_epoch Integer. Epoch at which to start training (useful for resuming a previous training run). required steps_per_epoch Integer or None . Total number of steps (batches of samples) before declaring one epoch finished and starting the next epoch. When training with input tensors such as TensorFlow data tensors, the default None is equal to the number of samples in your dataset divided by the batch size, or 1 if that cannot be determined. If x is a tf.data dataset, and 'steps_per_epoch' is None, the epoch will run until the input dataset is exhausted. When passing an infinitely repeating dataset, you must specify the steps_per_epoch argument. This argument is not supported with array inputs. required validation_steps Only relevant if validation_data is provided and is a tf.data dataset. Total number of steps (batches of samples) to draw before stopping when performing validation at the end of every epoch. If 'validation_steps' is None, validation will run until the validation_data dataset is exhausted. In the case of an infinitely repeated dataset, it will run into an infinite loop. If 'validation_steps' is specified and only part of the dataset will be consumed, the evaluation will start from the beginning of the dataset at each epoch. This ensures that the same validation samples are used every time. required validation_batch_size Integer or None . Number of samples per validation batch. If unspecified, will default to batch_size . Do not specify the validation_batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required validation_freq Only relevant if validation data is provided. Integer or collections_abc.Container instance (e.g. list, tuple, etc.). If an integer, specifies how many training epochs to run before a new validation run is performed, e.g. validation_freq=2 runs validation every 2 epochs. If a Container, specifies the epochs on which to run validation, e.g. validation_freq=[1, 2, 10] runs validation at the end of the 1st, 2nd, and 10th epochs. required max_queue_size Integer. Used for generator or keras.utils.Sequence input only. Maximum size for the generator queue. If unspecified, max_queue_size will default to 10. required workers Integer. Used for generator or keras.utils.Sequence input only. Maximum number of processes to spin up when using process-based threading. If unspecified, workers will default to 1. If 0, will execute the generator on the main thread. required use_multiprocessing Boolean. Used for generator or keras.utils.Sequence input only. If True , use process-based threading. If unspecified, use_multiprocessing will default to False . Note that because this implementation relies on multiprocessing, you should not pass non-picklable arguments to the generator as they can't be passed easily to children processes. required Unpacking behavior for iterator-like inputs: A common pattern is to pass a tf.data.Dataset, generator, or tf.keras.utils.Sequence to the x argument of fit, which will in fact yield not only features (x) but optionally targets (y) and sample weights. Keras requires that the output of such iterator-likes be unambiguous. The iterator should return a tuple of length 1, 2, or 3, where the optional second and third elements will be used for y and sample_weight respectively. Any other type provided will be wrapped in a length one tuple, effectively treating everything as 'x'. When yielding dicts, they should still adhere to the top-level tuple structure. e.g. ({\"x0\": x0, \"x1\": x1}, y) . Keras will not attempt to separate features, targets, and weights from the keys of a single dict. A notable unsupported data type is the namedtuple. The reason is that it behaves like both an ordered datatype (tuple) and a mapping datatype (dict). So given a namedtuple of the form: namedtuple(\"example_tuple\", [\"y\", \"x\"]) it is ambiguous whether to reverse the order of the elements when interpreting the value. Even worse is a tuple of the form: namedtuple(\"other_tuple\", [\"x\", \"y\", \"z\"]) where it is unclear if the tuple was intended to be unpacked into x, y, and sample_weight or passed through as a single element to x . As a result the data processing code will simply raise a ValueError if it encounters a namedtuple. (Along with instructions to remedy the issue.) Returns: Type Description A History object. Its History.history attribute is a record of training loss values and metrics values at successive epochs, as well as validation loss values and validation metrics values (if applicable). Exceptions: Type Description RuntimeError If the model was never compiled or, ValueError In case of mismatch between the provided input data and what the model expects or when the input data is empty.","title":"fit()"},{"location":"api/models/VariationalAutoencoder/#latent.models.vae.VariationalAutoencoder.transform","text":"Map data (x) to latent space (z). Parameters: Name Type Description Default inputs A numpy array with input data. required Returns: Type Description A numpy array with the coordinates of the input data in latent space.","title":"transform()"},{"location":"api/models/ZINBAutoencoder/","text":"ZINBAutoencoder latent.models.ae.ZINBAutoencoder Autoencoder with zero-inflated negative binomial (ZINB) decoder and reconstruction loss. __init__ ( self , encoder = None , name = 'zinb_autoencoder' , x_dim = None , latent_dim = 50 , encoder_units = [ 128 , 128 ], decoder_units = [ 128 , 128 ], use_conditions = False , dispersion = 'constant' , ** kwargs ) special Parameters: Name Type Description Default encoder Model Keras/tensorflow model object that inputs the data and outputs the latent space. If not provided, a default model will be constructed from the arguments. None name str String indicating the name of the model. 'zinb_autoencoder' x_dim int Integer indicating the number of features in the input data. None latent_dim int Integer indicating the number of dimensions in the latent space. 50 encoder_units Iterable[int] Integer list indicating the number of units of the encoder layers. Only used if encoder is not provided. [128, 128] decoder_units Iterable[int] An integer list indicating the number of units of the decoder layers. Only used if decoder is not provided. [128, 128] use_conditions bool Boolean, whether to force the unpacking of conditions from the inputs. False dispersion Union[Literal['gene', 'cell-gene', 'constant'], float] One of the following: 'gene' - dispersion parameter of NB is constant per gene across cells 'cell-gene' - dispersion can differ for every gene in every cell 'constant' - dispersion is constant across all genes and cells float - numeric value of fixed dispersion parameter 'constant' **kwargs Other arguments passed on to DenseStack for constructung encoder/decoder networks. {} call ( self , inputs ) inherited Full forward pass through model compile ( self , optimizer = 'adam' , loss = None , ** kwargs ) inherited Configures the model for training. Parameters: Name Type Description Default optimizer String (name of optimizer) or optimizer instance. See tf.keras.optimizers . 'adam' loss String (name of objective function), objective function or tf.keras.losses.Loss instance. See tf.keras.losses . An objective function is any callable with the signature loss = fn(y_true, y_pred) , where y_true = ground truth values with shape = [batch_size, d0, .. dN] , except sparse loss functions such as sparse categorical crossentropy where shape = [batch_size, d0, .. dN-1] . y_pred = predicted values with shape = [batch_size, d0, .. dN] . It returns a weighted loss float tensor. If a custom Loss instance is used and reduction is set to NONE, return value has the shape [batch_size, d0, .. dN-1] ie. per-sample or per-timestep loss values; otherwise, it is a scalar. If the model has multiple outputs, you can use a different loss on each output by passing a dictionary or a list of losses. The loss value that will be minimized by the model will then be the sum of all individual losses. None metrics List of metrics to be evaluated by the model during training and testing. Each of this can be a string (name of a built-in function), function or a tf.keras.metrics.Metric instance. See tf.keras.metrics . Typically you will use metrics=['accuracy'] . A function is any callable with the signature result = fn(y_true, y_pred) . To specify different metrics for different outputs of a multi-output model, you could also pass a dictionary, such as metrics={'output_a': 'accuracy', 'output_b': ['accuracy', 'mse']} . You can also pass a list (len = len(outputs)) of lists of metrics such as metrics=[['accuracy'], ['accuracy', 'mse']] or metrics=['accuracy', ['accuracy', 'mse']] . When you pass the strings 'accuracy' or 'acc', we convert this to one of tf.keras.metrics.BinaryAccuracy , tf.keras.metrics.CategoricalAccuracy , tf.keras.metrics.SparseCategoricalAccuracy based on the loss function used and the model output shape. We do a similar conversion for the strings 'crossentropy' and 'ce' as well. required loss_weights Optional list or dictionary specifying scalar coefficients (Python floats) to weight the loss contributions of different model outputs. The loss value that will be minimized by the model will then be the weighted sum of all individual losses, weighted by the loss_weights coefficients. If a list, it is expected to have a 1:1 mapping to the model's outputs. If a dict, it is expected to map output names (strings) to scalar coefficients. required weighted_metrics List of metrics to be evaluated and weighted by sample_weight or class_weight during training and testing. required run_eagerly Bool. Defaults to False . If True , this Model 's logic will not be wrapped in a tf.function . Recommended to leave this as None unless your Model cannot be run inside a tf.function . required steps_per_execution Int. Defaults to 1. The number of batches to run during each tf.function call. Running multiple batches inside a single tf.function call can greatly improve performance on TPUs or small models with a large Python overhead. At most, one full epoch will be run each execution. If a number larger than the size of the epoch is passed, the execution will be truncated to the size of the epoch. Note that if steps_per_execution is set to N , Callback.on_batch_begin and Callback.on_batch_end methods will only be called every N batches (i.e. before/after each tf.function execution). required **kwargs Arguments supported for backwards compatibility only. {} Exceptions: Type Description ValueError In case of invalid arguments for optimizer , loss or metrics . fit ( self , x , y = None , ** kwargs ) inherited Trains the model for a fixed number of epochs (iterations on a dataset). Parameters: Name Type Description Default x Input data. It could be: - A Numpy array (or array-like), or a list of arrays (in case the model has multiple inputs). - A TensorFlow tensor, or a list of tensors (in case the model has multiple inputs). - A dict mapping input names to the corresponding array/tensors, if the model has named inputs. - A tf.data dataset. Should return a tuple of either (inputs, targets) or (inputs, targets, sample_weights) . - A generator or keras.utils.Sequence returning (inputs, targets) or (inputs, targets, sample_weights) . A more detailed description of unpacking behavior for iterator types (Dataset, generator, Sequence) is given below. required y Target data. Like the input data x , it could be either Numpy array(s) or TensorFlow tensor(s). It should be consistent with x (you cannot have Numpy inputs and tensor targets, or inversely). If x is a dataset, generator, or keras.utils.Sequence instance, y should not be specified (since targets will be obtained from x ). None batch_size Integer or None . Number of samples per gradient update. If unspecified, batch_size will default to 32. Do not specify the batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required epochs Integer. Number of epochs to train the model. An epoch is an iteration over the entire x and y data provided. Note that in conjunction with initial_epoch , epochs is to be understood as \"final epoch\". The model is not trained for a number of iterations given by epochs , but merely until the epoch of index epochs is reached. required verbose 0, 1, or 2. Verbosity mode. 0 = silent, 1 = progress bar, 2 = one line per epoch. Note that the progress bar is not particularly useful when logged to a file, so verbose=2 is recommended when not running interactively (eg, in a production environment). required callbacks List of keras.callbacks.Callback instances. List of callbacks to apply during training. See tf.keras.callbacks . Note tf.keras.callbacks.ProgbarLogger and tf.keras.callbacks.History callbacks are created automatically and need not be passed into model.fit . tf.keras.callbacks.ProgbarLogger is created or not based on verbose argument to model.fit . required validation_split Float between 0 and 1. Fraction of the training data to be used as validation data. The model will set apart this fraction of the training data, will not train on it, and will evaluate the loss and any model metrics on this data at the end of each epoch. The validation data is selected from the last samples in the x and y data provided, before shuffling. This argument is not supported when x is a dataset, generator or keras.utils.Sequence instance. required validation_data Data on which to evaluate the loss and any model metrics at the end of each epoch. The model will not be trained on this data. Thus, note the fact that the validation loss of data provided using validation_split or validation_data is not affected by regularization layers like noise and dropout. validation_data will override validation_split . validation_data could be: - tuple (x_val, y_val) of Numpy arrays or tensors - tuple (x_val, y_val, val_sample_weights) of Numpy arrays - dataset For the first two cases, batch_size must be provided. For the last case, validation_steps could be provided. Note that validation_data does not support all the data types that are supported in x , eg, dict, generator or keras.utils.Sequence . required shuffle Boolean (whether to shuffle the training data before each epoch) or str (for 'batch'). This argument is ignored when x is a generator. 'batch' is a special option for dealing with the limitations of HDF5 data; it shuffles in batch-sized chunks. Has no effect when steps_per_epoch is not None . required class_weight Optional dictionary mapping class indices (integers) to a weight (float) value, used for weighting the loss function (during training only). This can be useful to tell the model to \"pay more attention\" to samples from an under-represented class. required sample_weight Optional Numpy array of weights for the training samples, used for weighting the loss function (during training only). You can either pass a flat (1D) Numpy array with the same length as the input samples (1:1 mapping between weights and samples), or in the case of temporal data, you can pass a 2D array with shape (samples, sequence_length) , to apply a different weight to every timestep of every sample. This argument is not supported when x is a dataset, generator, or keras.utils.Sequence instance, instead provide the sample_weights as the third element of x . required initial_epoch Integer. Epoch at which to start training (useful for resuming a previous training run). required steps_per_epoch Integer or None . Total number of steps (batches of samples) before declaring one epoch finished and starting the next epoch. When training with input tensors such as TensorFlow data tensors, the default None is equal to the number of samples in your dataset divided by the batch size, or 1 if that cannot be determined. If x is a tf.data dataset, and 'steps_per_epoch' is None, the epoch will run until the input dataset is exhausted. When passing an infinitely repeating dataset, you must specify the steps_per_epoch argument. This argument is not supported with array inputs. required validation_steps Only relevant if validation_data is provided and is a tf.data dataset. Total number of steps (batches of samples) to draw before stopping when performing validation at the end of every epoch. If 'validation_steps' is None, validation will run until the validation_data dataset is exhausted. In the case of an infinitely repeated dataset, it will run into an infinite loop. If 'validation_steps' is specified and only part of the dataset will be consumed, the evaluation will start from the beginning of the dataset at each epoch. This ensures that the same validation samples are used every time. required validation_batch_size Integer or None . Number of samples per validation batch. If unspecified, will default to batch_size . Do not specify the validation_batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required validation_freq Only relevant if validation data is provided. Integer or collections_abc.Container instance (e.g. list, tuple, etc.). If an integer, specifies how many training epochs to run before a new validation run is performed, e.g. validation_freq=2 runs validation every 2 epochs. If a Container, specifies the epochs on which to run validation, e.g. validation_freq=[1, 2, 10] runs validation at the end of the 1st, 2nd, and 10th epochs. required max_queue_size Integer. Used for generator or keras.utils.Sequence input only. Maximum size for the generator queue. If unspecified, max_queue_size will default to 10. required workers Integer. Used for generator or keras.utils.Sequence input only. Maximum number of processes to spin up when using process-based threading. If unspecified, workers will default to 1. If 0, will execute the generator on the main thread. required use_multiprocessing Boolean. Used for generator or keras.utils.Sequence input only. If True , use process-based threading. If unspecified, use_multiprocessing will default to False . Note that because this implementation relies on multiprocessing, you should not pass non-picklable arguments to the generator as they can't be passed easily to children processes. required Unpacking behavior for iterator-like inputs: A common pattern is to pass a tf.data.Dataset, generator, or tf.keras.utils.Sequence to the x argument of fit, which will in fact yield not only features (x) but optionally targets (y) and sample weights. Keras requires that the output of such iterator-likes be unambiguous. The iterator should return a tuple of length 1, 2, or 3, where the optional second and third elements will be used for y and sample_weight respectively. Any other type provided will be wrapped in a length one tuple, effectively treating everything as 'x'. When yielding dicts, they should still adhere to the top-level tuple structure. e.g. ({\"x0\": x0, \"x1\": x1}, y) . Keras will not attempt to separate features, targets, and weights from the keys of a single dict. A notable unsupported data type is the namedtuple. The reason is that it behaves like both an ordered datatype (tuple) and a mapping datatype (dict). So given a namedtuple of the form: namedtuple(\"example_tuple\", [\"y\", \"x\"]) it is ambiguous whether to reverse the order of the elements when interpreting the value. Even worse is a tuple of the form: namedtuple(\"other_tuple\", [\"x\", \"y\", \"z\"]) where it is unclear if the tuple was intended to be unpacked into x, y, and sample_weight or passed through as a single element to x . As a result the data processing code will simply raise a ValueError if it encounters a namedtuple. (Along with instructions to remedy the issue.) Returns: Type Description A History object. Its History.history attribute is a record of training loss values and metrics values at successive epochs, as well as validation loss values and validation metrics values (if applicable). Exceptions: Type Description RuntimeError If the model was never compiled or, ValueError In case of mismatch between the provided input data and what the model expects or when the input data is empty. transform ( self , inputs ) inherited Map data (x) to latent space (z). Parameters: Name Type Description Default inputs A numpy array with input data. required Returns: Type Description A numpy array with the coordinates of the input data in latent space.","title":"ZINBAutoencoder"},{"location":"api/models/ZINBAutoencoder/#zinbautoencoder","text":"","title":"ZINBAutoencoder"},{"location":"api/models/ZINBAutoencoder/#latent.models.ae.ZINBAutoencoder","text":"Autoencoder with zero-inflated negative binomial (ZINB) decoder and reconstruction loss.","title":"ZINBAutoencoder"},{"location":"api/models/ZINBAutoencoder/#latent.models.ae.ZINBAutoencoder.__init__","text":"Parameters: Name Type Description Default encoder Model Keras/tensorflow model object that inputs the data and outputs the latent space. If not provided, a default model will be constructed from the arguments. None name str String indicating the name of the model. 'zinb_autoencoder' x_dim int Integer indicating the number of features in the input data. None latent_dim int Integer indicating the number of dimensions in the latent space. 50 encoder_units Iterable[int] Integer list indicating the number of units of the encoder layers. Only used if encoder is not provided. [128, 128] decoder_units Iterable[int] An integer list indicating the number of units of the decoder layers. Only used if decoder is not provided. [128, 128] use_conditions bool Boolean, whether to force the unpacking of conditions from the inputs. False dispersion Union[Literal['gene', 'cell-gene', 'constant'], float] One of the following: 'gene' - dispersion parameter of NB is constant per gene across cells 'cell-gene' - dispersion can differ for every gene in every cell 'constant' - dispersion is constant across all genes and cells float - numeric value of fixed dispersion parameter 'constant' **kwargs Other arguments passed on to DenseStack for constructung encoder/decoder networks. {}","title":"__init__()"},{"location":"api/models/ZINBAutoencoder/#latent.models.ae.ZINBAutoencoder.call","text":"Full forward pass through model","title":"call()"},{"location":"api/models/ZINBAutoencoder/#latent.models.ae.ZINBAutoencoder.compile","text":"Configures the model for training. Parameters: Name Type Description Default optimizer String (name of optimizer) or optimizer instance. See tf.keras.optimizers . 'adam' loss String (name of objective function), objective function or tf.keras.losses.Loss instance. See tf.keras.losses . An objective function is any callable with the signature loss = fn(y_true, y_pred) , where y_true = ground truth values with shape = [batch_size, d0, .. dN] , except sparse loss functions such as sparse categorical crossentropy where shape = [batch_size, d0, .. dN-1] . y_pred = predicted values with shape = [batch_size, d0, .. dN] . It returns a weighted loss float tensor. If a custom Loss instance is used and reduction is set to NONE, return value has the shape [batch_size, d0, .. dN-1] ie. per-sample or per-timestep loss values; otherwise, it is a scalar. If the model has multiple outputs, you can use a different loss on each output by passing a dictionary or a list of losses. The loss value that will be minimized by the model will then be the sum of all individual losses. None metrics List of metrics to be evaluated by the model during training and testing. Each of this can be a string (name of a built-in function), function or a tf.keras.metrics.Metric instance. See tf.keras.metrics . Typically you will use metrics=['accuracy'] . A function is any callable with the signature result = fn(y_true, y_pred) . To specify different metrics for different outputs of a multi-output model, you could also pass a dictionary, such as metrics={'output_a': 'accuracy', 'output_b': ['accuracy', 'mse']} . You can also pass a list (len = len(outputs)) of lists of metrics such as metrics=[['accuracy'], ['accuracy', 'mse']] or metrics=['accuracy', ['accuracy', 'mse']] . When you pass the strings 'accuracy' or 'acc', we convert this to one of tf.keras.metrics.BinaryAccuracy , tf.keras.metrics.CategoricalAccuracy , tf.keras.metrics.SparseCategoricalAccuracy based on the loss function used and the model output shape. We do a similar conversion for the strings 'crossentropy' and 'ce' as well. required loss_weights Optional list or dictionary specifying scalar coefficients (Python floats) to weight the loss contributions of different model outputs. The loss value that will be minimized by the model will then be the weighted sum of all individual losses, weighted by the loss_weights coefficients. If a list, it is expected to have a 1:1 mapping to the model's outputs. If a dict, it is expected to map output names (strings) to scalar coefficients. required weighted_metrics List of metrics to be evaluated and weighted by sample_weight or class_weight during training and testing. required run_eagerly Bool. Defaults to False . If True , this Model 's logic will not be wrapped in a tf.function . Recommended to leave this as None unless your Model cannot be run inside a tf.function . required steps_per_execution Int. Defaults to 1. The number of batches to run during each tf.function call. Running multiple batches inside a single tf.function call can greatly improve performance on TPUs or small models with a large Python overhead. At most, one full epoch will be run each execution. If a number larger than the size of the epoch is passed, the execution will be truncated to the size of the epoch. Note that if steps_per_execution is set to N , Callback.on_batch_begin and Callback.on_batch_end methods will only be called every N batches (i.e. before/after each tf.function execution). required **kwargs Arguments supported for backwards compatibility only. {} Exceptions: Type Description ValueError In case of invalid arguments for optimizer , loss or metrics .","title":"compile()"},{"location":"api/models/ZINBAutoencoder/#latent.models.ae.ZINBAutoencoder.fit","text":"Trains the model for a fixed number of epochs (iterations on a dataset). Parameters: Name Type Description Default x Input data. It could be: - A Numpy array (or array-like), or a list of arrays (in case the model has multiple inputs). - A TensorFlow tensor, or a list of tensors (in case the model has multiple inputs). - A dict mapping input names to the corresponding array/tensors, if the model has named inputs. - A tf.data dataset. Should return a tuple of either (inputs, targets) or (inputs, targets, sample_weights) . - A generator or keras.utils.Sequence returning (inputs, targets) or (inputs, targets, sample_weights) . A more detailed description of unpacking behavior for iterator types (Dataset, generator, Sequence) is given below. required y Target data. Like the input data x , it could be either Numpy array(s) or TensorFlow tensor(s). It should be consistent with x (you cannot have Numpy inputs and tensor targets, or inversely). If x is a dataset, generator, or keras.utils.Sequence instance, y should not be specified (since targets will be obtained from x ). None batch_size Integer or None . Number of samples per gradient update. If unspecified, batch_size will default to 32. Do not specify the batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required epochs Integer. Number of epochs to train the model. An epoch is an iteration over the entire x and y data provided. Note that in conjunction with initial_epoch , epochs is to be understood as \"final epoch\". The model is not trained for a number of iterations given by epochs , but merely until the epoch of index epochs is reached. required verbose 0, 1, or 2. Verbosity mode. 0 = silent, 1 = progress bar, 2 = one line per epoch. Note that the progress bar is not particularly useful when logged to a file, so verbose=2 is recommended when not running interactively (eg, in a production environment). required callbacks List of keras.callbacks.Callback instances. List of callbacks to apply during training. See tf.keras.callbacks . Note tf.keras.callbacks.ProgbarLogger and tf.keras.callbacks.History callbacks are created automatically and need not be passed into model.fit . tf.keras.callbacks.ProgbarLogger is created or not based on verbose argument to model.fit . required validation_split Float between 0 and 1. Fraction of the training data to be used as validation data. The model will set apart this fraction of the training data, will not train on it, and will evaluate the loss and any model metrics on this data at the end of each epoch. The validation data is selected from the last samples in the x and y data provided, before shuffling. This argument is not supported when x is a dataset, generator or keras.utils.Sequence instance. required validation_data Data on which to evaluate the loss and any model metrics at the end of each epoch. The model will not be trained on this data. Thus, note the fact that the validation loss of data provided using validation_split or validation_data is not affected by regularization layers like noise and dropout. validation_data will override validation_split . validation_data could be: - tuple (x_val, y_val) of Numpy arrays or tensors - tuple (x_val, y_val, val_sample_weights) of Numpy arrays - dataset For the first two cases, batch_size must be provided. For the last case, validation_steps could be provided. Note that validation_data does not support all the data types that are supported in x , eg, dict, generator or keras.utils.Sequence . required shuffle Boolean (whether to shuffle the training data before each epoch) or str (for 'batch'). This argument is ignored when x is a generator. 'batch' is a special option for dealing with the limitations of HDF5 data; it shuffles in batch-sized chunks. Has no effect when steps_per_epoch is not None . required class_weight Optional dictionary mapping class indices (integers) to a weight (float) value, used for weighting the loss function (during training only). This can be useful to tell the model to \"pay more attention\" to samples from an under-represented class. required sample_weight Optional Numpy array of weights for the training samples, used for weighting the loss function (during training only). You can either pass a flat (1D) Numpy array with the same length as the input samples (1:1 mapping between weights and samples), or in the case of temporal data, you can pass a 2D array with shape (samples, sequence_length) , to apply a different weight to every timestep of every sample. This argument is not supported when x is a dataset, generator, or keras.utils.Sequence instance, instead provide the sample_weights as the third element of x . required initial_epoch Integer. Epoch at which to start training (useful for resuming a previous training run). required steps_per_epoch Integer or None . Total number of steps (batches of samples) before declaring one epoch finished and starting the next epoch. When training with input tensors such as TensorFlow data tensors, the default None is equal to the number of samples in your dataset divided by the batch size, or 1 if that cannot be determined. If x is a tf.data dataset, and 'steps_per_epoch' is None, the epoch will run until the input dataset is exhausted. When passing an infinitely repeating dataset, you must specify the steps_per_epoch argument. This argument is not supported with array inputs. required validation_steps Only relevant if validation_data is provided and is a tf.data dataset. Total number of steps (batches of samples) to draw before stopping when performing validation at the end of every epoch. If 'validation_steps' is None, validation will run until the validation_data dataset is exhausted. In the case of an infinitely repeated dataset, it will run into an infinite loop. If 'validation_steps' is specified and only part of the dataset will be consumed, the evaluation will start from the beginning of the dataset at each epoch. This ensures that the same validation samples are used every time. required validation_batch_size Integer or None . Number of samples per validation batch. If unspecified, will default to batch_size . Do not specify the validation_batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required validation_freq Only relevant if validation data is provided. Integer or collections_abc.Container instance (e.g. list, tuple, etc.). If an integer, specifies how many training epochs to run before a new validation run is performed, e.g. validation_freq=2 runs validation every 2 epochs. If a Container, specifies the epochs on which to run validation, e.g. validation_freq=[1, 2, 10] runs validation at the end of the 1st, 2nd, and 10th epochs. required max_queue_size Integer. Used for generator or keras.utils.Sequence input only. Maximum size for the generator queue. If unspecified, max_queue_size will default to 10. required workers Integer. Used for generator or keras.utils.Sequence input only. Maximum number of processes to spin up when using process-based threading. If unspecified, workers will default to 1. If 0, will execute the generator on the main thread. required use_multiprocessing Boolean. Used for generator or keras.utils.Sequence input only. If True , use process-based threading. If unspecified, use_multiprocessing will default to False . Note that because this implementation relies on multiprocessing, you should not pass non-picklable arguments to the generator as they can't be passed easily to children processes. required Unpacking behavior for iterator-like inputs: A common pattern is to pass a tf.data.Dataset, generator, or tf.keras.utils.Sequence to the x argument of fit, which will in fact yield not only features (x) but optionally targets (y) and sample weights. Keras requires that the output of such iterator-likes be unambiguous. The iterator should return a tuple of length 1, 2, or 3, where the optional second and third elements will be used for y and sample_weight respectively. Any other type provided will be wrapped in a length one tuple, effectively treating everything as 'x'. When yielding dicts, they should still adhere to the top-level tuple structure. e.g. ({\"x0\": x0, \"x1\": x1}, y) . Keras will not attempt to separate features, targets, and weights from the keys of a single dict. A notable unsupported data type is the namedtuple. The reason is that it behaves like both an ordered datatype (tuple) and a mapping datatype (dict). So given a namedtuple of the form: namedtuple(\"example_tuple\", [\"y\", \"x\"]) it is ambiguous whether to reverse the order of the elements when interpreting the value. Even worse is a tuple of the form: namedtuple(\"other_tuple\", [\"x\", \"y\", \"z\"]) where it is unclear if the tuple was intended to be unpacked into x, y, and sample_weight or passed through as a single element to x . As a result the data processing code will simply raise a ValueError if it encounters a namedtuple. (Along with instructions to remedy the issue.) Returns: Type Description A History object. Its History.history attribute is a record of training loss values and metrics values at successive epochs, as well as validation loss values and validation metrics values (if applicable). Exceptions: Type Description RuntimeError If the model was never compiled or, ValueError In case of mismatch between the provided input data and what the model expects or when the input data is empty.","title":"fit()"},{"location":"api/models/ZINBAutoencoder/#latent.models.ae.ZINBAutoencoder.transform","text":"Map data (x) to latent space (z). Parameters: Name Type Description Default inputs A numpy array with input data. required Returns: Type Description A numpy array with the coordinates of the input data in latent space.","title":"transform()"},{"location":"api/models/ZINBVAE/","text":"ZINBVAE latent.models.vae.ZINBVAE Zero-inflated negative binomial variational autoencoder with fixed variational encoder and ZINB decoder networks. __init__ ( self , name = 'nb_vae' , x_dim = None , latent_dim = 50 , encoder_units = [ 128 , 128 ], decoder_units = [ 128 , 128 ], reconstruction_loss = None , use_conditions = False , dispersion = 'constant' , kld_weight = 1e-05 , prior = 'normal' , latent_dist = 'independent' , iaf_units = [ 256 , 256 ], n_pseudoinputs = 200 , ** kwargs ) special Parameters: Name Type Description Default decoder Keras/tensorflow model object that inputs the latent space and outputs the reconstructed data. If not provided, a default model will be constructed from the arguments. required name str String indicating the name of the model. 'nb_vae' x_dim int Integer indicating the number of features in the input data. None latent_dim int Integer indicating the number of dimensions in the latent space. 50 encoder_units Iterable[int] Integer list indicating the number of units of the encoder layers. Only used if encoder is not provided. [128, 128] decoder_units Iterable[int] An integer list indicating the number of units of the decoder layers. Only used if decoder is not provided. [128, 128] reconstruction_loss Callable Loss function applied to the reconstructed data and to be added by the decoder. Only used if decoder is not provided. Can also be added later by calling compile() . None use_conditions bool Boolean, whether to force the unpacking of conditions from the inputs. False dispersion Union[Literal['gene', 'cell-gene', 'constant'], float] One of the following: 'gene' - dispersion parameter of NB is constant per gene across cells 'cell-gene' - dispersion can differ for every gene in every cell 'constant' - dispersion is constant across all genes and cells float - numeric value of fixed dispersion parameter 'constant' kld_weight float Float indicating the weight of the KL Divergence regularization loss. 1e-05 prior Literal['normal', 'iaf', 'vamp'] The choice of prior distribution. One of the following: 'normal' - A unit gaussian (normal) distribution. 'iaf' - A unit gaussian with a Inverse Autoregressive Flows bijector ( Kingma 2016 ) 'vamp' - A variational mixture of posteriors (VAMP) prior ( Tomczak 2017 ) 'normal' latent_dist Literal['independent', 'multivariate'] The choice of latent distribution. One of the following: 'independent' - A independent normal produced by tfpl.IndependentNormal . 'multivariate' - A multivariate normal produced by tfpl.MultivariateNormalTriL . 'independent' iaf_units Iterable[int] Integer list indicating the units in the IAF bijector network. Only used if prior = 'iaf' . [256, 256] n_pseudoinputs int Integer indicating the number of pseudoinputs for the VAMP prior. Only used if prior = 'vamp' . 200 **kwargs Other arguments passed on to DenseStack for constructung encoder/ decoder networks. {} call ( self , inputs ) inherited Full forward pass through model compile ( self , optimizer = 'adam' , loss = None , ** kwargs ) inherited Configures the model for training. Parameters: Name Type Description Default optimizer String (name of optimizer) or optimizer instance. See tf.keras.optimizers . 'adam' loss String (name of objective function), objective function or tf.keras.losses.Loss instance. See tf.keras.losses . An objective function is any callable with the signature loss = fn(y_true, y_pred) , where y_true = ground truth values with shape = [batch_size, d0, .. dN] , except sparse loss functions such as sparse categorical crossentropy where shape = [batch_size, d0, .. dN-1] . y_pred = predicted values with shape = [batch_size, d0, .. dN] . It returns a weighted loss float tensor. If a custom Loss instance is used and reduction is set to NONE, return value has the shape [batch_size, d0, .. dN-1] ie. per-sample or per-timestep loss values; otherwise, it is a scalar. If the model has multiple outputs, you can use a different loss on each output by passing a dictionary or a list of losses. The loss value that will be minimized by the model will then be the sum of all individual losses. None metrics List of metrics to be evaluated by the model during training and testing. Each of this can be a string (name of a built-in function), function or a tf.keras.metrics.Metric instance. See tf.keras.metrics . Typically you will use metrics=['accuracy'] . A function is any callable with the signature result = fn(y_true, y_pred) . To specify different metrics for different outputs of a multi-output model, you could also pass a dictionary, such as metrics={'output_a': 'accuracy', 'output_b': ['accuracy', 'mse']} . You can also pass a list (len = len(outputs)) of lists of metrics such as metrics=[['accuracy'], ['accuracy', 'mse']] or metrics=['accuracy', ['accuracy', 'mse']] . When you pass the strings 'accuracy' or 'acc', we convert this to one of tf.keras.metrics.BinaryAccuracy , tf.keras.metrics.CategoricalAccuracy , tf.keras.metrics.SparseCategoricalAccuracy based on the loss function used and the model output shape. We do a similar conversion for the strings 'crossentropy' and 'ce' as well. required loss_weights Optional list or dictionary specifying scalar coefficients (Python floats) to weight the loss contributions of different model outputs. The loss value that will be minimized by the model will then be the weighted sum of all individual losses, weighted by the loss_weights coefficients. If a list, it is expected to have a 1:1 mapping to the model's outputs. If a dict, it is expected to map output names (strings) to scalar coefficients. required weighted_metrics List of metrics to be evaluated and weighted by sample_weight or class_weight during training and testing. required run_eagerly Bool. Defaults to False . If True , this Model 's logic will not be wrapped in a tf.function . Recommended to leave this as None unless your Model cannot be run inside a tf.function . required steps_per_execution Int. Defaults to 1. The number of batches to run during each tf.function call. Running multiple batches inside a single tf.function call can greatly improve performance on TPUs or small models with a large Python overhead. At most, one full epoch will be run each execution. If a number larger than the size of the epoch is passed, the execution will be truncated to the size of the epoch. Note that if steps_per_execution is set to N , Callback.on_batch_begin and Callback.on_batch_end methods will only be called every N batches (i.e. before/after each tf.function execution). required **kwargs Arguments supported for backwards compatibility only. {} Exceptions: Type Description ValueError In case of invalid arguments for optimizer , loss or metrics . fit ( self , x , y = None , ** kwargs ) inherited Trains the model for a fixed number of epochs (iterations on a dataset). Parameters: Name Type Description Default x Input data. It could be: - A Numpy array (or array-like), or a list of arrays (in case the model has multiple inputs). - A TensorFlow tensor, or a list of tensors (in case the model has multiple inputs). - A dict mapping input names to the corresponding array/tensors, if the model has named inputs. - A tf.data dataset. Should return a tuple of either (inputs, targets) or (inputs, targets, sample_weights) . - A generator or keras.utils.Sequence returning (inputs, targets) or (inputs, targets, sample_weights) . A more detailed description of unpacking behavior for iterator types (Dataset, generator, Sequence) is given below. required y Target data. Like the input data x , it could be either Numpy array(s) or TensorFlow tensor(s). It should be consistent with x (you cannot have Numpy inputs and tensor targets, or inversely). If x is a dataset, generator, or keras.utils.Sequence instance, y should not be specified (since targets will be obtained from x ). None batch_size Integer or None . Number of samples per gradient update. If unspecified, batch_size will default to 32. Do not specify the batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required epochs Integer. Number of epochs to train the model. An epoch is an iteration over the entire x and y data provided. Note that in conjunction with initial_epoch , epochs is to be understood as \"final epoch\". The model is not trained for a number of iterations given by epochs , but merely until the epoch of index epochs is reached. required verbose 0, 1, or 2. Verbosity mode. 0 = silent, 1 = progress bar, 2 = one line per epoch. Note that the progress bar is not particularly useful when logged to a file, so verbose=2 is recommended when not running interactively (eg, in a production environment). required callbacks List of keras.callbacks.Callback instances. List of callbacks to apply during training. See tf.keras.callbacks . Note tf.keras.callbacks.ProgbarLogger and tf.keras.callbacks.History callbacks are created automatically and need not be passed into model.fit . tf.keras.callbacks.ProgbarLogger is created or not based on verbose argument to model.fit . required validation_split Float between 0 and 1. Fraction of the training data to be used as validation data. The model will set apart this fraction of the training data, will not train on it, and will evaluate the loss and any model metrics on this data at the end of each epoch. The validation data is selected from the last samples in the x and y data provided, before shuffling. This argument is not supported when x is a dataset, generator or keras.utils.Sequence instance. required validation_data Data on which to evaluate the loss and any model metrics at the end of each epoch. The model will not be trained on this data. Thus, note the fact that the validation loss of data provided using validation_split or validation_data is not affected by regularization layers like noise and dropout. validation_data will override validation_split . validation_data could be: - tuple (x_val, y_val) of Numpy arrays or tensors - tuple (x_val, y_val, val_sample_weights) of Numpy arrays - dataset For the first two cases, batch_size must be provided. For the last case, validation_steps could be provided. Note that validation_data does not support all the data types that are supported in x , eg, dict, generator or keras.utils.Sequence . required shuffle Boolean (whether to shuffle the training data before each epoch) or str (for 'batch'). This argument is ignored when x is a generator. 'batch' is a special option for dealing with the limitations of HDF5 data; it shuffles in batch-sized chunks. Has no effect when steps_per_epoch is not None . required class_weight Optional dictionary mapping class indices (integers) to a weight (float) value, used for weighting the loss function (during training only). This can be useful to tell the model to \"pay more attention\" to samples from an under-represented class. required sample_weight Optional Numpy array of weights for the training samples, used for weighting the loss function (during training only). You can either pass a flat (1D) Numpy array with the same length as the input samples (1:1 mapping between weights and samples), or in the case of temporal data, you can pass a 2D array with shape (samples, sequence_length) , to apply a different weight to every timestep of every sample. This argument is not supported when x is a dataset, generator, or keras.utils.Sequence instance, instead provide the sample_weights as the third element of x . required initial_epoch Integer. Epoch at which to start training (useful for resuming a previous training run). required steps_per_epoch Integer or None . Total number of steps (batches of samples) before declaring one epoch finished and starting the next epoch. When training with input tensors such as TensorFlow data tensors, the default None is equal to the number of samples in your dataset divided by the batch size, or 1 if that cannot be determined. If x is a tf.data dataset, and 'steps_per_epoch' is None, the epoch will run until the input dataset is exhausted. When passing an infinitely repeating dataset, you must specify the steps_per_epoch argument. This argument is not supported with array inputs. required validation_steps Only relevant if validation_data is provided and is a tf.data dataset. Total number of steps (batches of samples) to draw before stopping when performing validation at the end of every epoch. If 'validation_steps' is None, validation will run until the validation_data dataset is exhausted. In the case of an infinitely repeated dataset, it will run into an infinite loop. If 'validation_steps' is specified and only part of the dataset will be consumed, the evaluation will start from the beginning of the dataset at each epoch. This ensures that the same validation samples are used every time. required validation_batch_size Integer or None . Number of samples per validation batch. If unspecified, will default to batch_size . Do not specify the validation_batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required validation_freq Only relevant if validation data is provided. Integer or collections_abc.Container instance (e.g. list, tuple, etc.). If an integer, specifies how many training epochs to run before a new validation run is performed, e.g. validation_freq=2 runs validation every 2 epochs. If a Container, specifies the epochs on which to run validation, e.g. validation_freq=[1, 2, 10] runs validation at the end of the 1st, 2nd, and 10th epochs. required max_queue_size Integer. Used for generator or keras.utils.Sequence input only. Maximum size for the generator queue. If unspecified, max_queue_size will default to 10. required workers Integer. Used for generator or keras.utils.Sequence input only. Maximum number of processes to spin up when using process-based threading. If unspecified, workers will default to 1. If 0, will execute the generator on the main thread. required use_multiprocessing Boolean. Used for generator or keras.utils.Sequence input only. If True , use process-based threading. If unspecified, use_multiprocessing will default to False . Note that because this implementation relies on multiprocessing, you should not pass non-picklable arguments to the generator as they can't be passed easily to children processes. required Unpacking behavior for iterator-like inputs: A common pattern is to pass a tf.data.Dataset, generator, or tf.keras.utils.Sequence to the x argument of fit, which will in fact yield not only features (x) but optionally targets (y) and sample weights. Keras requires that the output of such iterator-likes be unambiguous. The iterator should return a tuple of length 1, 2, or 3, where the optional second and third elements will be used for y and sample_weight respectively. Any other type provided will be wrapped in a length one tuple, effectively treating everything as 'x'. When yielding dicts, they should still adhere to the top-level tuple structure. e.g. ({\"x0\": x0, \"x1\": x1}, y) . Keras will not attempt to separate features, targets, and weights from the keys of a single dict. A notable unsupported data type is the namedtuple. The reason is that it behaves like both an ordered datatype (tuple) and a mapping datatype (dict). So given a namedtuple of the form: namedtuple(\"example_tuple\", [\"y\", \"x\"]) it is ambiguous whether to reverse the order of the elements when interpreting the value. Even worse is a tuple of the form: namedtuple(\"other_tuple\", [\"x\", \"y\", \"z\"]) where it is unclear if the tuple was intended to be unpacked into x, y, and sample_weight or passed through as a single element to x . As a result the data processing code will simply raise a ValueError if it encounters a namedtuple. (Along with instructions to remedy the issue.) Returns: Type Description A History object. Its History.history attribute is a record of training loss values and metrics values at successive epochs, as well as validation loss values and validation metrics values (if applicable). Exceptions: Type Description RuntimeError If the model was never compiled or, ValueError In case of mismatch between the provided input data and what the model expects or when the input data is empty. transform ( self , inputs ) inherited Map data (x) to latent space (z). Parameters: Name Type Description Default inputs A numpy array with input data. required Returns: Type Description A numpy array with the coordinates of the input data in latent space.","title":"ZINBVAE"},{"location":"api/models/ZINBVAE/#zinbvae","text":"","title":"ZINBVAE"},{"location":"api/models/ZINBVAE/#latent.models.vae.ZINBVAE","text":"Zero-inflated negative binomial variational autoencoder with fixed variational encoder and ZINB decoder networks.","title":"ZINBVAE"},{"location":"api/models/ZINBVAE/#latent.models.vae.ZINBVAE.__init__","text":"Parameters: Name Type Description Default decoder Keras/tensorflow model object that inputs the latent space and outputs the reconstructed data. If not provided, a default model will be constructed from the arguments. required name str String indicating the name of the model. 'nb_vae' x_dim int Integer indicating the number of features in the input data. None latent_dim int Integer indicating the number of dimensions in the latent space. 50 encoder_units Iterable[int] Integer list indicating the number of units of the encoder layers. Only used if encoder is not provided. [128, 128] decoder_units Iterable[int] An integer list indicating the number of units of the decoder layers. Only used if decoder is not provided. [128, 128] reconstruction_loss Callable Loss function applied to the reconstructed data and to be added by the decoder. Only used if decoder is not provided. Can also be added later by calling compile() . None use_conditions bool Boolean, whether to force the unpacking of conditions from the inputs. False dispersion Union[Literal['gene', 'cell-gene', 'constant'], float] One of the following: 'gene' - dispersion parameter of NB is constant per gene across cells 'cell-gene' - dispersion can differ for every gene in every cell 'constant' - dispersion is constant across all genes and cells float - numeric value of fixed dispersion parameter 'constant' kld_weight float Float indicating the weight of the KL Divergence regularization loss. 1e-05 prior Literal['normal', 'iaf', 'vamp'] The choice of prior distribution. One of the following: 'normal' - A unit gaussian (normal) distribution. 'iaf' - A unit gaussian with a Inverse Autoregressive Flows bijector ( Kingma 2016 ) 'vamp' - A variational mixture of posteriors (VAMP) prior ( Tomczak 2017 ) 'normal' latent_dist Literal['independent', 'multivariate'] The choice of latent distribution. One of the following: 'independent' - A independent normal produced by tfpl.IndependentNormal . 'multivariate' - A multivariate normal produced by tfpl.MultivariateNormalTriL . 'independent' iaf_units Iterable[int] Integer list indicating the units in the IAF bijector network. Only used if prior = 'iaf' . [256, 256] n_pseudoinputs int Integer indicating the number of pseudoinputs for the VAMP prior. Only used if prior = 'vamp' . 200 **kwargs Other arguments passed on to DenseStack for constructung encoder/ decoder networks. {}","title":"__init__()"},{"location":"api/models/ZINBVAE/#latent.models.vae.ZINBVAE.call","text":"Full forward pass through model","title":"call()"},{"location":"api/models/ZINBVAE/#latent.models.vae.ZINBVAE.compile","text":"Configures the model for training. Parameters: Name Type Description Default optimizer String (name of optimizer) or optimizer instance. See tf.keras.optimizers . 'adam' loss String (name of objective function), objective function or tf.keras.losses.Loss instance. See tf.keras.losses . An objective function is any callable with the signature loss = fn(y_true, y_pred) , where y_true = ground truth values with shape = [batch_size, d0, .. dN] , except sparse loss functions such as sparse categorical crossentropy where shape = [batch_size, d0, .. dN-1] . y_pred = predicted values with shape = [batch_size, d0, .. dN] . It returns a weighted loss float tensor. If a custom Loss instance is used and reduction is set to NONE, return value has the shape [batch_size, d0, .. dN-1] ie. per-sample or per-timestep loss values; otherwise, it is a scalar. If the model has multiple outputs, you can use a different loss on each output by passing a dictionary or a list of losses. The loss value that will be minimized by the model will then be the sum of all individual losses. None metrics List of metrics to be evaluated by the model during training and testing. Each of this can be a string (name of a built-in function), function or a tf.keras.metrics.Metric instance. See tf.keras.metrics . Typically you will use metrics=['accuracy'] . A function is any callable with the signature result = fn(y_true, y_pred) . To specify different metrics for different outputs of a multi-output model, you could also pass a dictionary, such as metrics={'output_a': 'accuracy', 'output_b': ['accuracy', 'mse']} . You can also pass a list (len = len(outputs)) of lists of metrics such as metrics=[['accuracy'], ['accuracy', 'mse']] or metrics=['accuracy', ['accuracy', 'mse']] . When you pass the strings 'accuracy' or 'acc', we convert this to one of tf.keras.metrics.BinaryAccuracy , tf.keras.metrics.CategoricalAccuracy , tf.keras.metrics.SparseCategoricalAccuracy based on the loss function used and the model output shape. We do a similar conversion for the strings 'crossentropy' and 'ce' as well. required loss_weights Optional list or dictionary specifying scalar coefficients (Python floats) to weight the loss contributions of different model outputs. The loss value that will be minimized by the model will then be the weighted sum of all individual losses, weighted by the loss_weights coefficients. If a list, it is expected to have a 1:1 mapping to the model's outputs. If a dict, it is expected to map output names (strings) to scalar coefficients. required weighted_metrics List of metrics to be evaluated and weighted by sample_weight or class_weight during training and testing. required run_eagerly Bool. Defaults to False . If True , this Model 's logic will not be wrapped in a tf.function . Recommended to leave this as None unless your Model cannot be run inside a tf.function . required steps_per_execution Int. Defaults to 1. The number of batches to run during each tf.function call. Running multiple batches inside a single tf.function call can greatly improve performance on TPUs or small models with a large Python overhead. At most, one full epoch will be run each execution. If a number larger than the size of the epoch is passed, the execution will be truncated to the size of the epoch. Note that if steps_per_execution is set to N , Callback.on_batch_begin and Callback.on_batch_end methods will only be called every N batches (i.e. before/after each tf.function execution). required **kwargs Arguments supported for backwards compatibility only. {} Exceptions: Type Description ValueError In case of invalid arguments for optimizer , loss or metrics .","title":"compile()"},{"location":"api/models/ZINBVAE/#latent.models.vae.ZINBVAE.fit","text":"Trains the model for a fixed number of epochs (iterations on a dataset). Parameters: Name Type Description Default x Input data. It could be: - A Numpy array (or array-like), or a list of arrays (in case the model has multiple inputs). - A TensorFlow tensor, or a list of tensors (in case the model has multiple inputs). - A dict mapping input names to the corresponding array/tensors, if the model has named inputs. - A tf.data dataset. Should return a tuple of either (inputs, targets) or (inputs, targets, sample_weights) . - A generator or keras.utils.Sequence returning (inputs, targets) or (inputs, targets, sample_weights) . A more detailed description of unpacking behavior for iterator types (Dataset, generator, Sequence) is given below. required y Target data. Like the input data x , it could be either Numpy array(s) or TensorFlow tensor(s). It should be consistent with x (you cannot have Numpy inputs and tensor targets, or inversely). If x is a dataset, generator, or keras.utils.Sequence instance, y should not be specified (since targets will be obtained from x ). None batch_size Integer or None . Number of samples per gradient update. If unspecified, batch_size will default to 32. Do not specify the batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required epochs Integer. Number of epochs to train the model. An epoch is an iteration over the entire x and y data provided. Note that in conjunction with initial_epoch , epochs is to be understood as \"final epoch\". The model is not trained for a number of iterations given by epochs , but merely until the epoch of index epochs is reached. required verbose 0, 1, or 2. Verbosity mode. 0 = silent, 1 = progress bar, 2 = one line per epoch. Note that the progress bar is not particularly useful when logged to a file, so verbose=2 is recommended when not running interactively (eg, in a production environment). required callbacks List of keras.callbacks.Callback instances. List of callbacks to apply during training. See tf.keras.callbacks . Note tf.keras.callbacks.ProgbarLogger and tf.keras.callbacks.History callbacks are created automatically and need not be passed into model.fit . tf.keras.callbacks.ProgbarLogger is created or not based on verbose argument to model.fit . required validation_split Float between 0 and 1. Fraction of the training data to be used as validation data. The model will set apart this fraction of the training data, will not train on it, and will evaluate the loss and any model metrics on this data at the end of each epoch. The validation data is selected from the last samples in the x and y data provided, before shuffling. This argument is not supported when x is a dataset, generator or keras.utils.Sequence instance. required validation_data Data on which to evaluate the loss and any model metrics at the end of each epoch. The model will not be trained on this data. Thus, note the fact that the validation loss of data provided using validation_split or validation_data is not affected by regularization layers like noise and dropout. validation_data will override validation_split . validation_data could be: - tuple (x_val, y_val) of Numpy arrays or tensors - tuple (x_val, y_val, val_sample_weights) of Numpy arrays - dataset For the first two cases, batch_size must be provided. For the last case, validation_steps could be provided. Note that validation_data does not support all the data types that are supported in x , eg, dict, generator or keras.utils.Sequence . required shuffle Boolean (whether to shuffle the training data before each epoch) or str (for 'batch'). This argument is ignored when x is a generator. 'batch' is a special option for dealing with the limitations of HDF5 data; it shuffles in batch-sized chunks. Has no effect when steps_per_epoch is not None . required class_weight Optional dictionary mapping class indices (integers) to a weight (float) value, used for weighting the loss function (during training only). This can be useful to tell the model to \"pay more attention\" to samples from an under-represented class. required sample_weight Optional Numpy array of weights for the training samples, used for weighting the loss function (during training only). You can either pass a flat (1D) Numpy array with the same length as the input samples (1:1 mapping between weights and samples), or in the case of temporal data, you can pass a 2D array with shape (samples, sequence_length) , to apply a different weight to every timestep of every sample. This argument is not supported when x is a dataset, generator, or keras.utils.Sequence instance, instead provide the sample_weights as the third element of x . required initial_epoch Integer. Epoch at which to start training (useful for resuming a previous training run). required steps_per_epoch Integer or None . Total number of steps (batches of samples) before declaring one epoch finished and starting the next epoch. When training with input tensors such as TensorFlow data tensors, the default None is equal to the number of samples in your dataset divided by the batch size, or 1 if that cannot be determined. If x is a tf.data dataset, and 'steps_per_epoch' is None, the epoch will run until the input dataset is exhausted. When passing an infinitely repeating dataset, you must specify the steps_per_epoch argument. This argument is not supported with array inputs. required validation_steps Only relevant if validation_data is provided and is a tf.data dataset. Total number of steps (batches of samples) to draw before stopping when performing validation at the end of every epoch. If 'validation_steps' is None, validation will run until the validation_data dataset is exhausted. In the case of an infinitely repeated dataset, it will run into an infinite loop. If 'validation_steps' is specified and only part of the dataset will be consumed, the evaluation will start from the beginning of the dataset at each epoch. This ensures that the same validation samples are used every time. required validation_batch_size Integer or None . Number of samples per validation batch. If unspecified, will default to batch_size . Do not specify the validation_batch_size if your data is in the form of datasets, generators, or keras.utils.Sequence instances (since they generate batches). required validation_freq Only relevant if validation data is provided. Integer or collections_abc.Container instance (e.g. list, tuple, etc.). If an integer, specifies how many training epochs to run before a new validation run is performed, e.g. validation_freq=2 runs validation every 2 epochs. If a Container, specifies the epochs on which to run validation, e.g. validation_freq=[1, 2, 10] runs validation at the end of the 1st, 2nd, and 10th epochs. required max_queue_size Integer. Used for generator or keras.utils.Sequence input only. Maximum size for the generator queue. If unspecified, max_queue_size will default to 10. required workers Integer. Used for generator or keras.utils.Sequence input only. Maximum number of processes to spin up when using process-based threading. If unspecified, workers will default to 1. If 0, will execute the generator on the main thread. required use_multiprocessing Boolean. Used for generator or keras.utils.Sequence input only. If True , use process-based threading. If unspecified, use_multiprocessing will default to False . Note that because this implementation relies on multiprocessing, you should not pass non-picklable arguments to the generator as they can't be passed easily to children processes. required Unpacking behavior for iterator-like inputs: A common pattern is to pass a tf.data.Dataset, generator, or tf.keras.utils.Sequence to the x argument of fit, which will in fact yield not only features (x) but optionally targets (y) and sample weights. Keras requires that the output of such iterator-likes be unambiguous. The iterator should return a tuple of length 1, 2, or 3, where the optional second and third elements will be used for y and sample_weight respectively. Any other type provided will be wrapped in a length one tuple, effectively treating everything as 'x'. When yielding dicts, they should still adhere to the top-level tuple structure. e.g. ({\"x0\": x0, \"x1\": x1}, y) . Keras will not attempt to separate features, targets, and weights from the keys of a single dict. A notable unsupported data type is the namedtuple. The reason is that it behaves like both an ordered datatype (tuple) and a mapping datatype (dict). So given a namedtuple of the form: namedtuple(\"example_tuple\", [\"y\", \"x\"]) it is ambiguous whether to reverse the order of the elements when interpreting the value. Even worse is a tuple of the form: namedtuple(\"other_tuple\", [\"x\", \"y\", \"z\"]) where it is unclear if the tuple was intended to be unpacked into x, y, and sample_weight or passed through as a single element to x . As a result the data processing code will simply raise a ValueError if it encounters a namedtuple. (Along with instructions to remedy the issue.) Returns: Type Description A History object. Its History.history attribute is a record of training loss values and metrics values at successive epochs, as well as validation loss values and validation metrics values (if applicable). Exceptions: Type Description RuntimeError If the model was never compiled or, ValueError In case of mismatch between the provided input data and what the model expects or when the input data is empty.","title":"fit()"},{"location":"api/models/ZINBVAE/#latent.models.vae.ZINBVAE.transform","text":"Map data (x) to latent space (z). Parameters: Name Type Description Default inputs A numpy array with input data. required Returns: Type Description A numpy array with the coordinates of the input data in latent space.","title":"transform()"},{"location":"api/modules/Decoder/","text":"Decoder latent.modules.decoder.Decoder Decoder base model. This model decompresses a latent space to reconstruct the input data by passing it through a DenseStack . It also takes care of adding the reconstruction loss to the model. __init__ ( self , x_dim , name = 'decoder' , hidden_units = [ 128 , 128 ], reconstruction_loss = None , loss_name = 'rec_loss' , initializer = 'glorot_normal' , ** kwargs ) special Parameters: Name Type Description Default x_dim int Integer indicating the number of dimensions in the input data. required name str String indicating the name of the model. 'decoder' hidden_units Iterable[int] Number of hidden units in DenseStack . If set to None the model skips the DenseStack and reduces to a linear decoder ( Svensson 2020 ). [128, 128] reconstruction_loss Union[Callable, str] Function to compute reconstruction loss. None loss_name str String indicating the name of the loss. 'rec_loss' initializer Union[str, Callable] Initializer for the kernel weights matrix (see keras.initializers ) 'glorot_normal' **kwargs Other arguments passed on to DenseStack {}","title":"Decoder"},{"location":"api/modules/Decoder/#decoder","text":"","title":"Decoder"},{"location":"api/modules/Decoder/#latent.modules.decoder.Decoder","text":"Decoder base model. This model decompresses a latent space to reconstruct the input data by passing it through a DenseStack . It also takes care of adding the reconstruction loss to the model.","title":"Decoder"},{"location":"api/modules/Decoder/#latent.modules.decoder.Decoder.__init__","text":"Parameters: Name Type Description Default x_dim int Integer indicating the number of dimensions in the input data. required name str String indicating the name of the model. 'decoder' hidden_units Iterable[int] Number of hidden units in DenseStack . If set to None the model skips the DenseStack and reduces to a linear decoder ( Svensson 2020 ). [128, 128] reconstruction_loss Union[Callable, str] Function to compute reconstruction loss. None loss_name str String indicating the name of the loss. 'rec_loss' initializer Union[str, Callable] Initializer for the kernel weights matrix (see keras.initializers ) 'glorot_normal' **kwargs Other arguments passed on to DenseStack {}","title":"__init__()"},{"location":"api/modules/Encoder/","text":"Encoder latent.modules.encoder.Encoder Encoder base class. This model compresses input data in a latent space with latent_dim dimensions by through passing it through a DenseStack . __init__ ( self , latent_dim = 50 , name = 'encoder' , initializer = 'glorot_normal' , ** kwargs ) special Parameters: Name Type Description Default latent_dim int Integer indicating the number of dimensions in the latent space. 50 name str String indicating the name of the model. 'encoder' initializer Union[str, Callable] Initializer for the kernel weights matrix (see keras.initializers ) 'glorot_normal' **kwargs Other arguments passed on to DenseStack {}","title":"Encoder"},{"location":"api/modules/Encoder/#encoder","text":"","title":"Encoder"},{"location":"api/modules/Encoder/#latent.modules.encoder.Encoder","text":"Encoder base class. This model compresses input data in a latent space with latent_dim dimensions by through passing it through a DenseStack .","title":"Encoder"},{"location":"api/modules/Encoder/#latent.modules.encoder.Encoder.__init__","text":"Parameters: Name Type Description Default latent_dim int Integer indicating the number of dimensions in the latent space. 50 name str String indicating the name of the model. 'encoder' initializer Union[str, Callable] Initializer for the kernel weights matrix (see keras.initializers ) 'glorot_normal' **kwargs Other arguments passed on to DenseStack {}","title":"__init__()"},{"location":"api/modules/NegativeBinomialDecoder/","text":"NegativeBinomialDecoder latent.modules.decoder.NegativeBinomialDecoder Decoder with negative binomial reconstruction loss. Uses size factors to deal with count data. __init__ ( self , x_dim , name = 'nb_decoder' , loss_name = 'nb_loss' , hidden_units = [ 128 , 128 ], initializer = 'glorot_normal' , dispersion = 'gene' , ** kwargs ) special Parameters: Name Type Description Default x_dim int Integer indicating the number of dimensions in the input data. required name str String indicating the name of the model. 'nb_decoder' hidden_units Iterable[int] Number of hidden units in DenseStack . If set to None the model skips the DenseStack and reduces to a linear decoder ( Svensson 2020 ). [128, 128] loss_name str String indicating the name of the loss. 'nb_loss' initializer Union[str, Callable] Initializer for the kernel weights matrix (see keras.initializers ) 'glorot_normal' dispersion Union[Literal['gene', 'cell-gene', 'constant'], float] One of the following: 'gene' - dispersion parameter of NB is constant per gene across cells 'cell-gene' - dispersion can differ for every gene in every cell 'constant' - dispersion is constant across all genes and cells float - numeric value of fixed dispersion parameter 'gene' **kwargs Other arguments passed on to DenseStack . {}","title":"NegativeBinomialDecoder"},{"location":"api/modules/NegativeBinomialDecoder/#negativebinomialdecoder","text":"","title":"NegativeBinomialDecoder"},{"location":"api/modules/NegativeBinomialDecoder/#latent.modules.decoder.NegativeBinomialDecoder","text":"Decoder with negative binomial reconstruction loss. Uses size factors to deal with count data.","title":"NegativeBinomialDecoder"},{"location":"api/modules/NegativeBinomialDecoder/#latent.modules.decoder.NegativeBinomialDecoder.__init__","text":"Parameters: Name Type Description Default x_dim int Integer indicating the number of dimensions in the input data. required name str String indicating the name of the model. 'nb_decoder' hidden_units Iterable[int] Number of hidden units in DenseStack . If set to None the model skips the DenseStack and reduces to a linear decoder ( Svensson 2020 ). [128, 128] loss_name str String indicating the name of the loss. 'nb_loss' initializer Union[str, Callable] Initializer for the kernel weights matrix (see keras.initializers ) 'glorot_normal' dispersion Union[Literal['gene', 'cell-gene', 'constant'], float] One of the following: 'gene' - dispersion parameter of NB is constant per gene across cells 'cell-gene' - dispersion can differ for every gene in every cell 'constant' - dispersion is constant across all genes and cells float - numeric value of fixed dispersion parameter 'gene' **kwargs Other arguments passed on to DenseStack . {}","title":"__init__()"},{"location":"api/modules/PoissonDecoder/","text":"PoissonDecoder latent.modules.decoder.PoissonDecoder Decoder with poisson reconstruction loss. Uses size factors to deal with count data. __init__ ( self , x_dim , name = 'poisson_decoder' , hidden_units = [ 128 , 128 ], reconstruction_loss = 'poisson' , loss_name = 'poisson_loss' , initializer = 'glorot_normal' , ** kwargs ) special Parameters: Name Type Description Default x_dim int Integer indicating the number of dimensions in the input data. required name str String indicating the name of the model. 'poisson_decoder' hidden_units Iterable[int] Number of hidden units in DenseStack . If set to None the model skips the DenseStack and reduces to a linear decoder ( Svensson 2020 ). [128, 128] reconstruction_loss Union[Callable, str] Function to compute reconstruction loss. 'poisson' loss_name str String indicating the name of the loss. 'poisson_loss' initializer Union[str, Callable] Initializer for the kernel weights matrix (see keras.initializers ) 'glorot_normal' **kwargs Other arguments passed on to DenseStack . {}","title":"PoissonDecoder"},{"location":"api/modules/PoissonDecoder/#poissondecoder","text":"","title":"PoissonDecoder"},{"location":"api/modules/PoissonDecoder/#latent.modules.decoder.PoissonDecoder","text":"Decoder with poisson reconstruction loss. Uses size factors to deal with count data.","title":"PoissonDecoder"},{"location":"api/modules/PoissonDecoder/#latent.modules.decoder.PoissonDecoder.__init__","text":"Parameters: Name Type Description Default x_dim int Integer indicating the number of dimensions in the input data. required name str String indicating the name of the model. 'poisson_decoder' hidden_units Iterable[int] Number of hidden units in DenseStack . If set to None the model skips the DenseStack and reduces to a linear decoder ( Svensson 2020 ). [128, 128] reconstruction_loss Union[Callable, str] Function to compute reconstruction loss. 'poisson' loss_name str String indicating the name of the loss. 'poisson_loss' initializer Union[str, Callable] Initializer for the kernel weights matrix (see keras.initializers ) 'glorot_normal' **kwargs Other arguments passed on to DenseStack . {}","title":"__init__()"},{"location":"api/modules/TopologicalEncoder/","text":"TopologicalEncoder latent.modules.encoder.TopologicalEncoder Encoder model with topological regularization loss on latent space ( Moor 2019 ). __init__ ( self , latent_dim = 50 , name = 'topological_encoder' , initializer = 'glorot_normal' , topo_weight = 1.0 , ** kwargs ) special Parameters: Name Type Description Default latent_dim int Integer indicating the number of dimensions in the latent space. 50 name str String indicating the name of the model. 'topological_encoder' initializer Union[str, Callable] Initializer for the kernel weights matrix (see keras.initializers ) 'glorot_normal' topo_weight float Float indicating the weight of the topological loss. 1.0 **kwargs Other arguments passed on to DenseStack {}","title":"TopologicalEncoder"},{"location":"api/modules/TopologicalEncoder/#topologicalencoder","text":"","title":"TopologicalEncoder"},{"location":"api/modules/TopologicalEncoder/#latent.modules.encoder.TopologicalEncoder","text":"Encoder model with topological regularization loss on latent space ( Moor 2019 ).","title":"TopologicalEncoder"},{"location":"api/modules/TopologicalEncoder/#latent.modules.encoder.TopologicalEncoder.__init__","text":"Parameters: Name Type Description Default latent_dim int Integer indicating the number of dimensions in the latent space. 50 name str String indicating the name of the model. 'topological_encoder' initializer Union[str, Callable] Initializer for the kernel weights matrix (see keras.initializers ) 'glorot_normal' topo_weight float Float indicating the weight of the topological loss. 1.0 **kwargs Other arguments passed on to DenseStack {}","title":"__init__()"},{"location":"api/modules/TopologicalVariationalEncoder/","text":"TopologicalVariationalEncoder latent.modules.encoder.VariationalEncoder Variational encoder. This model compresses input data by parameterizing a latent distribution that is regularized through a KL Divergence loss. __init__ ( self , latent_dim = 50 , name = 'variational_encoder' , initializer = 'glorot_normal' , kld_weight = 0.0001 , prior = 'normal' , latent_dist = 'independent' , iaf_units = [ 256 , 256 ], n_pseudoinputs = 200 , ** kwargs ) special Parameters: Name Type Description Default latent_dim int Integer indicating the number of dimensions in the latent space. 50 name str String indicating the name of the model. 'variational_encoder' initializer Union[str, Callable] Initializer for the kernel weights matrix (see keras.initializers ) 'glorot_normal' kld_weight float Float indicating the weight of the KL Divergence regularization loss. 0.0001 prior Literal['normal', 'iaf', 'vamp'] The choice of prior distribution. One of the following: 'normal' - A unit gaussian (normal) distribution. 'iaf' - A unit gaussian with a Inverse Autoregressive Flows bijector ( Kingma 2016 ) 'vamp' - A variational mixture of posteriors (VAMP) prior ( Tomczak 2017 ) 'normal' latent_dist Literal['independent', 'multivariate'] The choice of latent distribution. One of the following: 'independent' - A independent normal produced by tfpl.IndependentNormal . 'multivariate' - A multivariate normal produced by tfpl.MultivariateNormalTriL . 'independent' iaf_units Iterable[int] Integer list indicating the units in the IAF bijector network. Only used if prior = 'iaf' . [256, 256] n_pseudoinputs int Integer indicating the number of pseudoinputs for the VAMP prior. Only used if prior = 'vamp' . 200 **kwargs Other arguments passed on to DenseStack . {}","title":"TopologicalVariationalEncoder"},{"location":"api/modules/TopologicalVariationalEncoder/#topologicalvariationalencoder","text":"","title":"TopologicalVariationalEncoder"},{"location":"api/modules/TopologicalVariationalEncoder/#latent.modules.encoder.VariationalEncoder","text":"Variational encoder. This model compresses input data by parameterizing a latent distribution that is regularized through a KL Divergence loss.","title":"VariationalEncoder"},{"location":"api/modules/TopologicalVariationalEncoder/#latent.modules.encoder.VariationalEncoder.__init__","text":"Parameters: Name Type Description Default latent_dim int Integer indicating the number of dimensions in the latent space. 50 name str String indicating the name of the model. 'variational_encoder' initializer Union[str, Callable] Initializer for the kernel weights matrix (see keras.initializers ) 'glorot_normal' kld_weight float Float indicating the weight of the KL Divergence regularization loss. 0.0001 prior Literal['normal', 'iaf', 'vamp'] The choice of prior distribution. One of the following: 'normal' - A unit gaussian (normal) distribution. 'iaf' - A unit gaussian with a Inverse Autoregressive Flows bijector ( Kingma 2016 ) 'vamp' - A variational mixture of posteriors (VAMP) prior ( Tomczak 2017 ) 'normal' latent_dist Literal['independent', 'multivariate'] The choice of latent distribution. One of the following: 'independent' - A independent normal produced by tfpl.IndependentNormal . 'multivariate' - A multivariate normal produced by tfpl.MultivariateNormalTriL . 'independent' iaf_units Iterable[int] Integer list indicating the units in the IAF bijector network. Only used if prior = 'iaf' . [256, 256] n_pseudoinputs int Integer indicating the number of pseudoinputs for the VAMP prior. Only used if prior = 'vamp' . 200 **kwargs Other arguments passed on to DenseStack . {}","title":"__init__()"},{"location":"api/modules/VariationalEncoder/","text":"VariationalEncoder latent.modules.encoder.VariationalEncoder Variational encoder. This model compresses input data by parameterizing a latent distribution that is regularized through a KL Divergence loss. __init__ ( self , latent_dim = 50 , name = 'variational_encoder' , initializer = 'glorot_normal' , kld_weight = 0.0001 , prior = 'normal' , latent_dist = 'independent' , iaf_units = [ 256 , 256 ], n_pseudoinputs = 200 , ** kwargs ) special Parameters: Name Type Description Default latent_dim int Integer indicating the number of dimensions in the latent space. 50 name str String indicating the name of the model. 'variational_encoder' initializer Union[str, Callable] Initializer for the kernel weights matrix (see keras.initializers ) 'glorot_normal' kld_weight float Float indicating the weight of the KL Divergence regularization loss. 0.0001 prior Literal['normal', 'iaf', 'vamp'] The choice of prior distribution. One of the following: 'normal' - A unit gaussian (normal) distribution. 'iaf' - A unit gaussian with a Inverse Autoregressive Flows bijector ( Kingma 2016 ) 'vamp' - A variational mixture of posteriors (VAMP) prior ( Tomczak 2017 ) 'normal' latent_dist Literal['independent', 'multivariate'] The choice of latent distribution. One of the following: 'independent' - A independent normal produced by tfpl.IndependentNormal . 'multivariate' - A multivariate normal produced by tfpl.MultivariateNormalTriL . 'independent' iaf_units Iterable[int] Integer list indicating the units in the IAF bijector network. Only used if prior = 'iaf' . [256, 256] n_pseudoinputs int Integer indicating the number of pseudoinputs for the VAMP prior. Only used if prior = 'vamp' . 200 **kwargs Other arguments passed on to DenseStack . {}","title":"VariationalEncoder"},{"location":"api/modules/VariationalEncoder/#variationalencoder","text":"","title":"VariationalEncoder"},{"location":"api/modules/VariationalEncoder/#latent.modules.encoder.VariationalEncoder","text":"Variational encoder. This model compresses input data by parameterizing a latent distribution that is regularized through a KL Divergence loss.","title":"VariationalEncoder"},{"location":"api/modules/VariationalEncoder/#latent.modules.encoder.VariationalEncoder.__init__","text":"Parameters: Name Type Description Default latent_dim int Integer indicating the number of dimensions in the latent space. 50 name str String indicating the name of the model. 'variational_encoder' initializer Union[str, Callable] Initializer for the kernel weights matrix (see keras.initializers ) 'glorot_normal' kld_weight float Float indicating the weight of the KL Divergence regularization loss. 0.0001 prior Literal['normal', 'iaf', 'vamp'] The choice of prior distribution. One of the following: 'normal' - A unit gaussian (normal) distribution. 'iaf' - A unit gaussian with a Inverse Autoregressive Flows bijector ( Kingma 2016 ) 'vamp' - A variational mixture of posteriors (VAMP) prior ( Tomczak 2017 ) 'normal' latent_dist Literal['independent', 'multivariate'] The choice of latent distribution. One of the following: 'independent' - A independent normal produced by tfpl.IndependentNormal . 'multivariate' - A multivariate normal produced by tfpl.MultivariateNormalTriL . 'independent' iaf_units Iterable[int] Integer list indicating the units in the IAF bijector network. Only used if prior = 'iaf' . [256, 256] n_pseudoinputs int Integer indicating the number of pseudoinputs for the VAMP prior. Only used if prior = 'vamp' . 200 **kwargs Other arguments passed on to DenseStack . {}","title":"__init__()"},{"location":"api/modules/ZINBDecoder/","text":"ZINBDecoder latent.modules.decoder.ZINBDecoder Decoder with ZINB reconstruction loss. Uses size factors to deal with count data. __init__ ( self , x_dim , name = 'zinb_decoder' , loss_name = 'zinb_loss' , hidden_units = [ 128 , 128 ], initializer = 'glorot_normal' , dispersion = 'gene' , ** kwargs ) special Parameters: Name Type Description Default x_dim int Integer indicating the number of dimensions in the input data. required name str String indicating the name of the model. 'zinb_decoder' hidden_units Iterable[int] Number of hidden units in DenseStack . If set to None the model skips the DenseStack and reduces to a linear decoder ( Svensson 2020 ) [128, 128] loss_name str String indicating the name of the loss. 'zinb_loss' initializer Union[str, Callable] Initializer for the kernel weights matrix (see keras.initializers ) 'glorot_normal' dispersion Union[Literal['gene', 'cell-gene', 'constant'], float] One of the following: 'gene' - dispersion parameter of NB is constant per gene across cells 'cell-gene' - dispersion can differ for every gene in every cell 'constant' - dispersion is constant across all genes and cells float - numeric value of fixed dispersion parameter 'gene' **kwargs Other arguments passed on to DenseStack . {}","title":"ZINBDecoder"},{"location":"api/modules/ZINBDecoder/#zinbdecoder","text":"","title":"ZINBDecoder"},{"location":"api/modules/ZINBDecoder/#latent.modules.decoder.ZINBDecoder","text":"Decoder with ZINB reconstruction loss. Uses size factors to deal with count data.","title":"ZINBDecoder"},{"location":"api/modules/ZINBDecoder/#latent.modules.decoder.ZINBDecoder.__init__","text":"Parameters: Name Type Description Default x_dim int Integer indicating the number of dimensions in the input data. required name str String indicating the name of the model. 'zinb_decoder' hidden_units Iterable[int] Number of hidden units in DenseStack . If set to None the model skips the DenseStack and reduces to a linear decoder ( Svensson 2020 ) [128, 128] loss_name str String indicating the name of the loss. 'zinb_loss' initializer Union[str, Callable] Initializer for the kernel weights matrix (see keras.initializers ) 'glorot_normal' dispersion Union[Literal['gene', 'cell-gene', 'constant'], float] One of the following: 'gene' - dispersion parameter of NB is constant per gene across cells 'cell-gene' - dispersion can differ for every gene in every cell 'constant' - dispersion is constant across all genes and cells float - numeric value of fixed dispersion parameter 'gene' **kwargs Other arguments passed on to DenseStack . {}","title":"__init__()"},{"location":"notebooks/integration/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Integration of datasets from different batches is often a central step in a single cell analysis pipeline. In this notebook we are going to use a conditional variational autoencoder (CVAE) to integrate a single-cell dataset with significant batch effects. As demonstrated by scVI ( Lopez 18 ) CVAEs are very well suited for integration of single-cell data. By injecting the condition label into the encoder and decoder layer, the network is incentivized to only learn variation in the dataset that cannot be explained by the condition label. import numpy as np import scanpy as sc import tensorflow.keras as keras from sklearn import preprocessing as pp from latent.models import NegativeBinomialVAE as NBVAE ; We import all necessary dependencies, including the VariationalAutoencoder from LatentLego. Now we load the dataset with scanpy . Here, we use the dataset used in this scanpy tutorial , since it contains strong batch effects and has been usen in various papers on data integration. adata = sc . read ( 'data/pancreas.h5ad' , backup_url = 'https://www.dropbox.com/s/qj1jlm9w10wmt0u/pancreas.h5ad?dl=1' ) print ( adata ); AnnData object with n_obs \u00d7 n_vars = 14693 \u00d7 2448 obs: 'celltype', 'sample', 'n_genes', 'batch', 'n_counts', 'louvain' var: 'n_cells-0', 'n_cells-1', 'n_cells-2', 'n_cells-3' uns: 'celltype_colors', 'louvain', 'neighbors', 'pca', 'sample_colors' obsm: 'X_pca', 'X_umap' varm: 'PCs' obsp: 'distances', 'connectivities' Data preprocessing As a first step, we preprocess the data and visualize it using UMAP, so we can appreciate the batch effects. sc . pp . highly_variable_genes ( adata , n_top_genes = 2000 ) sc . pp . pca ( adata ) sc . pp . neighbors ( adata ) sc . tl . umap ( adata ); Now we plot the UMAP representation of the data. sc . pl . umap ( adata , color = [ 'batch' , 'celltype' ]) We can clearly see that a major part of the variation in this dataset is driven by batch and celltypes from different batches do not co-cluster at all. This is a good indicatior that integration of the different batches is necessary for downstream analysis. Preparing the data Currently, LatentLego is mostly an addon to TensorFlow/Keras and provides no interface to work with AnnData objects directly. I will probably add that in a future version though. For now, we have to extract and prepare the model inputs manually. # Select highly variable genes highvar = adata . raw . var . index . isin ( adata . var . index ) # Extract unscaled data X_use = np . array ( adata . raw . X [:, highvar ] . todense ()) # Calculate size factors n_umis = X_use . sum ( 1 ) size_factors = n_umis / np . median ( n_umis ) # Get batch label and format to one-hot encoded matrix cond = adata . obs [ 'batch' ] . values le = pp . LabelEncoder () cond = le . fit_transform ( cond ) cond = keras . utils . to_categorical ( cond ) print ( cond ) [[1. 0. 0. 0.] [1. 0. 0. 0.] [1. 0. 0. 0.] ... [0. 0. 0. 1.] [0. 0. 0. 1.] [0. 0. 0. 1.]] Fit the model Now we prepare the model as well as a callback for early stopping and the optimizer. With conditional = 'all' , we tell the model to inject the condition in every hidden layer of the encoder and decoder networks. We also use a conditional version of the VAMP prior ( Tomczak 2017 ) that has been shown to perform well on single cell data ( Dony 2020 ). # Initiate keras callback function and optimizer es_callback = keras . callbacks . EarlyStopping ( monitor = 'loss' , min_delta = 0.001 , patience = 10 , verbose = 0 , mode = 'auto' , baseline = None , restore_best_weights = False ) optimizer = keras . optimizers . Adam ( learning_rate = 0.0002 ) # Initiate autoencoder autoencoder = NBVAE ( x_dim = X_use . shape [ 1 ], encoder_units = [ 256 , 128 ], decoder_units = [ 128 , 256 ], latent_dim = 10 , kld_weight = 1e-3 , conditional = 'all' , prior = 'vamp' , n_pseudoinputs = 50 , dispersion = 'gene' ) autoencoder . compile ( optimizer = optimizer , run_eagerly = False ) Now we train the keras model the model (depending on where you are running this, this might take a while ;)) history = autoencoder . fit ( [ X_use , cond , size_factors ], batch_size = 50 , epochs = 100 , use_multiprocessing = True , workers = 30 , callbacks = [ es_callback ], verbose = False ); Now we can use the .transform() method to obtain the latent representation. We'll add that to the AnnData object and use UMAP to further reduce it to 2D. latent = autoencoder . transform ([ X_use , cond ]) adata . obsm [ 'X_ae' ] = latent sc . pp . neighbors ( adata , use_rep = 'X_ae' , n_neighbors = 30 ) sc . tl . umap ( adata , min_dist = 0.1 , spread = 0.5 ) And plot the result: p = sc . pl . scatter ( adata , show = False , basis = 'umap' , color = [ 'celltype' , 'batch' ]) We can see that the batches are integrated a lot better while preserving a good separation of celltypes. We can of course also use a 'regular' variational autoencoder with a standard normal prior. However, with the same weight of the KLD loss, the latent representation will be 'smoother' and the celltypes are less well separated. # Initiate autoencoder autoencoder = NBVAE ( x_dim = X_use . shape [ 1 ], encoder_units = [ 256 , 128 ], decoder_units = [ 128 , 256 ], latent_dim = 10 , kld_weight = 1e-3 , conditional = 'all' , dispersion = 'gene' ) autoencoder . compile ( optimizer = optimizer , run_eagerly = False ) history = autoencoder . fit ( [ X_use , cond , size_factors ], batch_size = 50 , epochs = 100 , use_multiprocessing = True , workers = 30 , callbacks = [ es_callback ], verbose = False ); latent = autoencoder . transform ([ X_use , cond ]) adata . obsm [ 'X_ae' ] = latent sc . pp . neighbors ( adata , use_rep = 'X_ae' , n_neighbors = 30 ) sc . tl . umap ( adata , min_dist = 0.1 , spread = 0.5 ) p = sc . pl . scatter ( adata , show = False , basis = 'umap' , color = [ 'celltype' , 'batch' ])","title":"Integration"},{"location":"notebooks/integration/#data-preprocessing","text":"As a first step, we preprocess the data and visualize it using UMAP, so we can appreciate the batch effects. sc . pp . highly_variable_genes ( adata , n_top_genes = 2000 ) sc . pp . pca ( adata ) sc . pp . neighbors ( adata ) sc . tl . umap ( adata ); Now we plot the UMAP representation of the data. sc . pl . umap ( adata , color = [ 'batch' , 'celltype' ]) We can clearly see that a major part of the variation in this dataset is driven by batch and celltypes from different batches do not co-cluster at all. This is a good indicatior that integration of the different batches is necessary for downstream analysis.","title":"Data preprocessing"},{"location":"notebooks/integration/#preparing-the-data","text":"Currently, LatentLego is mostly an addon to TensorFlow/Keras and provides no interface to work with AnnData objects directly. I will probably add that in a future version though. For now, we have to extract and prepare the model inputs manually. # Select highly variable genes highvar = adata . raw . var . index . isin ( adata . var . index ) # Extract unscaled data X_use = np . array ( adata . raw . X [:, highvar ] . todense ()) # Calculate size factors n_umis = X_use . sum ( 1 ) size_factors = n_umis / np . median ( n_umis ) # Get batch label and format to one-hot encoded matrix cond = adata . obs [ 'batch' ] . values le = pp . LabelEncoder () cond = le . fit_transform ( cond ) cond = keras . utils . to_categorical ( cond ) print ( cond ) [[1. 0. 0. 0.] [1. 0. 0. 0.] [1. 0. 0. 0.] ... [0. 0. 0. 1.] [0. 0. 0. 1.] [0. 0. 0. 1.]]","title":"Preparing the data"},{"location":"notebooks/integration/#fit-the-model","text":"Now we prepare the model as well as a callback for early stopping and the optimizer. With conditional = 'all' , we tell the model to inject the condition in every hidden layer of the encoder and decoder networks. We also use a conditional version of the VAMP prior ( Tomczak 2017 ) that has been shown to perform well on single cell data ( Dony 2020 ). # Initiate keras callback function and optimizer es_callback = keras . callbacks . EarlyStopping ( monitor = 'loss' , min_delta = 0.001 , patience = 10 , verbose = 0 , mode = 'auto' , baseline = None , restore_best_weights = False ) optimizer = keras . optimizers . Adam ( learning_rate = 0.0002 ) # Initiate autoencoder autoencoder = NBVAE ( x_dim = X_use . shape [ 1 ], encoder_units = [ 256 , 128 ], decoder_units = [ 128 , 256 ], latent_dim = 10 , kld_weight = 1e-3 , conditional = 'all' , prior = 'vamp' , n_pseudoinputs = 50 , dispersion = 'gene' ) autoencoder . compile ( optimizer = optimizer , run_eagerly = False ) Now we train the keras model the model (depending on where you are running this, this might take a while ;)) history = autoencoder . fit ( [ X_use , cond , size_factors ], batch_size = 50 , epochs = 100 , use_multiprocessing = True , workers = 30 , callbacks = [ es_callback ], verbose = False ); Now we can use the .transform() method to obtain the latent representation. We'll add that to the AnnData object and use UMAP to further reduce it to 2D. latent = autoencoder . transform ([ X_use , cond ]) adata . obsm [ 'X_ae' ] = latent sc . pp . neighbors ( adata , use_rep = 'X_ae' , n_neighbors = 30 ) sc . tl . umap ( adata , min_dist = 0.1 , spread = 0.5 ) And plot the result: p = sc . pl . scatter ( adata , show = False , basis = 'umap' , color = [ 'celltype' , 'batch' ]) We can see that the batches are integrated a lot better while preserving a good separation of celltypes. We can of course also use a 'regular' variational autoencoder with a standard normal prior. However, with the same weight of the KLD loss, the latent representation will be 'smoother' and the celltypes are less well separated. # Initiate autoencoder autoencoder = NBVAE ( x_dim = X_use . shape [ 1 ], encoder_units = [ 256 , 128 ], decoder_units = [ 128 , 256 ], latent_dim = 10 , kld_weight = 1e-3 , conditional = 'all' , dispersion = 'gene' ) autoencoder . compile ( optimizer = optimizer , run_eagerly = False ) history = autoencoder . fit ( [ X_use , cond , size_factors ], batch_size = 50 , epochs = 100 , use_multiprocessing = True , workers = 30 , callbacks = [ es_callback ], verbose = False ); latent = autoencoder . transform ([ X_use , cond ]) adata . obsm [ 'X_ae' ] = latent sc . pp . neighbors ( adata , use_rep = 'X_ae' , n_neighbors = 30 ) sc . tl . umap ( adata , min_dist = 0.1 , spread = 0.5 ) p = sc . pl . scatter ( adata , show = False , basis = 'umap' , color = [ 'celltype' , 'batch' ])","title":"Fit the model"}]}